<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Linux Sysadmin</title><link href="http://www.linuxsysadmin.tk/" rel="alternate"></link><link href="http://www.linuxsysadmin.tk/feeds/all.atom.xml" rel="self"></link><id>http://www.linuxsysadmin.tk/</id><updated>2016-03-21T08:00:00+01:00</updated><entry><title>Creando un entorno escalable (IV)</title><link href="http://www.linuxsysadmin.tk/2016/03/creando-un-entorno-escalable-4.html" rel="alternate"></link><updated>2016-03-21T08:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-03-21:2016/03/creando-un-entorno-escalable-4.html</id><summary type="html">&lt;p&gt;Acabamos el artículo anterior de esta serie con las aplicaciones corriendo en sus respectivas máquinas. En este artículo vamos a poner una fachada a todo el sistema, mediante un &lt;em&gt;proxy HTTP&lt;/em&gt; que haga las funciones de terminación &lt;em&gt;SSL&lt;/em&gt; y de &lt;em&gt;balanceador&lt;/em&gt;, exponiendo todo el sistema en una sola dirección IP.&lt;/p&gt;
&lt;p&gt;Como &lt;em&gt;proxy HTTP&lt;/em&gt; tenemos varias opciones; solo se necesita un servidor web que soporte &lt;em&gt;virtual hosts&lt;/em&gt;, protocolo HTTP sobre SSL, capacidad de hacer de &lt;em&gt;proxy&lt;/em&gt; y capacidad para balancear las peticiones entre varias opciones.&lt;/p&gt;
&lt;p&gt;Si analizamos estos requisitos, podemos comprobar que las opciones son muchas; desde el todopoderoso &lt;strong&gt;apache&lt;/strong&gt; al &lt;strong&gt;nginx&lt;/strong&gt;, pasando por soluciones de balanceador puro como &lt;strong&gt;haproxy&lt;/strong&gt;, u opciones mas esotéricas como &lt;strong&gt;squid&lt;/strong&gt;. En este caso, se utiliza &lt;strong&gt;nginx&lt;/strong&gt; por su facilidad de uso y su bajo consumo de recursos. Cumple con el subconjunto básico de funcionalidades necesario, pero no dispone de tantos algoritmos de balanceo como otras opciones.&lt;/p&gt;
&lt;h2&gt;Instalación de paquetes&lt;/h2&gt;
&lt;p&gt;Empezamos instalando los requisitos para nuestra fachada; en principio solo se necesitaría el servidor web &lt;strong&gt;nginx&lt;/strong&gt; (en la versión mínima) y &lt;strong&gt;openssl&lt;/strong&gt; para generar los certificados. Adicionalmente instalaremos &lt;strong&gt;curl&lt;/strong&gt; para comprobar que el resultado es correcto.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@frontend:~# apt-get install nginx-light curl
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias
Leyendo la información de estado... Hecho
Se instalarán los siguientes paquetes extras:
  ca-certificates libcurl3 libffi6 libgmp10 libgnutls-deb0-28 libhogweed2 libidn11 libldap-2.4-2 libnettle4 libp11-kit0 librtmp1
  libsasl2-2 libsasl2-modules libsasl2-modules-db libssh2-1 libtasn1-6 nginx-common openssl
Paquetes sugeridos:
  gnutls-bin libsasl2-modules-otp libsasl2-modules-ldap libsasl2-modules-sql libsasl2-modules-gssapi-mit
  libsasl2-modules-gssapi-heimdal fcgiwrap nginx-doc ssl-cert
Se instalarán los siguientes paquetes NUEVOS:
  ca-certificates curl libcurl3 libffi6 libgmp10 libgnutls-deb0-28 libhogweed2 libidn11 libldap-2.4-2 libnettle4 libp11-kit0
  librtmp1 libsasl2-2 libsasl2-modules libsasl2-modules-db libssh2-1 libtasn1-6 nginx-common nginx-light openssl
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;20&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar 4.077 kB de archivos.
Se utilizarán 8.832 kB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
root@frontend:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El paquete &lt;strong&gt;nginx&lt;/strong&gt; de la distribución &lt;em&gt;Debian&lt;/em&gt; viene con una configuración por defecto en &lt;em&gt;/etc/nginx/sites-enabled/&lt;/em&gt;, que vamos a eliminar para evitar que se pise con nuestras configuraciones.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@frontend:~# ls -lh /etc/nginx/sites-enabled/
total 0
lrwxrwxrwx &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;34&lt;/span&gt; feb &lt;span class="m"&gt;26&lt;/span&gt; 11:28 default -&amp;gt; /etc/nginx/sites-available/default
root@frontend:~# unlink /etc/nginx/sites-enabled/default
root@frontend:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Consideraciones de seguridad&lt;/h2&gt;
&lt;p&gt;Cuando nuestro servidor web recibe una petición, va a iniciar una nueva conexión contra el servidor de &lt;em&gt;backend&lt;/em&gt; que toque o el de &lt;em&gt;backoffice&lt;/em&gt;. Para habilitar esto, se necesitan nuevas reglas en el &lt;em&gt;firewall&lt;/em&gt;, que en este caso es &lt;strong&gt;firehol&lt;/strong&gt;, instalado en la máquina anfitriona.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/firehol/firehol.conf
...  
&lt;span class="nv"&gt;app_servers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;10.0.0.3 10.0.0.4 10.0.0.5&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;frontend_server&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;10.0.0.2&amp;quot;&lt;/span&gt;
...
router internal inface lxc0 outface lxc0
...  
    route webcache accept src &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$frontend_server&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; dst &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$app_servers&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
root@lxc:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;No os olvidéis de reiniciar &lt;strong&gt;firehol&lt;/strong&gt;, para que se apliquen las nuevas reglas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# service firehol restart
...  
root@lxc:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Montando los virtualhosts de ambas aplicaciones&lt;/h2&gt;
&lt;p&gt;La parte privada va a estar escondida tras una terminación &lt;strong&gt;HTTPS&lt;/strong&gt;. Esa aplicación se podría esconder tras una &lt;a href="http://www.linuxsysadmin.tk/2016/02/restringiendo-accesos-mediante-certificados-de-cliente.html"&gt;autenticación de certificados cliente&lt;/a&gt; o mediante &lt;a href="http://www.linuxsysadmin.tk/2016/02/restringiendo-accesos-web-mediante-autenticacion-basica.html"&gt;autenticación básica&lt;/a&gt;. Por simplicidad vamos a usar esta última.&lt;/p&gt;
&lt;p&gt;Empezamos generando un certificado autofirmado para el servidor web, directamente firmado, y su clave. Fijaos que no generamos ningún certificado de CA, ya que no tenemos ninguna intención de generar autenticación cliente en el futuro.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@frontend:~# openssl req -new -newkey rsa:2048 -days &lt;span class="m"&gt;365&lt;/span&gt; -nodes -x509 -keyout server.key -out server.crt -subj &lt;span class="s2"&gt;&amp;quot;/C=ES/ST=Spain/L=Barcelona/O=LinuxSysadmin/CN=shop.linuxsysadmin.tk&amp;quot;&lt;/span&gt;
Generating a &lt;span class="m"&gt;2048&lt;/span&gt; bit RSA private key
.......................................+++
.................................................................................................................................................................+++
writing new private key to &lt;span class="s1"&gt;&amp;#39;server.key&amp;#39;&lt;/span&gt;
-----
root@frontend:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ponemos la clave y el certificado generado en sus respectivas localizaciones, de acuerdo a los estándares.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@frontend:~# cp server.key /etc/ssl/private/
root@frontend:~# cp server.crt /etc/ssl/certs/
root@frontend:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como verificación, así quedaría la carpeta &lt;em&gt;/etc/ssl/&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@frontend:~# tree /etc/ssl/
/etc/ssl/
├── certs
│   └── server.crt
├── openssl.cnf
└── private
    └── server.key

&lt;span class="m"&gt;2&lt;/span&gt; directories, &lt;span class="m"&gt;3&lt;/span&gt; files
root@frontend:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para poder autenticar mediante autenticación básica, generamos un usuario en un fichero tipo &lt;strong&gt;htpasswd&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@frontend:~# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;admin:&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;openssl passwd -crypt s3cr3t&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &amp;gt; /etc/nginx/shop.basic_auth
root@frontend:~# cat /etc/nginx/shop.basic_auth
admin:rOU9H0ABEB2H6
root@frontend:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con todas las piezas listas, montamos los virtualhosts, en un fichero de configuración o en varios, según nos apetezca.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@frontend:~# cat /etc/nginx/sites-enabled/shop
upstream backends &lt;span class="o"&gt;{&lt;/span&gt;
        server backend1:8080&lt;span class="p"&gt;;&lt;/span&gt;
        server backend2:8080&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

server &lt;span class="o"&gt;{&lt;/span&gt;
        listen &lt;span class="m"&gt;80&lt;/span&gt; default_server&lt;span class="p"&gt;;&lt;/span&gt;
        server_name _&lt;span class="p"&gt;;&lt;/span&gt;

        location / &lt;span class="o"&gt;{&lt;/span&gt;
                proxy_pass http://backends&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

server &lt;span class="o"&gt;{&lt;/span&gt;
        listen &lt;span class="m"&gt;443&lt;/span&gt; ssl&lt;span class="p"&gt;;&lt;/span&gt;
        server_name _&lt;span class="p"&gt;;&lt;/span&gt;

        ssl_certificate /etc/ssl/certs/server.crt&lt;span class="p"&gt;;&lt;/span&gt;
        ssl_certificate_key /etc/ssl/private/server.key&lt;span class="p"&gt;;&lt;/span&gt;

        auth_basic &lt;span class="s2"&gt;&amp;quot;Admin Area&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        auth_basic_user_file /etc/nginx/shop.basic_auth&lt;span class="p"&gt;;&lt;/span&gt;

        location / &lt;span class="o"&gt;{&lt;/span&gt;
                proxy_pass http://backoffice:8080&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
root@frontend:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La configuración es bastante estándar; se trata de un &lt;em&gt;server&lt;/em&gt; (equivalente en &lt;strong&gt;nginx&lt;/strong&gt; a un &lt;em&gt;virtualhost&lt;/em&gt; de &lt;strong&gt;apache&lt;/strong&gt;) para cada protocolo. La parte de administración es solamente la mediación &lt;strong&gt;SSL&lt;/strong&gt; y un &lt;em&gt;proxy_pass&lt;/em&gt; hacia el &lt;em&gt;backoffice&lt;/em&gt;. La parte de la API pública también se limita a hacer un &lt;em&gt;proxy_pass&lt;/em&gt;, solo que se hace contra &lt;em&gt;backends&lt;/em&gt; que es un objeto &lt;strong&gt;upstream&lt;/strong&gt;, que es el que define el balanceador.&lt;/p&gt;
&lt;p&gt;Ahora solo queda reiniciar el servidor web para aplicar los cambios. De acuerdo a la documentación, habría bastado un &lt;em&gt;reload&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@frontend:~# service nginx restart
root@frontend:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Comprobando que las aplicaciones funcionan&lt;/h2&gt;
&lt;p&gt;Para comprobar que la parte de la API funciona y balancea adecuadamente, basta con hacer peticiones. Podemos comprobar el &lt;em&gt;backend&lt;/em&gt; que la ha servido porque la aplicación pone una cabecera que especifica el nombre del &lt;em&gt;host&lt;/em&gt; que la resolvió. Con dos peticiones veremos que va alternativamente a cada &lt;em&gt;backend&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@frontend:~# curl -i http://localhost/products/
HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; OK
Server: nginx/1.6.2
Date: Fri, &lt;span class="m"&gt;26&lt;/span&gt; Feb &lt;span class="m"&gt;2016&lt;/span&gt; 11:04:38 GMT
Content-Type: application/json
Content-Length: 3
Connection: keep-alive
Backend: backend1

&lt;span class="o"&gt;[]&lt;/span&gt;
root@frontend:~# curl -i http://localhost/products/
HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; OK
Server: nginx/1.6.2
Date: Fri, &lt;span class="m"&gt;26&lt;/span&gt; Feb &lt;span class="m"&gt;2016&lt;/span&gt; 11:04:40 GMT
Content-Type: application/json
Content-Length: 3
Connection: keep-alive
Backend: backend2

&lt;span class="o"&gt;[]&lt;/span&gt;
root@frontend:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para la parte privada, haremos la petición, de la misma manera; vamos a añadir el flag &lt;em&gt;-k&lt;/em&gt; para sobrepasar el certificado autofirmado. Como no hemos indicado el usuario y la contraseña, nos devuelve un error 401, que indica que no estamos autorizados a pasar mas allá.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@frontend:~# curl -i -k https://localhost/products
HTTP/1.1 &lt;span class="m"&gt;401&lt;/span&gt; Unauthorized
Server: nginx/1.6.2
Date: Fri, &lt;span class="m"&gt;26&lt;/span&gt; Feb &lt;span class="m"&gt;2016&lt;/span&gt; 11:05:35 GMT
Content-Type: text/html
Content-Length: 194
Connection: keep-alive
WWW-Authenticate: Basic &lt;span class="nv"&gt;realm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Admin Area&amp;quot;&lt;/span&gt;

&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;401 Authorization Required&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body &lt;span class="nv"&gt;bgcolor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;white&amp;quot;&lt;/span&gt;&amp;gt;
&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;401 Authorization Required&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;
&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/1.6.2&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
root@frontend:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto parece que funciona, a falta de probar con un navegador adecuado.&lt;/p&gt;
&lt;h2&gt;Un pequeño detalle: abrimos los puertos&lt;/h2&gt;
&lt;p&gt;Puesto que este entorno está montado sobre virtualización &lt;strong&gt;LXC&lt;/strong&gt;, necesitamos que la dirección IP de la maquina anfitriona exponga los puertos de la máquina &lt;em&gt;frontend&lt;/em&gt;. Para ello hay que habilitar un mecanismo que se llama &lt;em&gt;port forwarding&lt;/em&gt;, coloquialmente conocido como "abrir el puerto".&lt;/p&gt;
&lt;p&gt;Mediante una directiva de &lt;strong&gt;firehol&lt;/strong&gt; indicamos que pasaremos todas las peticiones recibidas a los puertos 80 y 443 directamente a la máquina de &lt;em&gt;frontend&lt;/em&gt;. Hay que habilitar ese tráfico de &lt;strong&gt;FORWARD&lt;/strong&gt;, mediante otras reglas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/firehol/firehol.conf
...
&lt;span class="nv"&gt;frontend_server&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;10.0.0.2&amp;quot;&lt;/span&gt;
...
dnat to &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$frontend_server&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; proto tcp dport 80
dnat to &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$frontend_server&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; proto tcp dport 443
...
router world2lan inface eth0 outface lxc0
    route http accept dst &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$frontend_server&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
    route https accept dst &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$frontend_server&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
...
root@lxc:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y nuevamente reiniciamos el servicio para aplicar las nuevas reglas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# service firehol restart
...
root@lxc:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Accediendo a las aplicaciones en la IP pública&lt;/h2&gt;
&lt;p&gt;Vamos a acceder con un navegador a la parte de administración, para ver que funciona y para rellenar algunos datos, para que se vea una respuesta de la API con fundamento.&lt;/p&gt;
&lt;p&gt;El primer paso consiste en abrir el navegador con la URL adecuada, y nos tropezamos con la autenticación.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Auth basic" src="http://www.linuxsysadmin.tk/images/entorno-escalable-auth-basic.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Tras pasar la autenticación podemos acceder a los formularios para añadir productos.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Admin form" src="http://www.linuxsysadmin.tk/images/entorno-escalable-admin-form.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Tras añadir tres productos, vemos que ya se genera la lista, en formato web.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Admin list" src="http://www.linuxsysadmin.tk/images/entorno-escalable-admin-list.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Con los datos introducidos podemos consumir la API, para comprobar que los datos que hemos introducido en la base de datos (mediante la aplicación de administración) están disponibles.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;wget -qO- http://192.168.1.232/products/
&lt;span class="o"&gt;[&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="s2"&gt;&amp;quot;price&amp;quot;&lt;/span&gt;: 1.5, 
        &lt;span class="s2"&gt;&amp;quot;_id&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;123&amp;quot;&lt;/span&gt;, 
        &lt;span class="s2"&gt;&amp;quot;description&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;Apples&amp;quot;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;, 
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="s2"&gt;&amp;quot;price&amp;quot;&lt;/span&gt;: 1.0, 
        &lt;span class="s2"&gt;&amp;quot;_id&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;456&amp;quot;&lt;/span&gt;, 
        &lt;span class="s2"&gt;&amp;quot;description&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;Oranges&amp;quot;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;, 
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="s2"&gt;&amp;quot;price&amp;quot;&lt;/span&gt;: 2.0, 
        &lt;span class="s2"&gt;&amp;quot;_id&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;789&amp;quot;&lt;/span&gt;, 
        &lt;span class="s2"&gt;&amp;quot;description&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;Pears&amp;quot;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;]&lt;/span&gt;
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y consultando un producto concreto, también funciona como debe.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;wget -qO- http://192.168.1.232/products/456
&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;price&amp;quot;&lt;/span&gt;: 1.0, 
    &lt;span class="s2"&gt;&amp;quot;_id&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;456&amp;quot;&lt;/span&gt;, 
    &lt;span class="s2"&gt;&amp;quot;description&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;Oranges&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto comprobamos que todo queda en su sitio. Solo hará falta limpiar cualquier desecho que hayamos dejado en &lt;em&gt;/root/&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Y con este artículo cerramos la serie.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="proxy http"></category><category term="balanceador"></category><category term="ssl"></category><category term="nginx"></category><category term="virtual hosts"></category><category term="port forwarding"></category></entry><entry><title>Creando un entorno escalable (III)</title><link href="http://www.linuxsysadmin.tk/2016/03/creando-un-entorno-escalable-3.html" rel="alternate"></link><updated>2016-03-14T08:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-03-14:2016/03/creando-un-entorno-escalable-3.html</id><summary type="html">&lt;p&gt;En el artículo anterior de esta serie montamos el cluster de la base de datos que íbamos a necesitar para las aplicaciones que conformaban este entorno de ejemplo. Ahora que tenemos la base de datos, falta poner los servidores de aplicaciones que sirven nuestras aplicaciones y que usan el cluster.&lt;/p&gt;
&lt;p&gt;Las aplicaciones que pretendemos servir son aplicaciones hechas en &lt;strong&gt;python&lt;/strong&gt;, siguiendo el protocolo &lt;strong&gt;WSGI&lt;/strong&gt;. Para ir rápidos, ambas utilizan el &lt;em&gt;framework&lt;/em&gt; &lt;strong&gt;bottle&lt;/strong&gt;. En realidad, nos sirve cualquier &lt;em&gt;framework&lt;/em&gt; que construya aplicaciones &lt;strong&gt;WSGI&lt;/strong&gt; estándares, de acuerdo al protocolo. Estas aplicaciones se conectan a la base de datos antes creadas para resolver las peticiones, mediante el &lt;em&gt;driver&lt;/em&gt; de &lt;strong&gt;mongodb&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Desde el punto de vista de entrada al servidor, ambas aplicaciones se van a servir mediante el protocolo &lt;strong&gt;HTTP&lt;/strong&gt; en puerto TCP 8080. Hay muchos servidores que sirven aplicaciones &lt;strong&gt;WSGI&lt;/strong&gt;, por ejemplo, &lt;strong&gt;Apache mod_wsgi&lt;/strong&gt;, &lt;strong&gt;gunicorn&lt;/strong&gt; o &lt;strong&gt;uWSGI&lt;/strong&gt;. De hecho hay docenas de ellos, casi todos capaces de servir aplicaciones &lt;strong&gt;WSGI&lt;/strong&gt; en un puerto cualquiera TCP.&lt;/p&gt;
&lt;p&gt;En este caso, usaremos un servidor de aplicaciones &lt;strong&gt;uWSGI&lt;/strong&gt; que, aunque es un poco mas complicado que &lt;strong&gt;gunicorn&lt;/strong&gt; (y menos que &lt;strong&gt;mod_wsgi&lt;/strong&gt;), me tiene enamorado. Destaco especialmente el modo de funcionamiento &lt;em&gt;emperador&lt;/em&gt; y la capacidad de usar un &lt;em&gt;virtualenv&lt;/em&gt; distinto para cada aplicación servida. De hecho, puede servir diferentes lenguajes y/o versiones, una por cada aplicación.&lt;/p&gt;
&lt;h2&gt;Instalar el servidor de aplicaciones&lt;/h2&gt;
&lt;p&gt;Este paso se repite en las máquinas &lt;em&gt;backend1&lt;/em&gt;, &lt;em&gt;backend2&lt;/em&gt; y  &lt;em&gt;backoffice&lt;/em&gt;; aunque cada una va a servir una aplicación distinta, el servidor de aplicaciones es el mismo. En puntos posteriores pondremos y activaremos las aplicaciones.&lt;/p&gt;
&lt;p&gt;El servidor &lt;strong&gt;uWSGI&lt;/strong&gt; está disponible en los repositorios oficiales de &lt;em&gt;Debian Jessie&lt;/em&gt;. Vamos a instalarlo con un &lt;em&gt;init script&lt;/em&gt; que levante un emperador y le vamos a añadir el &lt;em&gt;plugin&lt;/em&gt; para servir &lt;strong&gt;python&lt;/strong&gt; (en la versión 2.7, según podemos ver).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:~# apt-get install uwsgi-emperor uwsgi-plugin-python
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias
Leyendo la información de estado... Hecho
Se instalarán los siguientes paquetes extras:
  file libexpat1 libffi6 libjansson4 libmagic1 libmatheval1 libpgm-5.1-0 libpython2.7 libpython2.7-minimal libpython2.7-stdlib
  libsodium13 libsqlite3-0 libxml2 libyaml-0-2 libzmq3 mime-support sgml-base uwsgi-core xml-core
Paquetes sugeridos:
  sgml-base-doc nginx-full cherokee libapache2-mod-proxy-uwsgi libapache2-mod-uwsgi libapache2-mod-ruwsgi uwsgi-plugins-all
  uwsgi-extra python-uwsgidecorators debhelper
Se instalarán los siguientes paquetes NUEVOS:
  file libexpat1 libffi6 libjansson4 libmagic1 libmatheval1 libpgm-5.1-0 libpython2.7 libpython2.7-minimal libpython2.7-stdlib
  libsodium13 libsqlite3-0 libxml2 libyaml-0-2 libzmq3 mime-support sgml-base uwsgi-core uwsgi-emperor uwsgi-plugin-python
  xml-core
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;21&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar 6.608 kB de archivos.
Se utilizarán 25,9 MB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
root@backend1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto ya tenemos el servidor de aplicaciones en funcionamiento. Las instancias se declaran con un fichero de configuración en &lt;em&gt;/etc/uwsgi-emperor/vassals/&lt;/em&gt;, que haremos mas adelante.&lt;/p&gt;
&lt;h2&gt;Consideraciones de seguridad&lt;/h2&gt;
&lt;p&gt;Estas aplicaciones usarán el &lt;em&gt;driver&lt;/em&gt; &lt;strong&gt;pymongo&lt;/strong&gt; para conectar a las instancias de &lt;strong&gt;mongodb&lt;/strong&gt;. Para eso hay que habilitar el tráfico relativo (de los servidores de aplicaciones a los de mongodb, por el puerto TCP 27017).&lt;/p&gt;
&lt;p&gt;En nuestro caso, como estamos trabajando con &lt;strong&gt;LXC&lt;/strong&gt;, lo haremos desde el &lt;em&gt;host&lt;/em&gt;, mediante la modificación de las reglas de &lt;em&gt;firehol&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/firehol/firehol.conf
&lt;span class="nv"&gt;mongo_servers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;10.0.0.5 10.0.0.6 10.0.0.7&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;app_servers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;10.0.0.3 10.0.0.4 10.0.0.5&amp;quot;&lt;/span&gt;
...  
router internal inface lxc0 outface lxc0
...  
      route custom mongodb tcp/27017 default accept src &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$app_servers&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; dst &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$mongo_servers&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
...  
root@lxc:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;No os olvidéis de reiniciar el servicio &lt;em&gt;firehol&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Instalando las aplicaciones&lt;/h2&gt;
&lt;p&gt;Este punto se hace en los tres servidores que sirven aplicaciones (&lt;em&gt;backend1&lt;/em&gt;, &lt;em&gt;backend2&lt;/em&gt; y &lt;em&gt;backoffice&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Las aplicaciones de ejemplo que vamos a usar las podéis encontrar en &lt;a href="http://www.linuxsysadmin.tk/downloads/shop.tar.gz"&gt;este enlace&lt;/a&gt;. Debo admitir que no son bonitas, pero para esta demostración, nos valen.&lt;/p&gt;
&lt;p&gt;Descomprimimos el fichero comprimido con las dos aplicaciones.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:~# tar xzf shop.tar.gz
root@backend1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esta es la estructura que queda tras descomprimir:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:~# tree
.
├── shop
│   ├── requirements.txt
│   ├── shop_admin
│   │   ├── app.py
│   │   └── views
│   │       ├── index.tpl
│   │       ├── product_form.tpl
│   │       └── product_list.tpl
│   └── shop_api
│       └── app.py
└── shop.tar.gz

&lt;span class="m"&gt;4&lt;/span&gt; directories, &lt;span class="m"&gt;7&lt;/span&gt; files
root@backend1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esta estructura tiene las dos aplicaciones. Cada tipo de servidor usará solo una por simplicidad, así que borraremos la que no se utilice, de acuerdo al tipo de servidor.&lt;/p&gt;
&lt;p&gt;En resumen, vamos a poner la carpeta &lt;em&gt;shop&lt;/em&gt; en &lt;em&gt;/opt/&lt;/em&gt;, y vamos a poner dentro el &lt;em&gt;virtualenv&lt;/em&gt; con las librerías necesarias.&lt;/p&gt;
&lt;p&gt;Como buena &lt;em&gt;praxis&lt;/em&gt;, vamos a instalar las librerías en un &lt;em&gt;virtualenv&lt;/em&gt; dedicado por aplicación. Para ello necesitamos la herramienta, que puede salir del repositorio oficial o lo podemos descargar, para usarlo y desecharlo posteriormente. Podemos encontrar el paquete en &lt;a href="https://pypi.python.org/packages/source/v/virtualenv/virtualenv-14.0.6.tar.gz#md5=a035037925c82990a7659ecf8764bcdb"&gt;este enlace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lo descomprimimos y lo dejamos ahí, para que los puntos específicos para cada servidor lo usen a su antojo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:~# tar xzf virtualenv-14.0.6.tar.gz
root@backend1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El &lt;em&gt;script&lt;/em&gt; de creación del &lt;em&gt;virtualenv&lt;/em&gt; se ejecuta con &lt;strong&gt;python&lt;/strong&gt;; así que también lo necesitamos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:~# apt-get install python
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias
Leyendo la información de estado... Hecho
Se instalarán los siguientes paquetes extras:
  libpython-stdlib python-minimal python2.7 python2.7-minimal
Paquetes sugeridos:
  python-doc python-tk python2.7-doc binutils binfmt-support
Se instalarán los siguientes paquetes NUEVOS:
  libpython-stdlib python python-minimal python2.7 python2.7-minimal
0 actualizados, 5 nuevos se instalarán, 0 para eliminar y 0 no actualizados.
Se necesita descargar 1.854 kB de archivos.
Se utilizarán 5.131 kB de espacio de disco adicional después de esta operación.
¿Desea continuar? [S/n] s
..
root@backend1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Veamos ahora los puntos específicos por tipo de aplicación.&lt;/p&gt;
&lt;h3&gt;Aplicación de backend: la API pública&lt;/h3&gt;
&lt;p&gt;Este punto se ejecuta solamente en los &lt;em&gt;backends&lt;/em&gt; (&lt;em&gt;backend1&lt;/em&gt; y &lt;em&gt;backend2&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Eliminamos la aplicación de administración, que no se usa en los &lt;em&gt;backends&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:~# rm -R shop/shop_admin/
root@backend1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Así nos queda la carpeta:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:~# tree shop
shop
├── requirements.txt
└── shop_api
    └── app.py

&lt;span class="m"&gt;1&lt;/span&gt; directory, &lt;span class="m"&gt;2&lt;/span&gt; files
root@backend1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Copiamos la carpeta a &lt;em&gt;/opt/&lt;/em&gt; que va a ser su emplazamiento habitual.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:~# cp -R shop/ /opt/
root@backend1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a trabajar ya desde la carpeta contenedora del proyecto.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:~# &lt;span class="nb"&gt;cd&lt;/span&gt; /opt/shop/
root@backend1:/opt/shop#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El siguiente paso es crear el conjunto de librerías necesarias, construyendo un &lt;em&gt;virtualenv&lt;/em&gt; con las librerías. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:/opt/shop# /root/virtualenv-14.0.6/virtualenv.py env
New python executable in /opt/shop/env/bin/python
Installing setuptools, pip, wheel...done.
root@backend1:/opt/shop#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Activamos el entorno virtual para instalar las librerías declaradas en el fichero &lt;em&gt;requirements.txt&lt;/em&gt;. Luego salimos del entorno.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:/opt/shop# . env/bin/activate
&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; root@backend1:/opt/shop# pip install -r requirements.txt
Collecting &lt;span class="nv"&gt;bottle&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;0.12.9 &lt;span class="o"&gt;(&lt;/span&gt;from -r requirements.txt &lt;span class="o"&gt;(&lt;/span&gt;line 1&lt;span class="o"&gt;))&lt;/span&gt;
...
Installing collected packages: bottle, pymongo
Successfully installed bottle-0.12.9 pymongo-3.2
&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; root@backend1:/opt/shop# deactivate
root@backend1:/opt/shop#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y para evitarnos problemas de permisos, uniformizamos el propietario de la carpeta:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:~# chown -R www-data:www-data /opt/shop/
root@backend1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Con todo lo necesario para levantar la aplicación, la declaramos como &lt;em&gt;vasallo&lt;/em&gt; del &lt;em&gt;emperador&lt;/em&gt;; el mismo &lt;strong&gt;emperador&lt;/strong&gt; va a levantar un proceso para servir esa configuración.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:/opt/shop# cat /etc/uwsgi-emperor/vassals/shop_api.ini
&lt;span class="o"&gt;[&lt;/span&gt;uwsgi&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;plugin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; python
http-socket &lt;span class="o"&gt;=&lt;/span&gt; 0.0.0.0:8080
&lt;span class="nv"&gt;master&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="nv"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 2
&lt;span class="nv"&gt;virtualenv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; /opt/shop/env
&lt;span class="nv"&gt;chdir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; /opt/shop/shop_api
&lt;span class="nv"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; app:app
root@backend1:/opt/shop#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y podemos comprobar que todo funciona como debe haciendo una petición a la &lt;strong&gt;API&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backend1:~# curl -i http://localhost:8080/products/
HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; OK
Content-Length: 3
Content-Type: application/json
Backend: backend1

&lt;span class="o"&gt;[]&lt;/span&gt;
root@backend1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Aplicación de backoffice: la interfaz de administración&lt;/h3&gt;
&lt;p&gt;Este punto aplica solamente a la máquina &lt;em&gt;backoffice&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;El proceso es análogo al de los &lt;em&gt;backends&lt;/em&gt;; quitamos la aplicación que no vamos a utilizar.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backoffice:~# rm -R shop/shop_api/
root@backoffice:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Así nos queda la carpeta:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backoffice:~# tree shop
shop
├── requirements.txt
└── shop_admin
    ├── app.py
    └── views
        ├── index.tpl
        ├── product_form.tpl
        └── product_list.tpl

&lt;span class="m"&gt;2&lt;/span&gt; directories, &lt;span class="m"&gt;5&lt;/span&gt; files
root@backoffice:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La transferimos a la carpeta &lt;em&gt;/opt/&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backoffice:~# cp -R shop/ /opt/
root@backoffice:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nos situamos en la carpeta contenedora:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backoffice:~# &lt;span class="nb"&gt;cd&lt;/span&gt; /opt/shop/
root@backoffice:/opt/shop#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Creamos el &lt;em&gt;virtualenv&lt;/em&gt; en la carpeta contenedora.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backoffice:/opt/shop# /root/virtualenv-14.0.6/virtualenv.py env
New python executable in /opt/shop/env/bin/python
Installing setuptools, pip, wheel...done.
root@backoffice:/opt/shop#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y le instalamos las librerías necesarias, declaradas en el fichero &lt;em&gt;requirements.txt&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backoffice:/opt/shop# . env/bin/activate
&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; root@backoffice:/opt/shop# pip install -r requirements.txt
Collecting &lt;span class="nv"&gt;bottle&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;0.12.9 &lt;span class="o"&gt;(&lt;/span&gt;from -r requirements.txt &lt;span class="o"&gt;(&lt;/span&gt;line 1&lt;span class="o"&gt;))&lt;/span&gt;
...
Installing collected packages: bottle, pymongo
Successfully installed bottle-0.12.9 pymongo-3.2
&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; root@backoffice:/opt/shop# deactivate
root@backoffice:/opt/shop#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Actualizamos el propietario de la aplicación &lt;strong&gt;WSGI&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backoffice:/opt/shop# chown -R www-data:www-data /opt/shop/
root@backoffice:/opt/shop#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y creamos el fichero de configuración del &lt;em&gt;vasallo&lt;/em&gt;, para que lo levante el &lt;em&gt;emperador&lt;/em&gt;, quedando así:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backoffice:/opt/shop# cat /etc/uwsgi-emperor/vassals/shop_admin.ini
&lt;span class="o"&gt;[&lt;/span&gt;uwsgi&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;plugin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; python
http-socket &lt;span class="o"&gt;=&lt;/span&gt; 0.0.0.0:8080
&lt;span class="nv"&gt;master&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="nv"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 2
&lt;span class="nv"&gt;virtualenv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; /opt/shop/env
&lt;span class="nv"&gt;chdir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; /opt/shop/shop_admin
&lt;span class="nv"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; app:app
root@backoffice:/opt/shop#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y comprobamos que obtenemos la página web que se espera:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@backoffice:~# curl -i http://localhost:8080/
HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; OK
Content-Length: 33
Content-Type: text/html&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;charset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;UTF-8

&amp;lt;a &lt;span class="nv"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/products&amp;quot;&lt;/span&gt;&amp;gt;Products&amp;lt;/a&amp;gt;
root@backoffice:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto hemos acabado con las aplicaciones. Nuevamente, todo lo que queda en la carpeta &lt;em&gt;/root/&lt;/em&gt; es desechable.&lt;/p&gt;
&lt;p&gt;En el siguiente artículo vamos a montar el &lt;em&gt;proxy&lt;/em&gt;/balanceador que va a actuar como fachada de todo el sistema.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="WSGI"></category><category term="uWSGI"></category><category term="python"></category><category term="virtualenv"></category><category term="firehol"></category></entry><entry><title>Creando un entorno escalable (II)</title><link href="http://www.linuxsysadmin.tk/2016/03/creando-un-entorno-escalable-2.html" rel="alternate"></link><updated>2016-03-07T08:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-03-07:2016/03/creando-un-entorno-escalable-2.html</id><summary type="html">&lt;p&gt;Seguimos con la serie de montar un entorno escalable. Tras explicar en el primer artículo lo que vamos a montar, seguimos con ello. En este artículo vamos a montar un &lt;em&gt;cluster&lt;/em&gt; de bases de datos; será &lt;strong&gt;mongodb&lt;/strong&gt; porque la aplicación lo requiere y usará la topología de un &lt;strong&gt;replica set&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Este artículo se basa enormemente en &lt;a href="http://www.linuxsysadmin.tk/2015/12/construyendo-una-replica-set-en-mongodb.html"&gt;otro artículo&lt;/a&gt; que ya publicamos, al que vamos a añadir algunas mejoras reflejadas en otros.&lt;/p&gt;
&lt;p&gt;Como ya vimos en el artículo referido, solo necesitamos levantar un proceso &lt;em&gt;mongod&lt;/em&gt; en cada una de las máquinas, para posteriormente casarlos entre sí.&lt;/p&gt;
&lt;h2&gt;Levantando los procesos de mongodb&lt;/h2&gt;
&lt;p&gt;Este punto se repite en las máquinas que van a formar la &lt;strong&gt;replica set&lt;/strong&gt;, que son &lt;em&gt;mongo1&lt;/em&gt;, &lt;em&gt;mongo2&lt;/em&gt; y &lt;em&gt;backoffice&lt;/em&gt;. Vamos a seguir solamente una de ellas; el resto son análogas.&lt;/p&gt;
&lt;p&gt;Crearemos una estructura en &lt;em&gt;/opt/&lt;/em&gt; para alojar los binarios, las configuraciones, los datos y los logs.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# mkdir -p /opt/mongodb/&lt;span class="o"&gt;{&lt;/span&gt;bin,conf,data,logs&lt;span class="o"&gt;}&lt;/span&gt;
root@mongo1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En la carpeta de binarios vamos a poner el único que se necesita: el &lt;em&gt;mongod&lt;/em&gt;. Lo podemos sacar descomprimiendo el 
fichero comprimido &lt;em&gt;.tar.gz&lt;/em&gt; de la página de descargas de &lt;strong&gt;mongodb&lt;/strong&gt;. En nuestro caso concreto, lo he sacado de &lt;a href="https://fastdl.mongodb.org/linux/mongodb-linux-i686-3.2.3.tgz"&gt;https://fastdl.mongodb.org/linux/mongodb-linux-i686-3.2.3.tgz&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# cp mongodb-linux-i686-3.2.3/bin/mongod /opt/mongodb/bin/
root@mongo1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ponemos un fichero de configuración para la instancia que queremos correr. Esta configuración puede variar mucho, pero un ejemplo básico para salir del paso con una máquina de 32 bits (que no soportan &lt;em&gt;WiredTiger&lt;/em&gt;) podría ser:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# cat /opt/mongodb/conf/mongo.conf
systemLog:
    path: /opt/mongodb/logs/mongo.log
    logAppend: &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="nb"&gt;    &lt;/span&gt;destination: file

net:
    port: 27017
    bindIp: 0.0.0.0

storage:
    dbPath: /opt/mongodb/data/
    engine: mmapv1
    mmapv1:
        smallFiles: &lt;span class="nb"&gt;true&lt;/span&gt;

replication:
    replSetName: rs
root@mongo1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Truco&lt;/strong&gt;: Es un buen momento para montar un sistema de ficheros alternativo para almacenar los datos, sea poner &lt;a href="http://www.linuxsysadmin.tk/2016/01/lvm-logical-volume-manager.html"&gt;LVM&lt;/a&gt; (para tener crecimiento dinámico o &lt;a href="http://www.linuxsysadmin.tk/2016/02/haciendo-snapshots-con-lvm.html"&gt;snapshots&lt;/a&gt;, sea un &lt;a href="http://www.linuxsysadmin.tk/2015/12/construyendo-un-raid-10-en-linux.html"&gt;RAID&lt;/a&gt; (por ejemplo para tener alto rendimiento y/o replicación de datos), o incluso ambos.&lt;/p&gt;
&lt;p&gt;Cumpliendo con una política de seguridad básica, vamos a crear un usuario de sistema para correr el proceso.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# useradd -s /usr/sbin/nologin -r -M mongo -d /opt/mongodb/
root@mongo1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Le damos la propiedad de toda la estructura de &lt;strong&gt;mongodb&lt;/strong&gt;, para ahorrarnos problemas de permisos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# chown -R mongo:mongo /opt/mongodb/
root@mongo1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y ya como resumen, ponemos una salida para ver como nos queda la estructura:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# tree /opt/mongodb/
/opt/mongodb/
├── bin
│   └── mongod
├── conf
│   └── mongo.conf
├── data
└── logs

&lt;span class="m"&gt;4&lt;/span&gt; directories, &lt;span class="m"&gt;2&lt;/span&gt; files
root@mongo1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El último paso consiste en crear una &lt;em&gt;unit&lt;/em&gt; en &lt;strong&gt;systemd&lt;/strong&gt; (o un &lt;em&gt;init script&lt;/em&gt;, dependiendo de la distribución usada; de hecho, cada máquina puede ir con una distribución distinta).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# cat /etc/systemd/system/mongo.service
&lt;span class="o"&gt;[&lt;/span&gt;Unit&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;MongoDB

&lt;span class="o"&gt;[&lt;/span&gt;Service&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;mongo
&lt;span class="nv"&gt;LimitFSIZE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitCPU&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitNOFILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;LimitNPROC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;ExecStartPre&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/bin/rm -f /opt/mongodb/data/mongod.lock
&lt;span class="nv"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/opt/mongodb/bin/mongod -f /opt/mongodb/conf/mongo.conf

&lt;span class="o"&gt;[&lt;/span&gt;Install&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;multi-user.target
root@mongo1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Lo activamos para que se levante solo en los siguientes arranques, y lo levantamos para la sesión actual.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# systemctl &lt;span class="nb"&gt;enable &lt;/span&gt;mongo
Created symlink from /etc/systemd/system/multi-user.target.wants/mongo.service to /etc/systemd/system/mongo.service.
root@mongo1:~# systemctl start mongo
root@mongo1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Repetid este paso en las otras máquinas de &lt;strong&gt;mongodb&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Consideraciones de seguridad&lt;/h2&gt;
&lt;p&gt;Para que una &lt;strong&gt;replica set&lt;/strong&gt; funcione como debe, todos los procesos deben comunicarse entre sí. Como los hemos puesto en el mismo puerto, podemos agruparlo todo en una sola regla.&lt;/p&gt;
&lt;p&gt;Como en nuestro caso estamos virtualizando con &lt;strong&gt;LXC&lt;/strong&gt;, vamos a controlar el tráfico con el &lt;strong&gt;firehol&lt;/strong&gt; de la máquina anfitriona.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;...
root@lxc:~# cat /etc/firehol/firehol.conf
&lt;span class="nv"&gt;mongo_servers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;10.0.0.5 10.0.0.6 10.0.0.7&amp;quot;&lt;/span&gt;
...  
router internal inface lxc0 outface lxc0
    route custom mongodb tcp/27017 default accept src &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$mongo_servers&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; dst &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$mongo_servers&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
...
root@lxc:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Acordaos de reiniciar &lt;strong&gt;firehol&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Atando la replica set&lt;/h2&gt;
&lt;p&gt;Este paso se ejecuta en una sola máquina, que va a reproducir los cambios a las demás, por efecto de la &lt;strong&gt;replica set&lt;/strong&gt;. Por ejemplo, lo hago en &lt;em&gt;mongo1&lt;/em&gt;, por hacer alguna.&lt;/p&gt;
&lt;p&gt;Entramos en el &lt;em&gt;mongo shell&lt;/em&gt;, desde donde lanzaremos el resto de comandos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# ./mongodb-linux-i686-3.2.3/bin/mongo
MongoDB shell version: 3.2.3
connecting to: &lt;span class="nb"&gt;test&lt;/span&gt;
Welcome to the MongoDB shell.
For interactive &lt;span class="nb"&gt;help&lt;/span&gt;, &lt;span class="nb"&gt;type&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;help&amp;quot;&lt;/span&gt;.
...
&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Siguiendo los pasos estándares, creamos una configuración vacía en la máquina elegida, y añadimos las otras dos. Tened en cuenta que la máquina &lt;em&gt;backoffice&lt;/em&gt; se declara como un árbitro, por decisión de diseño.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt; rs.initiate&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="s2"&gt;&amp;quot;info2&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;no configuration specified. Using a default configuration for the set&amp;quot;&lt;/span&gt;,
        &lt;span class="s2"&gt;&amp;quot;me&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;mongo1:27017&amp;quot;&lt;/span&gt;,
        &lt;span class="s2"&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; : 1
&lt;span class="o"&gt;}&lt;/span&gt;
rs:SECONDARY&amp;gt; rs.add&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mongo2:27017&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; : &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
rs:PRIMARY&amp;gt; rs.addArb&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;backoffice:27017&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; : &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
rs:PRIMARY&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Podemos verificar que todo está bien mediante el comando &lt;em&gt;rs.status()&lt;/em&gt;, como sigue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;rs:PRIMARY&amp;gt; rs.status&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="s2"&gt;&amp;quot;set&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;rs&amp;quot;&lt;/span&gt;,
...  
        &lt;span class="s2"&gt;&amp;quot;members&amp;quot;&lt;/span&gt; : &lt;span class="o"&gt;[&lt;/span&gt;
                &lt;span class="o"&gt;{&lt;/span&gt;
...  
                        &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;mongo1:27017&amp;quot;&lt;/span&gt;,
                        &lt;span class="s2"&gt;&amp;quot;stateStr&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;PRIMARY&amp;quot;&lt;/span&gt;,
...  
                &lt;span class="o"&gt;}&lt;/span&gt;,
                &lt;span class="o"&gt;{&lt;/span&gt;
...  
                        &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;mongo2:27017&amp;quot;&lt;/span&gt;,
                        &lt;span class="s2"&gt;&amp;quot;stateStr&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;SECONDARY&amp;quot;&lt;/span&gt;,
...  
                &lt;span class="o"&gt;}&lt;/span&gt;,
                &lt;span class="o"&gt;{&lt;/span&gt;
...  
                        &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;backoffice:27017&amp;quot;&lt;/span&gt;,
                        &lt;span class="s2"&gt;&amp;quot;stateStr&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;ARBITER&amp;quot;&lt;/span&gt;,
...  
                &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;]&lt;/span&gt;,
        &lt;span class="s2"&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; : 1
&lt;span class="o"&gt;}&lt;/span&gt;
rs:PRIMARY&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y salimos del &lt;em&gt;mongo shell&lt;/em&gt;, que ya no necesitamos; las aplicaciones de &lt;em&gt;backend&lt;/em&gt; y de &lt;em&gt;backoffice&lt;/em&gt; ya incluyen una librería para conectarse por sí mismos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;rs:PRIMARY&amp;gt; &lt;span class="nb"&gt;exit&lt;/span&gt;
bye
root@mongo1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Todo lo que queda en &lt;em&gt;/root/&lt;/em&gt; es innecesario y se puede borrar. De todas formas podemos dejar el resto de binarios en &lt;em&gt;/opt/mongodb/&lt;/em&gt; en alguna de las máquinas por si acaso.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;El siguiente paso va a ser montar los servidores de aplicaciones en los backends y en el backoffice&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="mongodb"></category><category term="replica set"></category><category term="systemd"></category><category term="firehol"></category></entry><entry><title>Creando un entorno escalable (I)</title><link href="http://www.linuxsysadmin.tk/2016/02/creando-un-entorno-escalable.html" rel="alternate"></link><updated>2016-02-29T08:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-02-29:2016/02/creando-un-entorno-escalable.html</id><summary type="html">&lt;p&gt;Mucha gente tiene un servidor único para alojar páginas web dinámicas, por ejemplo con &lt;strong&gt;PHP&lt;/strong&gt; y con &lt;strong&gt;MySQL&lt;/strong&gt;. Sin embargo, a veces esto puede resultar insuficiente; nos puede interesar tener un entorno de bajas especificaciones y de bajo coste, pero preparado crecer al mismo ritmo que lo hacen los usuarios.&lt;/p&gt;
&lt;p&gt;En este caso, el truco consiste en hacer trabajar a varias máquinas como si fueran una sola, escondidas en una o varias subredes privadas y poniendo un representante único de todo el sistema (que es el que va a recibir &lt;strong&gt;todas&lt;/strong&gt; las peticiones).&lt;/p&gt;
&lt;p&gt;Este representante suele ser lo que llamamos un &lt;strong&gt;balanceador de carga&lt;/strong&gt;, cuya función es repartir el trabajo entre varios servidores de &lt;strong&gt;backend&lt;/strong&gt;. Al tratarse solo de un "policía de tráfico" su rendimiento es elevado con unas especificaciones modestas, mientras que los servidores de &lt;strong&gt;backend&lt;/strong&gt; consiguen resolver las mismas peticiones por unidad de tiempo; la mejora reside en que pueden haber varios servidores de &lt;strong&gt;backend&lt;/strong&gt; resolviendo peticiones en paralelo.&lt;/p&gt;
&lt;p&gt;Normalmente, estos servidores de &lt;strong&gt;backend&lt;/strong&gt; suelen conectarse a otros servicios (idealmente en otros servidores) para cumplir con sus funciones, por ejemplo con un grupo de servidores de &lt;strong&gt;bases de datos&lt;/strong&gt; dispuestos como un &lt;em&gt;cluster&lt;/em&gt;, que suelen tener una topología propia.&lt;/p&gt;
&lt;p&gt;En este tutorial se va a montar un entorno pequeño de estas características, sirviendo una &lt;em&gt;API&lt;/em&gt; pública en servidores de &lt;strong&gt;backend&lt;/strong&gt;, una aplicación web de administración de los datos de la &lt;em&gt;API&lt;/em&gt; en un servidor de &lt;strong&gt;backoffice&lt;/strong&gt;, y un &lt;em&gt;cluster&lt;/em&gt; de &lt;strong&gt;bases de datos&lt;/strong&gt; representado por una &lt;em&gt;replica set&lt;/em&gt; de MongoDB; todo ello oculto en una red privada y un balanceador usando &lt;em&gt;virtualhosts&lt;/em&gt; para ir a una aplicación u otra según el protocolo usado.&lt;/p&gt;
&lt;p&gt;Esto es lo que propongo montar:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Entorno propuesto" src="http://www.linuxsysadmin.tk/images/entorno_propuesto.png" /&gt;&lt;/p&gt;
&lt;p&gt;Para ello, vamos a crear las máquinas virtuales necesarias. En este caso, voy a usar mi servidor de &lt;strong&gt;virtualización con LXC&lt;/strong&gt;, tal como lo monté en &lt;a href="http://www.linuxsysadmin.tk/2015/11/virtualizando-contenedores-lxc-tras-bridge-interno.html"&gt;este artículo&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# lxc-ls -f
NAME        STATE    IPV4        IPV6  AUTOSTART
------------------------------------------------
backend1    RUNNING  10.0.0.3    -     YES
backend2    RUNNING  10.0.0.4    -     YES
backoffice  RUNNING  10.0.0.5    -     YES
frontend    RUNNING  10.0.0.2    -     YES
mongo1      RUNNING  10.0.0.6    -     YES
mongo2      RUNNING  10.0.0.7    -     YES
root@lxc:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para hacer mas fácil las referencias a las diferentes máquinas, vamos a utilizar sus nombres; como no me apetece montar un servidor DNS, vamos a ponerlas en el fichero &lt;em&gt;/etc/hosts&lt;/em&gt; en todas las máquinas virtuales.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# cat /etc/hosts
...
10.0.0.2        frontend
10.0.0.3        backend1
10.0.0.4        backend2
10.0.0.5        backoffice
10.0.0.6        mongo1
10.0.0.7        mongo2
...
root@mongo1:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a ir montando todas las máquinas una por una; es laborioso pero no es nada complicado. Las reglas del &lt;em&gt;firewall&lt;/em&gt; también las iremos explicando según el rol de cada máquina.&lt;/p&gt;
&lt;p&gt;El orden de montaje no es importante, pero como queremos ir comprobando en cada caso que va funcionando, se montarán de acuerdo al orden de requisitos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;El &lt;em&gt;cluster&lt;/em&gt; de &lt;strong&gt;bases de datos&lt;/strong&gt;, que no tiene dependencias.&lt;/li&gt;
&lt;li&gt;Los servidores de &lt;strong&gt;backend&lt;/strong&gt; y &lt;strong&gt;backoffice&lt;/strong&gt; que dependen del &lt;em&gt;cluster&lt;/em&gt; de &lt;strong&gt;bases de datos&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Finalmente, pondremos el servidor de &lt;strong&gt;frontend&lt;/strong&gt;, con los &lt;em&gt;virtualhosts&lt;/em&gt; y el balanceador, lanzando las peticiones contra los &lt;strong&gt;backends&lt;/strong&gt; y el &lt;strong&gt;backoffice&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Sabiendo lo que vamos a montar, solo queda decir: ¡Manos a la obra!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;</summary><category term="linux"></category><category term="entorno"></category><category term="escalable"></category></entry><entry><title>Restringiendo accesos mediante certificados de cliente</title><link href="http://www.linuxsysadmin.tk/2016/02/restringiendo-accesos-mediante-certificados-de-cliente.html" rel="alternate"></link><updated>2016-02-22T08:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-02-22:2016/02/restringiendo-accesos-mediante-certificados-de-cliente.html</id><summary type="html">&lt;p&gt;De vez en cuando, tenemos algún contenido web o una API que necesita un control de acceso superior. El método mas eficaz del que disponemos hoy en día es la autenticación con certificados SSL cliente, en donde es el cliente el que debe ofrecer un certificado que el servidor validará.&lt;/p&gt;
&lt;p&gt;Como se trata de proteger contenido web, vamos a necesitar un servidor web, por ejemplo, &lt;strong&gt;nginx&lt;/strong&gt;. De paso, vamos a instalar el paquete &lt;strong&gt;openssl&lt;/strong&gt;, que nos permitirá generar los certificados usados.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# apt-get install nginx-light openssl
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias
Leyendo la información de estado... Hecho
Se instalarán los siguientes paquetes extras:
  nginx-common
Paquetes sugeridos:
  fcgiwrap nginx-doc ssl-cert ca-certificates
Se instalarán los siguientes paquetes NUEVOS:
  nginx-common nginx-light openssl
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;3&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar 1.126 kB de archivos.
Se utilizarán 2.148 kB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Generar el certificado y la clave de la CA&lt;/h2&gt;
&lt;p&gt;Empezaremos por generar la clave de la CA, que va a servir para firmar el certificado que pondremos en el servidor.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl genrsa -des3 -out ca.key 4096
Generating RSA private key, &lt;span class="m"&gt;4096&lt;/span&gt; bit long modulus
...................................................................++
.++
e is &lt;span class="m"&gt;65537&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;0x10001&lt;span class="o"&gt;)&lt;/span&gt;
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; ca.key:
Verifying - Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; ca.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora generamos el certificado de la CA. Lo generamos directamente firmado en un solo paso.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl req -new -x509 -days &lt;span class="m"&gt;365&lt;/span&gt; -key ca.key -out ca.crt -subj &lt;span class="s2"&gt;&amp;quot;/C=ES/ST=Spain/L=Barcelona/O=LinuxSysadmin&amp;quot;&lt;/span&gt;
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; ca.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Generar el certificado para el servidor web&lt;/h2&gt;
&lt;p&gt;Generamos la clave para el certificado del servidor web.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl genrsa -des3 -out server.key 4096
Generating RSA private key, &lt;span class="m"&gt;4096&lt;/span&gt; bit long modulus
.............................................++
.....................................++
e is &lt;span class="m"&gt;65537&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;0x10001&lt;span class="o"&gt;)&lt;/span&gt;
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; server.key:
Verifying - Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; server.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora creamos un certificado para el servidor web. Es importante que el campo &lt;strong&gt;CN&lt;/strong&gt; sea el mismo que el nombre del &lt;em&gt;virtualhost&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl req -new -key server.key -out server.csr -subj &lt;span class="s2"&gt;&amp;quot;/C=ES/ST=Spain/L=Barcelona/O=LinuxSysadmin/CN=private.linuxsysadmin.tk&amp;quot;&lt;/span&gt;
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; server.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y lo firmamos con la clave y el certificado de la CA.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl x509 -req -days &lt;span class="m"&gt;365&lt;/span&gt; -in server.csr -CA ca.crt -CAkey ca.key -set_serial &lt;span class="m"&gt;01&lt;/span&gt; -out server.crt
Signature ok
&lt;span class="nv"&gt;subject&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/C&lt;span class="o"&gt;=&lt;/span&gt;ES/ST&lt;span class="o"&gt;=&lt;/span&gt;Spain/L&lt;span class="o"&gt;=&lt;/span&gt;Barcelona/O&lt;span class="o"&gt;=&lt;/span&gt;LinuxSysadmin/CN&lt;span class="o"&gt;=&lt;/span&gt;private.linuxsysadmin.tk
Getting CA Private Key
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; ca.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;TRUCO&lt;/strong&gt;: Si la clave está protegida por una passphrase, se va a necesitar introducirla cada vez que se quiera levantar el servidor web. Nos lo podemos ahorrar con unos simples comandos, que dejará la clave como insegura.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mv server.key server.key.secure
root@server:~# openssl rsa -in server.key.secure -out server.key
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; server.key.secure:
writing RSA key
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Generar el certificado cliente&lt;/h2&gt;
&lt;p&gt;Generamos la clave para el certificado del cliente.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl genrsa -des3 -out client.key 1024
Generating RSA private key, &lt;span class="m"&gt;1024&lt;/span&gt; bit long modulus
...............................++++++
.....................++++++
e is &lt;span class="m"&gt;65537&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;0x10001&lt;span class="o"&gt;)&lt;/span&gt;
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; client.key:
Verifying - Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; client.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El siguiente paso consiste en generar una petición de certificado, que posteriormente haremos firmar. El campo &lt;strong&gt;CN&lt;/strong&gt; puede ser recogido por el servidor web y trasladado mediante cabeceras a un hipotético &lt;em&gt;backend&lt;/em&gt;, en caso de hacer un &lt;em&gt;proxy_pass&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl req -new -key client.key -out client.csr -subj &lt;span class="s2"&gt;&amp;quot;/C=ES/ST=Spain/L=Barcelona/O=LinuxSysadmin/CN=Gerard Monells&amp;quot;&lt;/span&gt;
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; client.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Firmamos nuestra petición de certificado con la clave de la CA, obteniendo el certificado final.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl x509 -req -days &lt;span class="m"&gt;365&lt;/span&gt; -in client.csr -CA ca.crt -CAkey ca.key -set_serial &lt;span class="m"&gt;91&lt;/span&gt; -out client.crt
Signature ok
&lt;span class="nv"&gt;subject&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/C&lt;span class="o"&gt;=&lt;/span&gt;ES/ST&lt;span class="o"&gt;=&lt;/span&gt;Spain/L&lt;span class="o"&gt;=&lt;/span&gt;Barcelona/O&lt;span class="o"&gt;=&lt;/span&gt;LinuxSysadmin/CN&lt;span class="o"&gt;=&lt;/span&gt;Gerard Monells
Getting CA Private Key
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; ca.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora queda empaquetar la clave y el certificado en un fichero &lt;em&gt;client.p12&lt;/em&gt; que pueda ser importado en un navegador web.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl pkcs12 -export -in client.crt -inkey client.key -out client.p12 -name &lt;span class="s2"&gt;&amp;quot;LinuxSysadmin&amp;quot;&lt;/span&gt;
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; client.key:
Enter Export Password:
Verifying - Enter Export Password:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Montando el dominio web&lt;/h2&gt;
&lt;p&gt;Además de necesitar el certificado y la clave servidor, es necesario que el servidor web conozca el certificado de la CA para que pueda verificar el servidor cliente que nos ofrezca el navegador.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cp server.key /etc/ssl/private/
root@server:~# cp server.crt /etc/ssl/certs/
root@server:~# cp ca.crt /etc/ssl/certs/
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Así quedarían los certificados una vez en su sitio.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# tree /etc/ssl/
/etc/ssl/
├── certs
│   ├── ca.crt
│   └── server.crt
├── openssl.cnf
└── private
    └── server.key

&lt;span class="m"&gt;2&lt;/span&gt; directories, &lt;span class="m"&gt;4&lt;/span&gt; files
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a poner un fichero de configuración en &lt;strong&gt;nginx&lt;/strong&gt;, que va a escuchar por el puerto 443 y con &lt;strong&gt;SSL&lt;/strong&gt; habilitado. Indicamos también donde están los ficheros que servirá el &lt;strong&gt;nginx&lt;/strong&gt;, la localización de los certificados y la necesidad de verificar al cliente mediante certificado contra el certificado de la CA.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/nginx/sites-enabled/private.linuxsysadmin.tk
server &lt;span class="o"&gt;{&lt;/span&gt;
    listen                      &lt;span class="m"&gt;443&lt;/span&gt; ssl&lt;span class="p"&gt;;&lt;/span&gt;
    server_name                 private.linuxsysadmin.tk&lt;span class="p"&gt;;&lt;/span&gt;
    root                        /www&lt;span class="p"&gt;;&lt;/span&gt;

    ssl_certificate             /etc/ssl/certs/server.crt&lt;span class="p"&gt;;&lt;/span&gt;
    ssl_certificate_key         /etc/ssl/private/server.key&lt;span class="p"&gt;;&lt;/span&gt;
    ssl_client_certificate      /etc/ssl/certs/ca.crt&lt;span class="p"&gt;;&lt;/span&gt;
    ssl_verify_client           on&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Podemos verificar que la sintaxis de la configuración es correcta usando el binario de &lt;strong&gt;nginx&lt;/strong&gt; con el parámetro adecuado.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf &lt;span class="nb"&gt;test &lt;/span&gt;is successful
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y sabiendo que es correcto, reiniciamos el servidor web.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# service nginx restart
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Comprobación de funcionamiento&lt;/h2&gt;
&lt;p&gt;Como hemos indicado en la configuración en el &lt;em&gt;document root&lt;/em&gt;, vamos a servir el contenido que se encuentra en &lt;em&gt;/www&lt;/em&gt;. Empezaremos poniendo algún contenido en él.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkdir /www
root@server:~# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Private area&amp;quot;&lt;/span&gt; &amp;gt; /www/index.html
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora apuntemos el navegador a la &lt;strong&gt;URL&lt;/strong&gt; del servidor web. Debemos aceptar el certificado autofirmado, puesto que no viene firmado por ninguna autoridad certificadora conocida, por ejemplo, &lt;strong&gt;VeriSign&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Aún así, como no hemos presentado el certificado cliente, el servidor web nos impide el acceso, con una respuesta &lt;strong&gt;HTTP 400&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="2 way SSL access denied" src="http://www.linuxsysadmin.tk/images/2-way-ssl-access-denied.png" /&gt;&lt;/p&gt;
&lt;p&gt;Ahora debemos importar el certificado &lt;em&gt;client.p12&lt;/em&gt; en el navegador web. En el caso concreto de &lt;strong&gt;Google Chrome&lt;/strong&gt;, se hace desde el siguiente menú:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Menu &amp;rarr; Settings &amp;rarr; Show advanced settings &amp;rarr; HTTPS/SSL &amp;rarr; Manage certificates &amp;rarr; Your certificates &amp;rarr; Import &amp;rarr; client.p12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Y ya podemos acceder a nuestro contenido protegido, previa selección del certificado a usar.&lt;/p&gt;
&lt;p&gt;&lt;img alt="2 way SSL certificate" src="http://www.linuxsysadmin.tk/images/2-way-ssl-certificate.png" /&gt;&lt;/p&gt;
&lt;p&gt;Y con esto ya tenemos montada la autenticación cliente mediante certificados.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="nginx"></category><category term="2 way ssl"></category><category term="ssl"></category><category term="https"></category><category term="certificado"></category></entry><entry><title>Haciendo snapshots con LVM</title><link href="http://www.linuxsysadmin.tk/2016/02/haciendo-snapshots-con-lvm.html" rel="alternate"></link><updated>2016-02-15T08:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-02-15:2016/02/haciendo-snapshots-con-lvm.html</id><summary type="html">&lt;p&gt;Una de las funcionalidades mas implementadas en los sistemas de ficheros de nueva generación es la capacidad de hacer &lt;em&gt;snapshots point-in-time&lt;/em&gt;. Sin embargo, no tenemos que renunciar a la estabilidad de los sistemas de ficheros tradicionales como &lt;strong&gt;ext4&lt;/strong&gt;; otras veces no es posible por requisitos del servicio que debe usarlo.&lt;/p&gt;
&lt;p&gt;En este tutorial vamos a demostrar lo fácil que es hacer este tipo de &lt;em&gt;snapshots&lt;/em&gt;, usando como tecnología subyacente el &lt;strong&gt;logical volume manager&lt;/strong&gt;, de ahora en adelante, &lt;strong&gt;LVM&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Los únicos requisitos para seguir esta guía son el paquete &lt;strong&gt;lvm&lt;/strong&gt; y un disco físico sobre el que vamos a construir el &lt;em&gt;volume group&lt;/em&gt; que va a alojar los &lt;em&gt;logical volumes&lt;/em&gt;; al menos van a ser la partición original y algo de espacio para servir como volumen para el &lt;em&gt;snapshot&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Preparación&lt;/h2&gt;
&lt;p&gt;Empezamos instalando los requisitos software:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# apt-get install lvm2
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias
Leyendo la información de estado... Hecho
Se instalarán los siguientes paquetes extras:
  dmeventd libdevmapper-event1.02.1 liblvm2cmd2.02 libreadline5
Paquetes sugeridos:
  thin-provisioning-tools
Se instalarán los siguientes paquetes NUEVOS:
  dmeventd libdevmapper-event1.02.1 liblvm2cmd2.02 libreadline5 lvm2
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;5&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar 1.530 kB de archivos.
Se utilizarán 3.898 kB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Suponiendo que el disco que vamos a usar es &lt;em&gt;/dev/sdb&lt;/em&gt;, vamos a acondicionarlo para que pueda actuar como &lt;em&gt;physical volume&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# pvcreate /dev/sdb
  Physical volume &lt;span class="s2"&gt;&amp;quot;/dev/sdb&amp;quot;&lt;/span&gt; successfully created
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora vamos a usar este &lt;em&gt;physical volume&lt;/em&gt; para crear el &lt;em&gt;volume group&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# vgcreate lvm /dev/sdb
  /proc/devices: No entry &lt;span class="k"&gt;for&lt;/span&gt; device-mapper found
  Volume group &lt;span class="s2"&gt;&amp;quot;lvm&amp;quot;&lt;/span&gt; successfully created
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a sacar un &lt;em&gt;logical volume&lt;/em&gt; para crear el sistema de ficheros que va a ser el objeto del &lt;em&gt;snapshot&lt;/em&gt;. El tamaño del volumen puede ser el que nos convenga, e incluso crecer según sea necesario. De momento, nos basta con 1 GB.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# lvcreate lvm -L 1G -n datos
  Logical volume &lt;span class="s2"&gt;&amp;quot;datos&amp;quot;&lt;/span&gt; created
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Lo formateamos como si de un disco mas se tratara.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkfs.ext4 /dev/lvm/datos
mke2fs 1.42.12 &lt;span class="o"&gt;(&lt;/span&gt;29-Aug-2014&lt;span class="o"&gt;)&lt;/span&gt;
Se está creando El sistema de ficheros con &lt;span class="m"&gt;262144&lt;/span&gt; 4k bloques y &lt;span class="m"&gt;65536&lt;/span&gt; nodos-i

UUID del sistema de ficheros: 1ad4e531-82de-4797-9968-28cb33b3badd
Respaldo del superbloque guardado en los bloques:
        32768, 98304, 163840, 229376

Reservando las tablas de grupo: hecho
Escribiendo las tablas de nodos-i: hecho
Creando el fichero de transacciones &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;8192&lt;/span&gt; bloques&lt;span class="o"&gt;)&lt;/span&gt;: hecho
Escribiendo superbloques y la información contable del sistema de ficheros: hecho

root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a asumir que nuestro servicio necesita dejar sus datos en &lt;em&gt;/data&lt;/em&gt;; como no existe, vamos a crearlo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkdir /data
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El siguiente paso es montar ese volumen en su sitio, en este caso, en &lt;em&gt;/data&lt;/em&gt;. Se deja como ejercicio personal ponerlo en el &lt;em&gt;/etc/fstab&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mount /dev/lvm/datos /data/
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a crear algo de contenido en la carpeta para simular los datos que dejaría el servicio que supuestamente usaría esta carpeta.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &amp;gt; /data/a
root@server:~# &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &amp;gt; /data/b
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creación del snapshot&lt;/h2&gt;
&lt;p&gt;Hacer un &lt;em&gt;snapshot&lt;/em&gt; es tan fácil como invocar el binario &lt;strong&gt;lvcreate&lt;/strong&gt; con el parámetro &lt;em&gt;-s&lt;/em&gt;, especificando el tamaño, el nombre y el volumen objetivo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# lvcreate -L 100M -n datos-snap -s /dev/lvm/datos
  Logical volume &lt;span class="s2"&gt;&amp;quot;datos-snap&amp;quot;&lt;/span&gt; created
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El volumen &lt;em&gt;datos-snap&lt;/em&gt; solo contiene las diferencias con el volumen original, así que no necesita tener el mismo tamaño que el original. Sin embargo, si hubiera mas de 100 MB de cambios, este &lt;em&gt;snapshot&lt;/em&gt; quedaría inválido.&lt;/p&gt;
&lt;p&gt;De momento, creo que con 100 MB va a ser suficiente, ya que solo pretendo sacar un fichero comprimido de ese &lt;em&gt;snapshot&lt;/em&gt;, eliminándolo después. Un tamaño seguro habría sido el mismo que el volumen original. Sin embargo, como se trata de otro volumen &lt;strong&gt;LVM&lt;/strong&gt;, podremos extenderla a posteriori con &lt;em&gt;lvextend&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Vamos a analizar el contenido; lo montamos en una carpeta cualquiera para ver su contenido.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mount /dev/lvm/datos-snap /mnt/
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Es fácil de verificar que tienen el mismo contenido.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# grep . /data/* /mnt/*
/data/a:1
/data/b:1
/mnt/a:1
/mnt/b:1
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a continuar simulando que el servicio escribe en el volumen original, por ejemplo, modificando uno de los ficheros.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt; &amp;gt; /data/a
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y verificamos que el &lt;em&gt;snapshot point-in-time&lt;/em&gt; se quedó en el momento temporal en el que lo hicimos, quedando como estaba entonces:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# grep . /data/* /mnt/*
/data/a:2
/data/b:1
/mnt/a:1
/mnt/b:1
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Verificando los &lt;em&gt;logical volume&lt;/em&gt; con el comando &lt;em&gt;lvs&lt;/em&gt;, vemos que es un volumen de 100 MB, con una ocupación baja, del 0,08%. El &lt;em&gt;snapshot&lt;/em&gt; quedaría inservible si llegara a superar el 100%.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# lvs
  LV         VG   Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  datos      lvm  owi-aos---   1,00g
  datos-snap lvm  swi-aos--- 100,00m      datos  0,08
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Sacando el backup&lt;/h2&gt;
&lt;p&gt;El objetivo inicial era sacar una copia de los datos, congelados en un momento concreto. Tenemos ese momento en el volumen &lt;em&gt;datos-snap&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Empezaremos montándolo en alguna carpeta cualquiera, si no lo teníamos ya (lo hemos montado en el punto anterior).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mount /dev/lvm/datos-snap /mnt/
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Con el volumen montado, el resto es procedimiento estándar. En este caso, vamos a sacar un fichero &lt;em&gt;.tar.gz&lt;/em&gt; con el contenido de la carpeta:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# &lt;span class="nb"&gt;cd&lt;/span&gt; /mnt/
root@server:/mnt# tar cvzf /root/backup.tar.gz *
a
b
root@server:/mnt#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y finalmente vamos a limpiar el &lt;em&gt;snapshot&lt;/em&gt;, empezando por desmontar el volumen. Como estamos dentro de la carpeta no vamos a poder desmontar el volumen, así que salimos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:/mnt# &lt;span class="nb"&gt;cd&lt;/span&gt;
root@server:~# umount /mnt/
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y ahora que no lo tenemos montado, lo eliminamos sin problemas con las herramientas propias de &lt;strong&gt;LVM&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# lvremove /dev/lvm/datos-snap
Do you really want to remove active logical volume datos-snap? &lt;span class="o"&gt;[&lt;/span&gt;y/n&lt;span class="o"&gt;]&lt;/span&gt;: y
  Logical volume &lt;span class="s2"&gt;&amp;quot;datos-snap&amp;quot;&lt;/span&gt; successfully removed
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y solo quedará poner el fichero &lt;em&gt;backup.tar.gz&lt;/em&gt; a buen recaudo.&lt;/p&gt;</summary><category term="linux"></category><category term="lvm"></category><category term="logical volume manager"></category><category term="snapshot"></category><category term="point-in-time"></category><category term="backup"></category></entry><entry><title>Restringiendo accesos web mediante autenticación básica</title><link href="http://www.linuxsysadmin.tk/2016/02/restringiendo-accesos-web-mediante-autenticacion-basica.html" rel="alternate"></link><updated>2016-02-08T08:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-02-08:2016/02/restringiendo-accesos-web-mediante-autenticacion-basica.html</id><summary type="html">&lt;p&gt;Algunas veces nos encontramos con la necesidad de restringir el acceso a algunos recursos web. Normalmente se suele implementar algún sistema de &lt;em&gt;login&lt;/em&gt;, &lt;em&gt;cookies&lt;/em&gt; o &lt;em&gt;sesiones&lt;/em&gt;; no obstante, esta opción no siempre nos es posible, y tenemos que proteger esos recursos usando los mecanismos que nos ofrezca el servidor web.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ATENCIÓN&lt;/strong&gt;: Este método es bastante simple, y se puede descodificar lo que manda el cliente; por eso se recomienda encarecidamente usar &lt;strong&gt;SSL&lt;/strong&gt;, mediante el uso de &lt;strong&gt;HTTPS&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Empezaremos instalando el servidor web y la herramienta de generación de certificados para usar con &lt;strong&gt;SSL&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# apt-get install nginx-light openssl
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias
Leyendo la información de estado... Hecho
Se instalarán los siguientes paquetes extras:
  nginx-common
Paquetes sugeridos:
  fcgiwrap nginx-doc ssl-cert ca-certificates
Se instalarán los siguientes paquetes NUEVOS:
  nginx-common nginx-light openssl
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;3&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar 1.126 kB de archivos.
Se utilizarán 2.148 kB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Generar el certificado y la clave de la CA&lt;/h2&gt;
&lt;p&gt;Empezaremos por generar la clave de la CA, que va a servir para firmar el certificado que pondremos en el servidor.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl genrsa -des3 -out ca.key 4096
Generating RSA private key, &lt;span class="m"&gt;4096&lt;/span&gt; bit long modulus
..................................++
.....................................................................++
e is &lt;span class="m"&gt;65537&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;0x10001&lt;span class="o"&gt;)&lt;/span&gt;
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; ca.key:
Verifying - Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; ca.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora generamos el certificado de la CA. Lo generamos directamente firmado en un solo paso.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl req -new -x509 -days &lt;span class="m"&gt;365&lt;/span&gt; -key ca.key -out ca.crt -subj &lt;span class="s2"&gt;&amp;quot;/C=ES/ST=Spain/L=Barcelona/O=LinuxSysadmin&amp;quot;&lt;/span&gt;
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; ca.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Generar el certificado para el servidor web&lt;/h2&gt;
&lt;p&gt;Generamos la clave para el certificado del servidor web.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl genrsa -des3 -out server.key 4096
Generating RSA private key, &lt;span class="m"&gt;4096&lt;/span&gt; bit long modulus
.....................................................................++
......................................................................................................................................................................++
e is &lt;span class="m"&gt;65537&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;0x10001&lt;span class="o"&gt;)&lt;/span&gt;
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; server.key:
Verifying - Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; server.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora creamos un certificado para el servidor web.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl req -new -key server.key -out server.csr -subj &lt;span class="s2"&gt;&amp;quot;/C=ES/ST=Spain/L=Barcelona/O=LinuxSysadmin/CN=private.linuxsysadmin.tk&amp;quot;&lt;/span&gt;
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; server.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y lo firmamos con la clave y el certificado de la CA.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# openssl x509 -req -days &lt;span class="m"&gt;365&lt;/span&gt; -in server.csr -CA ca.crt -CAkey ca.key -set_serial &lt;span class="m"&gt;01&lt;/span&gt; -out server.crt
Signature ok
&lt;span class="nv"&gt;subject&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/C&lt;span class="o"&gt;=&lt;/span&gt;ES/ST&lt;span class="o"&gt;=&lt;/span&gt;Spain/L&lt;span class="o"&gt;=&lt;/span&gt;Barcelona/O&lt;span class="o"&gt;=&lt;/span&gt;LinuxSysadmin/CN&lt;span class="o"&gt;=&lt;/span&gt;private.linuxsysadmin.tk
Getting CA Private Key
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; ca.key:
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;TRUCO&lt;/strong&gt;: Si la clave está protegida por una &lt;em&gt;passphrase&lt;/em&gt;, se va a necesitar introducirla cada vez que se quiera levantar el servidor web. Nos lo podemos ahorrar con unos simples comandos, que dejará la clave como insegura.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mv server.key server.key.secure
root@server:~# openssl rsa -in server.key.secure -out server.key
Enter pass phrase &lt;span class="k"&gt;for&lt;/span&gt; server.key.secure:
writing RSA key
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Montando el dominio web&lt;/h2&gt;
&lt;p&gt;Para habilitar &lt;strong&gt;SSL&lt;/strong&gt; en un dominio, necesitamos la clave y el certificado del servidor, así que vamos a ponerlos en una carpeta pensado para tal efecto.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cp server.key /etc/ssl/private/
root@server:~# cp server.crt /etc/ssl/certs/
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Así quedarían los certificados una vez en su sitio.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# tree /etc/ssl/
/etc/ssl/
├── certs
│   └── server.crt
├── openssl.cnf
└── private
    └── server.key

&lt;span class="m"&gt;2&lt;/span&gt; directories, &lt;span class="m"&gt;3&lt;/span&gt; files
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a poner un fichero de configuración en &lt;strong&gt;nginx&lt;/strong&gt;, que va a escuchar por el puerto 443 y con &lt;strong&gt;SSL&lt;/strong&gt; habilitado. Indicamos también donde están los ficheros que servirá el &lt;strong&gt;nginx&lt;/strong&gt;, la localización de los certificados y activamos la autenticación básica.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/nginx/sites-enabled/private.linuxsysadmin.tk
server &lt;span class="o"&gt;{&lt;/span&gt;
        listen &lt;span class="m"&gt;443&lt;/span&gt; ssl&lt;span class="p"&gt;;&lt;/span&gt;
        server_name private.linuxsysadmin.tk&lt;span class="p"&gt;;&lt;/span&gt;
        root /www&lt;span class="p"&gt;;&lt;/span&gt;

        ssl_certificate /etc/ssl/certs/server.crt&lt;span class="p"&gt;;&lt;/span&gt;
        ssl_certificate_key /etc/ssl/private/server.key&lt;span class="p"&gt;;&lt;/span&gt;

        auth_basic &lt;span class="s2"&gt;&amp;quot;Admin Area&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        auth_basic_user_file /etc/nginx/auth/private&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora tenemos que crear un fichero tipo &lt;em&gt;.htpasswd&lt;/em&gt; como los de &lt;strong&gt;apache&lt;/strong&gt;. Crearemos primero la carpeta en donde lo vamos a dejar.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkdir /etc/nginx/auth
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En la carpeta creada pondremos un fichero llamado &lt;em&gt;private&lt;/em&gt; con un formato idéntico a los &lt;em&gt;.htpasswd&lt;/em&gt; de &lt;strong&gt;apache&lt;/strong&gt;. Aquí podríamos usar las herramientas de &lt;strong&gt;apache-utils&lt;/strong&gt;, pero de momento nos conformaremos con crearlo con &lt;strong&gt;openssl&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;admin:&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;openssl passwd -crypt s3cr3t&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/nginx/auth/private
root@server:~# cat /etc/nginx/auth/private
admin:y6xasR0LI8mbg
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente reiniciamos el servidor web para que aplique los cambios en la configuración.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# service nginx restart
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Comprobación de funcionamiento&lt;/h2&gt;
&lt;p&gt;Es importante que nos acordemos de crear nuestro &lt;em&gt;document root&lt;/em&gt; con algún contenido.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkdir /www
root@server:~# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Private area&amp;quot;&lt;/span&gt; &amp;gt; /www/index.html
root@server:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Si apuntamos un navegador al dominio configurado, y tras aceptar nuestro certificado autofirmado como excepción, deberíamos ver que se nos piden las credenciales en una ventana emergente.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Autenticación básica: credenciales" src="http://www.linuxsysadmin.tk/images/autenticacion-basica-credenciales.png" /&gt;&lt;/p&gt;
&lt;p&gt;Y con eso tenemos nuestro contenido protegido de los curiosos.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="nginx"></category><category term="autenticacion basica"></category><category term="htpasswd"></category><category term="ssl"></category><category term="https"></category><category term="certificado"></category></entry><entry><title>Un proxy DNS con dnsmasq</title><link href="http://www.linuxsysadmin.tk/2016/02/un-proxy-dns-con-dnsmasq.html" rel="alternate"></link><updated>2016-02-01T08:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-02-01:2016/02/un-proxy-dns-con-dnsmasq.html</id><summary type="html">&lt;p&gt;A veces nos puede interesar disponer de una servidor &lt;strong&gt;DNS&lt;/strong&gt; para nombrar las máquinas de nuestra red privada, sin la complejidad de &lt;strong&gt;BIND&lt;/strong&gt;. Otras, queremos acelerar el acceso a internet desde nuestra red; es interesante ver el tiempo que se pierde en la resolución &lt;strong&gt;DNS&lt;/strong&gt;. Para eso disponemos de &lt;strong&gt;dnsmasq&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;El servicio &lt;strong&gt;dnsmasq&lt;/strong&gt; proporciona servicios como caché &lt;strong&gt;DNS&lt;/strong&gt; y como servidor &lt;strong&gt;DHCP&lt;/strong&gt;. Se trata de un &lt;em&gt;proxy&lt;/em&gt; &lt;strong&gt;DNS&lt;/strong&gt; que va a dirigir las consultas &lt;strong&gt;DNS&lt;/strong&gt; contra el servidor configurado en el &lt;em&gt;proxy&lt;/em&gt;, guardando una copia en &lt;em&gt;caché&lt;/em&gt; para agilizar futuras consultas.&lt;/p&gt;
&lt;p&gt;Es muy fácil de configurar y es bastante ligero. Se considera ideal para redes pequeñas con menos de 50 ordenadores.&lt;/p&gt;
&lt;p&gt;En mi caso, resultó muy útil para solucionar el problema de &lt;strong&gt;DNS&lt;/strong&gt; que me planteaba una red &lt;strong&gt;Virtualbox&lt;/strong&gt; &lt;em&gt;solo anfitrión&lt;/em&gt;, en donde se escondían mis máquinas virtuales con dirección IP estática. Resulta que me muevo entre varias zonas de trabajo, y que no hay ningún servidor &lt;strong&gt;DNS&lt;/strong&gt; accesible desde todas; ir cambiando los &lt;strong&gt;DNS&lt;/strong&gt; de todas las máquinas era trabajoso.&lt;/p&gt;
&lt;p&gt;Con este problema, puse &lt;strong&gt;dnsmasq&lt;/strong&gt; en mi anfitrión (que usaba &lt;strong&gt;DHCP&lt;/strong&gt; y recibía el &lt;strong&gt;DNS&lt;/strong&gt; automáticamente), y configuré todas las máquinas para que usaran el anfitrión como servidor &lt;strong&gt;DNS&lt;/strong&gt;; nunca mas tuve que configurarlos.&lt;/p&gt;
&lt;h2&gt;Instalación&lt;/h2&gt;
&lt;p&gt;La instalación en una máquina derivada de &lt;em&gt;Debian&lt;/em&gt; es muy simple; está en los repositorios oficiales.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@proxy:~# apt-get install dnsmasq
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias       
Leyendo la información de estado... Hecho
Se instalarán los siguientes paquetes extras:
  dns-root-data dnsmasq-base libnetfilter-conntrack3
Paquetes sugeridos:
  resolvconf
Se instalarán los siguientes paquetes NUEVOS:
  dns-root-data dnsmasq dnsmasq-base libnetfilter-conntrack3
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;4&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar &lt;span class="m"&gt;488&lt;/span&gt; kB de archivos.
Se utilizarán 1.170 kB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
root@proxy:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En caso de querer modificar la configuración, se debe editar el fichero &lt;em&gt;/etc/dnsmasq.conf&lt;/em&gt;, y luego reiniciar el servicio &lt;em&gt;dnsmasq&lt;/em&gt;. En este mismo fichero se puede configurar el servicio &lt;strong&gt;DHCP&lt;/strong&gt; (directiva &lt;em&gt;dhcp-range&lt;/em&gt;), el servidor de nombres a dar al resto (la misma máquina de &lt;em&gt;dnsmasq&lt;/em&gt;, por defecto), el servidor &lt;strong&gt;NTP&lt;/strong&gt; o el &lt;em&gt;gateway&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;En mi caso, no vi necesario activar estos servicios, así que el fichero de configuración no se vio modificada. Así pues, con esto basta.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TRUCO&lt;/strong&gt;: En caso de querer resolver localmente, &lt;em&gt;dnsmasq&lt;/em&gt; sirve los nombres alojados en &lt;em&gt;/etc/hosts&lt;/em&gt;, a menos que se indique lo contrario en la configuración. Basta con modificar ese fichero.&lt;/p&gt;
&lt;h2&gt;Comprobación y uso&lt;/h2&gt;
&lt;p&gt;Para comprobar que funciona, vamos a poner otra máquina, configurada para usar el nuevo servidor &lt;strong&gt;DNS&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@client:~# cat /etc/resolv.conf 
nameserver 192.168.56.1
root@client:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En principio basta con comprobar que resuelve el nombre de una petición cualquiera, por ejemplo, con un &lt;strong&gt;ping&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Sin embargo, podemos apreciar la mejora de la &lt;em&gt;caché&lt;/em&gt; mediante una herramienta mas avanzada de resolución &lt;strong&gt;DNS&lt;/strong&gt;, por ejemplo, con &lt;strong&gt;dig&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@client:~# dig www.linuxsysadmin.tk &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;Query time&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; Query &lt;span class="nb"&gt;time&lt;/span&gt;: &lt;span class="m"&gt;118&lt;/span&gt; msec
root@client:~# dig www.linuxsysadmin.tk &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;Query time&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; Query &lt;span class="nb"&gt;time&lt;/span&gt;: &lt;span class="m"&gt;5&lt;/span&gt; msec
root@client:~# dig www.linuxsysadmin.tk &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;Query time&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; Query &lt;span class="nb"&gt;time&lt;/span&gt;: &lt;span class="m"&gt;4&lt;/span&gt; msec
root@client:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto hemos cumplido; tenemos un &lt;em&gt;proxy caché&lt;/em&gt; &lt;strong&gt;DNS&lt;/strong&gt;, que nos agiliza las peticiones, nos resuelve localmente y nos evita ir cambiando el &lt;strong&gt;DNS&lt;/strong&gt; cada vez que nos movemos de zona de trabajo.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="dnsmasq"></category><category term="cache"></category><category term="dns"></category><category term="dhcp"></category></entry><entry><title>Creando una jaula CentOS</title><link href="http://www.linuxsysadmin.tk/2016/01/creando-una-jaula-centos.html" rel="alternate"></link><updated>2016-01-25T08:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-01-25:2016/01/creando-una-jaula-centos.html</id><summary type="html">&lt;p&gt;Algunas veces nos puede interesar levantar procesos o demonios en entornos controlados, por ejemplo en una jaula, o para crear un contenedor. Otras veces, por comodidad o conocimiento, nos puede interesar cambiar la distribución, por ejemplo, servicios &lt;em&gt;CentOS&lt;/em&gt; en un servidor &lt;em&gt;Ubuntu&lt;/em&gt;. Hoy vamos a construir una jaula con &lt;em&gt;CentOS&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Vamos a crear una jaula de &lt;em&gt;CentOS&lt;/em&gt;, partiendo de una distribución basada en &lt;strong&gt;yum&lt;/strong&gt;. En este caso, se trata de una distribución &lt;em&gt;RedHat&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# cat /etc/redhat-release&lt;/span&gt;
Red Hat Enterprise Linux Server release 7.2 &lt;span class="o"&gt;(&lt;/span&gt;Maipo&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creación de la jaula&lt;/h2&gt;
&lt;p&gt;Empezaremos declarando una variable para indicar donde vamos a crear la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# export JAIL=/root/jail&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a crear la carpeta de la jaula y la estructura necesaria para albergar los datos del comando &lt;strong&gt;rpm&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# mkdir -p ${JAIL}/var/lib/rpm&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como la base de datos de &lt;strong&gt;rpm&lt;/strong&gt; no existe, la vamos a recrear con el mismo comando:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# rpm --rebuilddb --root=${JAIL}&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vemos ahora que tenemos una estructura de carpetas que empieza a parecerse a lo que debería.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# tree $JAIL&lt;/span&gt;
/root/jail
&lt;span class="sb"&gt;`&lt;/span&gt;-- var
    &lt;span class="sb"&gt;`&lt;/span&gt;-- lib
        &lt;span class="sb"&gt;`&lt;/span&gt;-- rpm
            &lt;span class="sb"&gt;`&lt;/span&gt;-- Packages

&lt;span class="m"&gt;3&lt;/span&gt; directories, &lt;span class="m"&gt;1&lt;/span&gt; file
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El siguiente paso consiste en localizar el fichero &lt;em&gt;.rpm&lt;/em&gt; relativo a la &lt;em&gt;release&lt;/em&gt; de &lt;em&gt;CentOS&lt;/em&gt; que queramos en nuestra jaula. Apuntamos el navegador al servidor web con el repositorio base en &lt;a href="http://mirror.centos.org/centos/"&gt;http://mirror.centos.org/centos/&lt;/a&gt; y buscamos el &lt;em&gt;link&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Suponiendo que queramos un &lt;em&gt;CentOS&lt;/em&gt; versión 7 y con una arquitectura &lt;em&gt;x64_64&lt;/em&gt;, el &lt;em&gt;link&lt;/em&gt; podría ser &lt;a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/centos-release-7-2.1511.el7.centos.2.10.x86_64.rpm"&gt;http://mirror.centos.org/centos/7/os/x86_64/Packages/centos-release-7-2.1511.el7.centos.2.10.x86_64.rpm&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# rpm -i --root=${JAIL} --nodeps http://mirror.centos.org/centos/7/os/x86_64/Packages/centos-release-7-2.1511.el7.centos.2.10.x86_64.rpm&lt;/span&gt;
warning: Generating &lt;span class="m"&gt;12&lt;/span&gt; missing index&lt;span class="o"&gt;(&lt;/span&gt;es&lt;span class="o"&gt;)&lt;/span&gt;, please wait...
warning: /root/jail/var/tmp/rpm-tmp.Vy1z44: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El siguiente paso consiste en instalar &lt;strong&gt;yum&lt;/strong&gt; en la jaula, que va a traer todas las dependencias necesarias para completar la jaula.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: El comando &lt;strong&gt;yum&lt;/strong&gt; busca las llaves del repositorio en &lt;em&gt;/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7&lt;/em&gt;, y no en la jaula. Esto se puede solventar con un &lt;em&gt;link&lt;/em&gt; simbólico:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# ln -s ${JAIL}/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y ya podemos instalar &lt;strong&gt;yum&lt;/strong&gt; y sus dependencias:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# yum --installroot=${JAIL} install -y yum&lt;/span&gt;
...
Resolving Dependencies
...
Dependencies Resolved
...
Install  &lt;span class="m"&gt;1&lt;/span&gt; Package &lt;span class="o"&gt;(&lt;/span&gt;+89 Dependent packages&lt;span class="o"&gt;)&lt;/span&gt;

Total download size: &lt;span class="m"&gt;49&lt;/span&gt; M
Installed size: &lt;span class="m"&gt;245&lt;/span&gt; M
...
Complete!
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Si queremos una jaula mas mínima todavía, en vez de &lt;em&gt;yum&lt;/em&gt; podemos instalar los paquetes necesarios, dejando que las dependencias hagan el resto:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# yum --installroot=${JAIL} install bash httpd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Alternativamente, se puede construir una jaula completa instalando el grupo &lt;em&gt;core&lt;/em&gt; en vez de &lt;em&gt;yum&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# yum --installroot=${JAIL} groupinstall core&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ya tenemos la jaula; es un buen momento para sacar una copia  de la carpeta.&lt;/p&gt;
&lt;h2&gt;Uso de la jaula&lt;/h2&gt;
&lt;p&gt;Esta copia es transferible a otras máquinas, aunque no sean derivadas de &lt;em&gt;RedHat&lt;/em&gt;. En este caso, la jaula se puso a funcionar en una máquina con &lt;em&gt;Debian&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Declaramos la carpeta donde tenemos la jaula, copiada o descomprimida.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@uranus ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# export JAIL=/root/jail&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@uranus ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Opcionalmente, podemos copiar el esqueleto de configuración para el usuario &lt;strong&gt;root&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@uranus:~# cp &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;JAIL&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;/etc/skel/.* &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;JAIL&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;/root
cp: se omite el directorio «/root/jail/etc/skel/.»
cp: se omite el directorio «/root/jail/etc/skel/..»
root@uranus:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Es hora de entrar en la jaula para definir la contraseña de &lt;strong&gt;root&lt;/strong&gt;, configuración de red  y otros detalles.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@uranus:~# chroot &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;JAIL&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; /bin/bash -l
&lt;span class="o"&gt;[&lt;/span&gt;root@uranus /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Verificamos que estamos dentro de la jaula, por ejemplo, mirando la versión y distribución instalada.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@uranus /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# cat /etc/redhat-release &lt;/span&gt;
CentOS Linux release 7.2.1511 &lt;span class="o"&gt;(&lt;/span&gt;Core&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="o"&gt;[&lt;/span&gt;root@uranus /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# exit&lt;/span&gt;
root@uranus:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Podemos instalar cualquier paquete deseado en el interior de la jaula, sea mediante el comando &lt;strong&gt;chroot&lt;/strong&gt; o el comando &lt;strong&gt;systemd-nspawn&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Finalmente, y suponiendo que hay &lt;strong&gt;systemd&lt;/strong&gt; instalado en la máquina anfitriona, podemos ejecutar la jaula como un contenedor.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@uranus:~# systemd-nspawn -b -D jail/
Spawning container jail on /root/jail.
...
Welcome to CentOS Linux &lt;span class="m"&gt;7&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Core&lt;span class="o"&gt;)&lt;/span&gt;!
...
CentOS Linux &lt;span class="m"&gt;7&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Core&lt;span class="o"&gt;)&lt;/span&gt;
Kernel 3.16.0-4-amd64 on an x86_64

jail login: 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto ya tenemos nuestra jaula.&lt;/p&gt;</summary><category term="linux"></category><category term="centos"></category><category term="maipo"></category><category term="jaula"></category></entry><entry><title>LVM: logical volume manager</title><link href="http://www.linuxsysadmin.tk/2016/01/lvm-logical-volume-manager.html" rel="alternate"></link><updated>2016-01-18T09:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-01-18:2016/01/lvm-logical-volume-manager.html</id><summary type="html">&lt;p&gt;Cuando eres un usuario medio no te complicas; particionas tu disco, a menudo usando un sistema de particionado guiado e instalas tu sistema operativo favorito. El problema es cuando las particiones se te quedan cortas. Para estos casos, se inventó una tecnología llamada &lt;em&gt;logical volume manager&lt;/em&gt;, usando sus siglas: &lt;strong&gt;LVM&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;LVM es una implementación de un administrador de volúmenes lógicos para el kernel Linux. Se escribió originalmente en 1998 por Heinz Mauelshagen, que se basó en el administrador de volúmenes de Veritas usado en sistemas HP-UX.&lt;/p&gt;
&lt;p&gt;Lo que hay que saber es que las "particiones" son ahora &lt;em&gt;logical volumes&lt;/em&gt;, que son particiones de un &lt;em&gt;volume group&lt;/em&gt;. A su vez, este &lt;em&gt;volume group&lt;/em&gt; es una agrupación de discos físicos, &lt;em&gt;physical volume&lt;/em&gt; en el argot de &lt;strong&gt;LVM&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;La ventaja de &lt;strong&gt;LVM&lt;/strong&gt; es que podemos redimensionar nuestros &lt;em&gt;logical volumes&lt;/em&gt; (siempre que el sistema de ficheros lo permita) y que podemos añadir y quitar &lt;em&gt;physical volumes&lt;/em&gt; a nuestros &lt;em&gt;volume groups&lt;/em&gt;, a efectos de incrementar su espacio disponible.&lt;/p&gt;
&lt;p&gt;Usos frecuentes para &lt;strong&gt;LVM&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dimensionado de discos en caliente&lt;/li&gt;
&lt;li&gt;Creación de particiones de espacio limitado&lt;/li&gt;
&lt;li&gt;Capacidad para crear &lt;em&gt;snapshots point-in-time&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Un ejemplo&lt;/h2&gt;
&lt;p&gt;Partimos de una máquina virtual con cualquier distribución &lt;em&gt;Linux&lt;/em&gt;, por ejemplo &lt;em&gt;Debian&lt;/em&gt;, que dispone de 2 discos adicionales dedicados para &lt;strong&gt;LVM&lt;/strong&gt;. Con uno bastaría, pero ya pongo los dos para tenerlo hecho cuando el tutorial avance.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# fdisk -l /dev/sdb

Disco /dev/sdb: &lt;span class="m"&gt;8&lt;/span&gt; GiB, &lt;span class="m"&gt;8589934592&lt;/span&gt; bytes, &lt;span class="m"&gt;16777216&lt;/span&gt; sectores
Unidades: sectores de &lt;span class="m"&gt;1&lt;/span&gt; * &lt;span class="nv"&gt;512&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;512&lt;/span&gt; bytes
Tamaño de sector &lt;span class="o"&gt;(&lt;/span&gt;lógico/físico&lt;span class="o"&gt;)&lt;/span&gt;: &lt;span class="m"&gt;512&lt;/span&gt; bytes / &lt;span class="m"&gt;512&lt;/span&gt; bytes
Tamaño de E/S &lt;span class="o"&gt;(&lt;/span&gt;mínimo/óptimo&lt;span class="o"&gt;)&lt;/span&gt;: &lt;span class="m"&gt;512&lt;/span&gt; bytes / &lt;span class="m"&gt;512&lt;/span&gt; bytes
root@server:~# fdisk -l /dev/sdc

Disco /dev/sdc: &lt;span class="m"&gt;4&lt;/span&gt; GiB, &lt;span class="m"&gt;4294967296&lt;/span&gt; bytes, &lt;span class="m"&gt;8388608&lt;/span&gt; sectores
Unidades: sectores de &lt;span class="m"&gt;1&lt;/span&gt; * &lt;span class="nv"&gt;512&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;512&lt;/span&gt; bytes
Tamaño de sector &lt;span class="o"&gt;(&lt;/span&gt;lógico/físico&lt;span class="o"&gt;)&lt;/span&gt;: &lt;span class="m"&gt;512&lt;/span&gt; bytes / &lt;span class="m"&gt;512&lt;/span&gt; bytes
Tamaño de E/S &lt;span class="o"&gt;(&lt;/span&gt;mínimo/óptimo&lt;span class="o"&gt;)&lt;/span&gt;: &lt;span class="m"&gt;512&lt;/span&gt; bytes / &lt;span class="m"&gt;512&lt;/span&gt; bytes
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Los discos que forman un &lt;em&gt;volume group&lt;/em&gt; no necesitan tener el mismo tamaño; así que con uno de 8 GB y otro de 4 GB tendremos bastante.&lt;/p&gt;
&lt;p&gt;Nos aseguramos que tenemos el paquete &lt;strong&gt;lvm2&lt;/strong&gt; instalado, y si no lo estuviera, lo instalamos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# apt-get install lvm2
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias       
Leyendo la información de estado... Hecho
...
Se instalarán los siguientes paquetes NUEVOS:
  dmeventd libdevmapper-event1.02.1 liblvm2cmd2.02 libreadline5 lvm2
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;5&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar 1.530 kB de archivos.
Se utilizarán 3.898 kB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a crear un &lt;em&gt;volume group&lt;/em&gt; con 1 solo disco. Así que primero vamos a preparar &lt;em&gt;/dev/sdb&lt;/em&gt; como &lt;em&gt;physical volume&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# pvcreate /dev/sdb 
  Physical volume &lt;span class="s2"&gt;&amp;quot;/dev/sdb&amp;quot;&lt;/span&gt; successfully created
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y ahora creamos un &lt;em&gt;volume group&lt;/em&gt; a partir del nuevo &lt;em&gt;physical volume&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# vgcreate vg1 /dev/sdb 
  /proc/devices: No entry &lt;span class="k"&gt;for&lt;/span&gt; device-mapper found
  Volume group &lt;span class="s2"&gt;&amp;quot;vg1&amp;quot;&lt;/span&gt; successfully created
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vemos que tenemos un &lt;em&gt;volume group&lt;/em&gt; llamado &lt;strong&gt;vg1&lt;/strong&gt; y que dispone de 8 GB, todos ellos libres.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# vgs
  VG   &lt;span class="c"&gt;#PV #LV #SN Attr   VSize VFree&lt;/span&gt;
  vg1    &lt;span class="m"&gt;1&lt;/span&gt;   &lt;span class="m"&gt;0&lt;/span&gt;   &lt;span class="m"&gt;0&lt;/span&gt; wz--n- 8,00g 8,00g
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nos gustaría que nuestros usuarios tuvieran una partición dedicada, así quedarán limitados en el espacio que pueden usar, sin molestar el resto del sistema operativo. En el argot de &lt;strong&gt;LVM&lt;/strong&gt; se trata de un &lt;em&gt;logical volume&lt;/em&gt;. Lo creamos, por ejemplo de 5 GB:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# lvcreate vg1 -L 5G -n users
  Logical volume &lt;span class="s2"&gt;&amp;quot;users&amp;quot;&lt;/span&gt; created
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Miramos la salida de los comandos &lt;strong&gt;lvs&lt;/strong&gt;, &lt;strong&gt;vgs&lt;/strong&gt; y &lt;strong&gt;pvs&lt;/strong&gt;: sin sorpresas. Tenemos un &lt;em&gt;logical volume&lt;/em&gt; de 5 GB, al &lt;em&gt;volume group&lt;/em&gt; le quedan 3 GB igual que al &lt;em&gt;physical volume&lt;/em&gt; subyacente.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# lvs
  LV    VG   Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  users vg1  -wi-a----- 5,00g                                                    
root@server:~# vgs
  VG   &lt;span class="c"&gt;#PV #LV #SN Attr   VSize VFree&lt;/span&gt;
  vg1    &lt;span class="m"&gt;1&lt;/span&gt;   &lt;span class="m"&gt;1&lt;/span&gt;   &lt;span class="m"&gt;0&lt;/span&gt; wz--n- 8,00g 3,00g
root@server:~# pvs
  PV         VG   Fmt  Attr PSize PFree
  /dev/sdb   vg1  lvm2 a--  8,00g 3,00g
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sabiendo que ahora tenemos un dispositivo nuevo de 5 GB en &lt;em&gt;/dev/vg1-users&lt;/em&gt;, lo formateamos y lo montamos como cualquier otra partición.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkfs.ext4 /dev/mapper/vg1-users 
mke2fs 1.42.12 &lt;span class="o"&gt;(&lt;/span&gt;29-Aug-2014&lt;span class="o"&gt;)&lt;/span&gt;
Se está creando El sistema de ficheros con &lt;span class="m"&gt;1310720&lt;/span&gt; 4k bloques y &lt;span class="m"&gt;327680&lt;/span&gt; nodos-i

UUID del sistema de ficheros: 44788452-bbb4-42e3-a5f3-4a1cfa50cabb
Respaldo del superbloque guardado en los bloques: 
    32768, 98304, 163840, 229376, 294912, 819200, 884736

Reservando las tablas de grupo: hecho                           
Escribiendo las tablas de nodos-i: hecho                           
Creando el fichero de transacciones &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;32768&lt;/span&gt; bloques&lt;span class="o"&gt;)&lt;/span&gt;: hecho
Escribiendo superbloques y la información contable del sistema de ficheros: hecho

root@server:~# tune2fs -m0 /dev/mapper/vg1-users 
tune2fs 1.42.12 &lt;span class="o"&gt;(&lt;/span&gt;29-Aug-2014&lt;span class="o"&gt;)&lt;/span&gt;
Se pone el porcentaje de bloques reservados a 0% &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; bloques&lt;span class="o"&gt;)&lt;/span&gt;
root@server:~# mount /dev/mapper/vg1-users /home/
root@server:~# df -h /home
S.ficheros            Tamaño Usados  Disp Uso% Montado en
/dev/mapper/vg1-users   4,8G    10M  4,8G   1% /home
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Tal como pasa el tiempo, vemos que los 5 GB de los usuarios se nos quedan cortos y decidimos que necesitan 10 GB. Como el &lt;em&gt;volume group&lt;/em&gt; no tiene 5 GB mas, hay que ampliarlo.&lt;/p&gt;
&lt;p&gt;Así pues, ponemos otro disco en la máquina, lo preparamos como &lt;em&gt;physical volume&lt;/em&gt; y lo asignamos al &lt;em&gt;volume group&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# pvcreate /dev/sdc
  Physical volume &lt;span class="s2"&gt;&amp;quot;/dev/sdc&amp;quot;&lt;/span&gt; successfully created
root@server:~# vgextend vg1 /dev/sdc
  Volume group &lt;span class="s2"&gt;&amp;quot;vg1&amp;quot;&lt;/span&gt; successfully extended
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Así nos queda el &lt;em&gt;volume group&lt;/em&gt;: tiene 12 GB y se compone de dos &lt;em&gt;physical volumes&lt;/em&gt;, uno de 8 GB y el otro de 4 GB, aunque para nosotros, el &lt;em&gt;volume group&lt;/em&gt; es una masa uniforme de información, sin importar en que disco cae.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# vgs
  VG   &lt;span class="c"&gt;#PV #LV #SN Attr   VSize  VFree&lt;/span&gt;
  vg1    &lt;span class="m"&gt;2&lt;/span&gt;   &lt;span class="m"&gt;1&lt;/span&gt;   &lt;span class="m"&gt;0&lt;/span&gt; wz--n- 11,99g 6,99g
root@server:~# pvs
  PV         VG   Fmt  Attr PSize PFree
  /dev/sdb   vg1  lvm2 a--  8,00g 3,00g
  /dev/sdc   vg1  lvm2 a--  4,00g 4,00g
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ya estamos en disposición de reclamar los 10 GB que necesitamos, asó que &lt;strong&gt;extendemos&lt;/strong&gt; el &lt;em&gt;logical volume&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# lvs
  LV    VG   Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  users vg1  -wi-ao---- 5,00g                                                    
root@server:~# lvextend /dev/mapper/vg1-users -L 10G
  Size of logical volume vg1/users changed from 5,00 GiB &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1280&lt;/span&gt; extents&lt;span class="o"&gt;)&lt;/span&gt; to 10,00 GiB &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2560&lt;/span&gt; extents&lt;span class="o"&gt;)&lt;/span&gt;.
  Logical volume users successfully resized
root@server:~# lvs
  LV    VG   Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  users vg1  -wi-ao---- 10,00g                                                    
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como curiosidad, se han absorbido 2 GB adicionales de cada &lt;em&gt;physical volume&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# pvs
  PV         VG   Fmt  Attr PSize PFree
  /dev/sdb   vg1  lvm2 a--  8,00g    0 
  /dev/sdc   vg1  lvm2 a--  4,00g 1,99g
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y un último detalle: a pesar de que la nueva "partición" dispone de 10 GB, el sistema de fichero subyacente no lo sabe, y solo tiene &lt;em&gt;inodos&lt;/em&gt; para indexar 5 GB de datos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# df -h /home/
S.ficheros            Tamaño Usados  Disp Uso% Montado en
/dev/mapper/vg1-users   4,8G    10M  4,8G   1% /home
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Por suerte para nosotros, el sistema de ficheros usado es &lt;em&gt;ext4&lt;/em&gt;, que nos permite redimensionarlo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# resize2fs /dev/mapper/vg1-users 
resize2fs 1.42.12 &lt;span class="o"&gt;(&lt;/span&gt;29-Aug-2014&lt;span class="o"&gt;)&lt;/span&gt;
El sistema de ficheros de /dev/mapper/vg1-users está montado en /home&lt;span class="p"&gt;;&lt;/span&gt; hace falta cambiar el tamaño en línea
&lt;span class="nv"&gt;old_desc_blocks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 1, &lt;span class="nv"&gt;new_desc_blocks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 1
The filesystem on /dev/mapper/vg1-users is now &lt;span class="m"&gt;2621440&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;4k&lt;span class="o"&gt;)&lt;/span&gt; blocks long.

root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto, el sistema de ficheros de &lt;em&gt;/home&lt;/em&gt; ya tiene el nuevo tamaño disponible y listo para usar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# df -h /home/
S.ficheros            Tamaño Usados  Disp Uso% Montado en
/dev/mapper/vg1-users   9,8G    12M  9,7G   1% /home
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto queda listo. Para hacer el montaje permanente, basta con añadir la línea adecuada a &lt;em&gt;/etc/fstab&lt;/em&gt;.&lt;/p&gt;</summary><category term="linux"></category><category term="lvm"></category><category term="logical volume manager"></category></entry><entry><title>Un repositorio de Debian con reprepro</title><link href="http://www.linuxsysadmin.tk/2016/01/un-repositorio-de-debian-con-reprepro.html" rel="alternate"></link><updated>2016-01-11T08:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-01-11:2016/01/un-repositorio-de-debian-con-reprepro.html</id><summary type="html">&lt;p&gt;Una de las grandes facilidades que nos ofrece una distribución de Linux es su sistema de gestor de paquetes. Los paquetes oficiales nos simplifican la instalación y mantenimiento de paquetes; sin embargo, podemos sacar provecho del sistema de paquetes para uso personal, para automatizar instalaciones y actualizaciones que queramos hacer.&lt;/p&gt;
&lt;p&gt;En este artículo vamos a crear un repositorio en el que podemos poner paquetes, sean sacados del repositorio oficial (para hacer de caché), o sean paquetes creados por nosotros con aplicativos propios o empaquetados a partir de paquetes no libres.&lt;/p&gt;
&lt;p&gt;Para hacerlo, necesitamos una máquina en donde pondremos el repositorio, y a efectos de demostración, una máquina en donde instalaremos paquetes de dicho repositorio. En este caso, usaremos como &lt;em&gt;LXC&lt;/em&gt; tecnología para crear las máquina virtuales.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# lxc-ls -f
NAME        STATE    IPV4      IPV6  AUTOSTART  
----------------------------------------------
client      RUNNING  10.0.0.3  -     YES        
repository  RUNNING  10.0.0.2  -     YES        
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Montando el repositorio&lt;/h2&gt;
&lt;p&gt;Un repositorio &lt;em&gt;Debian&lt;/em&gt; no es mas que un servidor web sirviendo una estructura de ficheros con una forma concreta, que vamos a crear con &lt;strong&gt;reprepro&lt;/strong&gt; y vamos a servir con &lt;strong&gt;nginx&lt;/strong&gt;. Aís pues, los instalamos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@repository:~# apt-get install reprepro nginx-light
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias       
Leyendo la información de estado... Hecho
...
Se instalarán los siguientes paquetes NUEVOS:
  ca-certificates gnupg-agent gnupg2 libarchive13 libassuan0 libcurl3-gnutls libffi6 libgmp10 libgnutls-deb0-28 libgpgme11 libhogweed2 libidn11 libksba8 libldap-2.4-2
  liblzo2-2 libnettle4 libp11-kit0 libpth20 librtmp1 libsasl2-2 libsasl2-modules libsasl2-modules-db libssh2-1 libtasn1-6 libxml2 nginx-common nginx-light openssl
  pinentry-curses reprepro sgml-base xml-core
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;32&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar 7.645 kB de archivos.
Se utilizarán 21,2 MB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
root@repository:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Un repositorio necesita una clave &lt;strong&gt;gpg&lt;/strong&gt; para firmar los paquetes que sirve; aunque de eso se encarga &lt;strong&gt;reprepro&lt;/strong&gt;, tenemos que generarla:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@repository:~# gpg --gen-key
gpg &lt;span class="o"&gt;(&lt;/span&gt;GnuPG&lt;span class="o"&gt;)&lt;/span&gt; 1.4.18&lt;span class="p"&gt;;&lt;/span&gt; Copyright &lt;span class="o"&gt;(&lt;/span&gt;C&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="m"&gt;2014&lt;/span&gt; Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
...
gpg: /root/.gnupg/trustdb.gpg: se ha creado base de datos de confianza
gpg: clave C1B88DF7 marcada como de confianza absoluta
claves pública y secreta creadas y firmadas.
...
root@repository:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora podemos ver que las claves se han creado y podemos anotar su identificador para continuar con el procedimiento.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@repository:~# gpg --list-keys
/root/.gnupg/pubring.gpg
------------------------
pub   2048R/C1B88DF7 2016-01-07
uid                  Gerard Monells &amp;lt;gerard.monells@gmail.com&amp;gt;
sub   2048R/5C5B84E3 2016-01-07

root@repository:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a crear el repositorio en &lt;em&gt;/opt/repo/&lt;/em&gt;, con una carpeta &lt;em&gt;public&lt;/em&gt; que es lo que vamos a servir con &lt;strong&gt;nginx&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@repository:~# mkdir -p /opt/repo/&lt;span class="o"&gt;{&lt;/span&gt;conf,public&lt;span class="o"&gt;}&lt;/span&gt;
root@repository:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Por comodidad, vamos a trabajar en la carpeta base del repositorio.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@repository:~# &lt;span class="nb"&gt;cd&lt;/span&gt; /opt/repo
root@repository:/opt/repo# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Un repositorio hecho con &lt;strong&gt;reprepro&lt;/strong&gt; se declara mediante un fichero de configuración, que vamos a crear en la carpeta &lt;em&gt;conf&lt;/em&gt;, declarando el nombre del repositorio, las arquitecturas y la clave con la que se firman los paquetes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@repository:/opt/repo# cat conf/distributions 
Codename: linuxsysadmin
Components: main
Architectures: i386
SignWith: C1B88DF7
root@repository:/opt/repo# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a poner la parte pública de nuestra clave &lt;strong&gt;gpg&lt;/strong&gt; en la raíz del servidor web, para que los clientes puedan agregarla a su almacén de claves, para usar sin problemas los paquetes de nuestro repositorio.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@repository:/opt/repo# gpg -a --export C1B88DF7 &amp;gt; /opt/repo/public/key.gpg
root@repository:/opt/repo# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora vamos a poner una configuración a &lt;strong&gt;nginx&lt;/strong&gt; que nos permita servir la carpeta pública en el puerto web.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@repository:/opt/repo# cat /etc/nginx/sites-enabled/repository
server &lt;span class="o"&gt;{&lt;/span&gt;
    server_name localhost&lt;span class="p"&gt;;&lt;/span&gt;
    root /opt/repo/public&lt;span class="p"&gt;;&lt;/span&gt;
    autoindex on&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
root@repository:/opt/repo# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Recargamos o reiniciamos el servicio &lt;strong&gt;nginx&lt;/strong&gt; para que la configuración surta efecto:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@repository:/opt/repo# service nginx restart
root@repository:/opt/repo# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Añadiendo paquetes al repositorio&lt;/h2&gt;
&lt;p&gt;Añadir un paquete a nuestro repositorio es tan fácil como invocar el comando &lt;em&gt;reprepro&lt;/em&gt;, con la opción &lt;em&gt;includedeb&lt;/em&gt; del paquete, en alguna carpeta de nuestra máquina. El resto son opciones que indican donde están las carpetas del repositorio.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: Si se pone un paquete empaquetado por nosotros, es importante que su fichero &lt;em&gt;control&lt;/em&gt; incluya las directivas &lt;em&gt;Section&lt;/em&gt; y &lt;em&gt;Priority&lt;/em&gt;, normalmente solo recomendadas, pero necesarias para &lt;strong&gt;reprepro&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Por ejemplo, podemos usar el paquete de un &lt;a href="http://www.linuxsysadmin.tk/2015/12/empaquetando-ficheros-punto-deb.html"&gt;artículo anterior&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@repository:/opt/repo# reprepro --distdir ./public/dists --outdir ./public includedeb linuxsysadmin /root/welcome_1.0-1_all.deb 
Exporting indices...
root@repository:/opt/repo# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: Puede que el comando falle si no se ha montado el sistema de ficheros &lt;em&gt;/dev/pts&lt;/em&gt;, especialmente en un entorno tipo &lt;strong&gt;chroot&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Usando el repositorio&lt;/h2&gt;
&lt;p&gt;Cambiamos de máquina; ahora vamos a la máquina que vaya a usar el repositorio y vamos a configurar el repositorio nuevo.&lt;/p&gt;
&lt;p&gt;Lo primero es declarar la &lt;strong&gt;source&lt;/strong&gt; de nuestro repositorio, declarando la dirección web del repositorio, el nombre del repositorio y el componente.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@client:~# cat /etc/apt/sources.list.d/linuxsysadmin.list 
deb http://10.0.0.2/ linuxsysadmin main
root@client:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora nos descargamos la clave pública del repositorio y la añadimos al almacén de claves de &lt;strong&gt;apt&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@client:~# wget -qO- http://10.0.0.2/key.gpg &lt;span class="p"&gt;|&lt;/span&gt; apt-key add -
OK
root@client:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto ya tenemos el repositorio habilitado. A partir de aquí su uso es el mismo que el de cualquier otro repositorio. Hacemos un &lt;em&gt;apt-get update&lt;/em&gt; para descargar la lista de paquetes del repositorio.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@client:~# apt-get update
Des:1 http://10.0.0.2 linuxsysadmin InRelease &lt;span class="o"&gt;[&lt;/span&gt;1.340 B&lt;span class="o"&gt;]&lt;/span&gt;
...
Des:2 http://10.0.0.2 linuxsysadmin/main i386 Packages &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;333&lt;/span&gt; B&lt;span class="o"&gt;]&lt;/span&gt;
...
Descargados 2.040 B en 6s &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;330&lt;/span&gt; B/s&lt;span class="o"&gt;)&lt;/span&gt;                                                                                                                                    
Leyendo lista de paquetes... Hecho
root@client:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A partir de aquí, y sabiendo nuestro sistema los paquetes de los que dispone el nuevo repositorio, podemos buscar los paquetes que hay en él.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@client:~# apt-cache search welcome &lt;span class="p"&gt;|&lt;/span&gt; grep ^welcome
welcome2l - Linux ANSI boot logo
welcome - A fancy shell script
root@client:~# apt-cache show welcome
Package: welcome
Version: 1.0-1
Architecture: all
Maintainer: Linux Sysadmin
Priority: optional
Section: main
Filename: pool/main/w/welcome/welcome_1.0-1_all.deb
Size: 786
SHA256: 2e701f7fbc090230fb7abc06597fbe5b4e9e70dcc553e749e69793a745b032f2
SHA1: 41351d1d2135bcee09e1fa3bade984ece9f23caf
MD5sum: 574fab58b3c871184047c40d0e732b35
Description: A fancy shell script
 To demonstrate how to package a .deb file
Description-md5: ed73975a1e7c5f0422fef1f624586821
Depends: bash, coreutils

root@client:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Visto que el paquete está disponible, podemos instalarlo, usando &lt;em&gt;apt-get&lt;/em&gt; o cualquier otro frontal, gráfico o no.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@client:~# apt-get install welcome
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias       
Leyendo la información de estado... Hecho
Se instalarán los siguientes paquetes NUEVOS:
  welcome
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;1&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar &lt;span class="m"&gt;786&lt;/span&gt; B de archivos.
Se utilizarán &lt;span class="m"&gt;0&lt;/span&gt; B de espacio de disco adicional después de esta operación.
Des:1 http://10.0.0.2/ linuxsysadmin/main welcome all 1.0-1 &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;786&lt;/span&gt; B&lt;span class="o"&gt;]&lt;/span&gt;
Descargados &lt;span class="m"&gt;786&lt;/span&gt; B en 0s &lt;span class="o"&gt;(&lt;/span&gt;37,4 kB/s&lt;span class="o"&gt;)&lt;/span&gt;
debconf: se retrasa la configuración de los paquetes, ya que «apt-utils» no está instalado
Seleccionando el paquete welcome previamente no seleccionado.
&lt;span class="o"&gt;(&lt;/span&gt;Leyendo la base de datos ... &lt;span class="m"&gt;10434&lt;/span&gt; ficheros o directorios instalados actualmente.&lt;span class="o"&gt;)&lt;/span&gt;
Preparando para desempaquetar .../archives/welcome_1.0-1_all.deb ...
Desempaquetando welcome &lt;span class="o"&gt;(&lt;/span&gt;1.0-1&lt;span class="o"&gt;)&lt;/span&gt; ...
Configurando welcome &lt;span class="o"&gt;(&lt;/span&gt;1.0-1&lt;span class="o"&gt;)&lt;/span&gt; ...
root@client:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Tal como lo esperábamos, el comando &lt;em&gt;welcome&lt;/em&gt; está instalado y funciona como esperábamos:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@client:~# which welcome
/usr/bin/welcome
root@client:~# welcome
Hello world!
root@client:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto tenemos nuestro repositorio funcional.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="repositorio"></category><category term="reprepro"></category><category term="nginx"></category><category term="gpg"></category><category term="apt"></category></entry><entry><title>Enjaulado de usuarios para uso de rsync</title><link href="http://www.linuxsysadmin.tk/2016/01/enjaulado-de-usuarios-para-uso-de-rsync.html" rel="alternate"></link><updated>2016-01-04T10:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-01-04:2016/01/enjaulado-de-usuarios-para-uso-de-rsync.html</id><summary type="html">&lt;p&gt;Todos nos hemos encontrado alguna vez con una web, sea en &lt;em&gt;HTML&lt;/em&gt; o en &lt;em&gt;PHP&lt;/em&gt;, que se compone de centenares o miles de ficheros, y que hay que ir actualizando cada vez que cambian unos pocos ficheros. En estos casos la capacidad incremental de la herramienta &lt;strong&gt;rsync&lt;/strong&gt; puede ayudarnos mucho.&lt;/p&gt;
&lt;p&gt;Sin embargo, la herramienta &lt;strong&gt;rsync&lt;/strong&gt; funciona por el puerto de &lt;em&gt;SSH&lt;/em&gt;, y dar acceso al mismo es un problema desde el punto de vista de la seguridad del sistema. Vamos a crear una jaula para los usuarios que lo necesiten, y vamos a limitar los comandos que puede utilizar, de forma que solo pueda hacer &lt;strong&gt;rsync&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Para poder continuar, necesitamos las 2 herramientas que se van a usar: &lt;strong&gt;rsync&lt;/strong&gt; y &lt;strong&gt;rssh&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# apt-get install rssh rsync
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias       
Leyendo la información de estado... Hecho
...
Se instalarán los siguientes paquetes NUEVOS:
  libpopt0 rssh rsync
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;3&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar &lt;span class="m"&gt;505&lt;/span&gt; kB de archivos.
Se utilizarán &lt;span class="m"&gt;962&lt;/span&gt; kB de espacio de disco adicional después de esta operación.
...
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Preparación del sistema de enjaulado&lt;/h2&gt;
&lt;p&gt;Como decisión de diseño, he decidido que voy a enjaular todos los usuarios que pertenezcan a un grupo, al que llamaremos &lt;em&gt;restricted&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# groupadd restricted
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora vamos a configurar el demonio &lt;strong&gt;SSH&lt;/strong&gt; para que todos los usuarios del grupo &lt;em&gt;restricted&lt;/em&gt; queden enjaulados en &lt;em&gt;/srv/jails/&lt;/em&gt;, en una carpeta por usuario. La directiva &lt;em&gt;X11Forwarding&lt;/em&gt; y &lt;em&gt;AllowTcpForwarding&lt;/em&gt; son restricciones adicionales y no son necesarias.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# cat /etc/ssh/sshd_config 
...
Match group restricted
    ChrootDirectory /srv/jails/%u
    X11Forwarding no
    AllowTcpForwarding no
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y reiniciamos el demonio para que se apliquen las modificaciones en la configuración.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# service ssh restart
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creando una jaula para el primer usuario&lt;/h2&gt;
&lt;p&gt;Para tener un usuario enjaulado, necesitamos un usuario, en este caso, el usuario &lt;em&gt;web&lt;/em&gt;. Le vamos a poner &lt;em&gt;rssh&lt;/em&gt; como shell, su carpeta personal como &lt;em&gt;/&lt;/em&gt; y le asignamos el grupo &lt;em&gt;restricted&lt;/em&gt; para que quede enjaulado.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# useradd -d / -s /usr/bin/rssh -G restricted web
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para que el usuario &lt;em&gt;web&lt;/em&gt; pueda entrar en esta máquina, necesita una contraseña. Alternativamente, podríamos haber montado una autenticación por claves &lt;em&gt;SSH&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# passwd web
Introduzca la nueva contraseña de UNIX: 
Vuelva a escribir la nueva contraseña de UNIX: 
passwd: contraseña actualizada correctamente
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y ahora vamos a crearle una estructura de carpetas muy básica en donde deberá estar su jaula. Puesto que se trata del usuario &lt;em&gt;web&lt;/em&gt;, la carpeta de la jaula (la que el usuario verá como &lt;em&gt;/&lt;/em&gt;) va a ser &lt;em&gt;/srv/jails/web/&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IMPORTANTE&lt;/strong&gt;: Esta carpeta y todas las de la ruta deben perteneces al usuario &lt;em&gt;root&lt;/em&gt; y tener permisos de escritura solo por el &lt;em&gt;owner&lt;/em&gt;; de otra manera, el &lt;em&gt;SSH&lt;/em&gt; falla al enjaular.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# mkdir -p /srv/jails/web/&lt;span class="o"&gt;{&lt;/span&gt;usr/bin,etc,lib&lt;span class="o"&gt;}&lt;/span&gt;
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para limitar que el usuario solo pueda hacer &lt;em&gt;rsync&lt;/em&gt; vamos a necesitar la ayuda de &lt;em&gt;rssh&lt;/em&gt;; así pues, vamos a poner ambos binarios en la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# cp /usr/bin/rssh /srv/jails/web/usr/bin/
root@webserver:~# cp /usr/bin/rsync /srv/jails/web/usr/bin/
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Estos dos comandos son binarios &lt;em&gt;linkados&lt;/em&gt; dinámicamente que necesitan librerías. Vamos a buscarlos con el comando &lt;strong&gt;ldd&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# ldd /usr/bin/rssh 
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb7789000&lt;span class="o"&gt;)&lt;/span&gt;
    libc.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libc.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0xb760a000&lt;span class="o"&gt;)&lt;/span&gt;
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb778c000&lt;span class="o"&gt;)&lt;/span&gt;
root@webserver:~# ldd /usr/bin/rsync 
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb7741000&lt;span class="o"&gt;)&lt;/span&gt;
    libattr.so.1 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libattr.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb76a3000&lt;span class="o"&gt;)&lt;/span&gt;
    libacl.so.1 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libacl.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb7699000&lt;span class="o"&gt;)&lt;/span&gt;
    libpopt.so.0 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libpopt.so.0 &lt;span class="o"&gt;(&lt;/span&gt;0xb768a000&lt;span class="o"&gt;)&lt;/span&gt;
    libc.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libc.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0xb7519000&lt;span class="o"&gt;)&lt;/span&gt;
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb7744000&lt;span class="o"&gt;)&lt;/span&gt;
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y las copiamos en la carpeta &lt;em&gt;lib&lt;/em&gt; de la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# cp /lib/ld-linux.so.2 /srv/jails/web/lib/
root@webserver:~# cp /lib/i386-linux-gnu/libc.so.6 /srv/jails/web/lib/
root@webserver:~# cp /lib/i386-linux-gnu/libattr.so.1 /srv/jails/web/lib/
root@webserver:~# cp /lib/i386-linux-gnu/libacl.so.1 /srv/jails/web/lib/
root@webserver:~# cp /lib/i386-linux-gnu/libpopt.so.0 /srv/jails/web/lib/
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Voy a quitar los permisos de ejecución de la librería &lt;em&gt;libc&lt;/em&gt; porque no lo necesita.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# chmod &lt;span class="m"&gt;644&lt;/span&gt; /srv/jails/web/lib/libc.so.6 
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora que tenemos las librerías en la jaula, volvemos a mirar que otras librerías puedan necesitar con &lt;strong&gt;ldd&lt;/strong&gt;, para evitar dejarnos ninguna.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# ldd /srv/jails/web/lib/*
/srv/jails/web/lib/ld-linux.so.2:
    statically linked
/srv/jails/web/lib/libacl.so.1:
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb77b3000&lt;span class="o"&gt;)&lt;/span&gt;
    libattr.so.1 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libattr.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb779e000&lt;span class="o"&gt;)&lt;/span&gt;
    libc.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libc.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0xb762d000&lt;span class="o"&gt;)&lt;/span&gt;
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb77b6000&lt;span class="o"&gt;)&lt;/span&gt;
/srv/jails/web/lib/libattr.so.1:
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb7756000&lt;span class="o"&gt;)&lt;/span&gt;
    libc.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libc.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0xb75da000&lt;span class="o"&gt;)&lt;/span&gt;
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb7759000&lt;span class="o"&gt;)&lt;/span&gt;
/srv/jails/web/lib/libc.so.6:
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb779f000&lt;span class="o"&gt;)&lt;/span&gt;
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb779c000&lt;span class="o"&gt;)&lt;/span&gt;
/srv/jails/web/lib/libpopt.so.0:
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb7782000&lt;span class="o"&gt;)&lt;/span&gt;
    libc.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libc.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0xb75fe000&lt;span class="o"&gt;)&lt;/span&gt;
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb7785000&lt;span class="o"&gt;)&lt;/span&gt;
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y como no han entrado de nuevas, hemos acabado con esto. Ahora vamos a copiar la configuración de &lt;strong&gt;rssh&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# cp /etc/rssh.conf /srv/jails/web/etc/
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a añadir la directiva &lt;em&gt;allowrsync&lt;/em&gt; ya que, por defecto, no se permite nada:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ANTES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# grep allowrsync /srv/jails/web/etc/rssh.conf 
&lt;span class="c"&gt;#allowrsync&lt;/span&gt;
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;DESPUES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# grep allowrsync /srv/jails/web/etc/rssh.conf 
allowrsync
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como estamos esperando que el usuario &lt;em&gt;web&lt;/em&gt; deje sus cosas en una carpeta &lt;em&gt;www&lt;/em&gt;, vamos a crearla, ya que va a ser la única en la que pueda copiar sus cosas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# mkdir /srv/jails/web/www
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y le damos permisos necesarios para que escriba en ella; por ejemplo, le damos la propiedad de la carpeta.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# chown web:web /srv/jails/web/www/
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto queda completa la jaula. Como demostración, muestro la salida del comando &lt;strong&gt;tree&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# tree /srv/jails/web/
/srv/jails/web/
├── etc
│   └── rssh.conf
├── lib
│   ├── ld-linux.so.2
│   ├── libacl.so.1
│   ├── libattr.so.1
│   ├── libc.so.6
│   └── libpopt.so.0
├── usr
│   └── bin
│       ├── rssh
│       └── rsync
└── www

&lt;span class="m"&gt;5&lt;/span&gt; directories, &lt;span class="m"&gt;8&lt;/span&gt; files
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Uso de la jaula&lt;/h2&gt;
&lt;p&gt;Supongamos que tenemos un proyecto web en una máquina &lt;em&gt;developer&lt;/em&gt;, por ejemplo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@developer:~&lt;span class="nv"&gt;$ &lt;/span&gt;tree web/
web/
└── index.html

&lt;span class="m"&gt;0&lt;/span&gt; directories, &lt;span class="m"&gt;1&lt;/span&gt; file
gerard@developer:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Intentamos entrar por &lt;em&gt;SSH&lt;/em&gt; y vemos que falla:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@developer:~&lt;span class="nv"&gt;$ &lt;/span&gt;ssh web@10.0.0.2
web@10.0.0.2&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s password: 

The programs included with the Debian GNU/Linux system are free software&lt;span class="p"&gt;;&lt;/span&gt;
the exact distribution terms &lt;span class="k"&gt;for&lt;/span&gt; each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Wed Dec &lt;span class="m"&gt;30&lt;/span&gt; 21:12:44 &lt;span class="m"&gt;2015&lt;/span&gt; from 10.0.0.3

This account is restricted by rssh.
Allowed commands: rsync 

If you believe this is in error, please contact your system administrator.

Connection to 10.0.0.2 closed.
gerard@developer:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a usar &lt;em&gt;rsync&lt;/em&gt; para sincronizar este proyecto con el servidor que acabamos de montar. Para eso, la máquina cliente necesita tener instalado el paquete &lt;strong&gt;rsync&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@developer:~&lt;span class="nv"&gt;$ &lt;/span&gt;rsync -rvzc --delete web/ web@10.0.0.2:/www
web@10.0.0.2&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s password: 
sending incremental file list
index.html

sent &lt;span class="m"&gt;139&lt;/span&gt; bytes  received &lt;span class="m"&gt;35&lt;/span&gt; bytes  49.71 bytes/sec
total size is &lt;span class="m"&gt;12&lt;/span&gt;  speedup is 0.07
gerard@developer:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Si repetimos el comando, vemos que la lista de ficheros no incluye el &lt;em&gt;index.html&lt;/em&gt;, porque no ha cambiado respecto a lo que tenemos en el servidor, así que no lo manda.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@developer:~&lt;span class="nv"&gt;$ &lt;/span&gt;rsync -rvzc --delete web/ web@10.0.0.2:/www
web@10.0.0.2&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s password: 
sending incremental file list

sent &lt;span class="m"&gt;83&lt;/span&gt; bytes  received &lt;span class="m"&gt;12&lt;/span&gt; bytes  7.60 bytes/sec
total size is &lt;span class="m"&gt;12&lt;/span&gt;  speedup is 0.13
gerard@developer:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;los &lt;em&gt;flags&lt;/em&gt; elegidos son &lt;strong&gt;-r&lt;/strong&gt; (recursivo), &lt;strong&gt;-v&lt;/strong&gt; (verbose), &lt;strong&gt;-z&lt;/strong&gt; (comprimido), &lt;strong&gt;-c&lt;/strong&gt; (diferenciar por &lt;em&gt;checksum&lt;/em&gt;) y &lt;strong&gt;--delete&lt;/strong&gt; (para borrar fichero que estén en el servidor y no deban).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IMPORTANTE&lt;/strong&gt;: la carpeta origen acaba con &lt;em&gt;/&lt;/em&gt;. Esa es la diferencia entre copiar el contenido de la carpeta y copiar la carpeta misma.&lt;/p&gt;
&lt;p&gt;Analizamos el resultado y vemos que lo hemos copiado en &lt;em&gt;/www/&lt;/em&gt;, siempre desde el punto de vista de la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@webserver:~# ls /www
ls: no se puede acceder a /www: No existe el fichero o el directorio
root@webserver:~# tree /srv/jails/web/
/srv/jails/web/
├── etc
│   └── rssh.conf
├── lib
│   ├── ld-linux.so.2
│   ├── libacl.so.1
│   ├── libattr.so.1
│   ├── libc.so.6
│   └── libpopt.so.0
├── usr
│   └── bin
│       ├── rssh
│       └── rsync
└── www
    └── index.html

&lt;span class="m"&gt;5&lt;/span&gt; directories, &lt;span class="m"&gt;9&lt;/span&gt; files
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto está todo hecho. Solo falta instalar el servidor web, pero eso lo dejo pendiente.&lt;/p&gt;</summary><category term="linux"></category><category term="rsync"></category><category term="rssh"></category><category term="ssh"></category><category term="ldd"></category><category term="jaula"></category></entry><entry><title>Empaquetando ficheros .deb</title><link href="http://www.linuxsysadmin.tk/2015/12/empaquetando-ficheros-punto-deb.html" rel="alternate"></link><updated>2015-12-28T10:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-12-28:2015/12/empaquetando-ficheros-punto-deb.html</id><summary type="html">&lt;p&gt;Una de las grandes ventajas de &lt;em&gt;linux&lt;/em&gt; es su sistema de paquetes. Con ellos es posible instalar de forma fácil un paquete de forma fácil y confiable. Hoy vamos a hacer un paquete &lt;em&gt;.deb&lt;/em&gt; como ejemplo que instale un &lt;em&gt;script&lt;/em&gt; cualquiera en la carpeta &lt;em&gt;/usr/bin/&lt;/em&gt; para su uso cotidiano.&lt;/p&gt;
&lt;p&gt;Por limpieza, vamos a crear una carpeta temporal para hacer el empaquetado, desde donde vamos a ejecutar todo el resto del procedimiento.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@packager:~# mkdir workspace
root@packager:~# &lt;span class="nb"&gt;cd &lt;/span&gt;workspace/
root@packager:~/workspace# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Preparación de la estructura del paquete&lt;/h2&gt;
&lt;p&gt;Vamos a poner el &lt;em&gt;script&lt;/em&gt; que queramos empaquetar, respetando al estructura que tendrá una vez se instale el paquete. También le damos los permisos que va a tener una vez instalado.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@packager:~/workspace# mkdir -p usr/bin
root@packager:~/workspace# cat usr/bin/welcome
&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello world!&amp;#39;&lt;/span&gt;
root@packager:~/workspace# chmod &lt;span class="m"&gt;755&lt;/span&gt; usr/bin/welcome
root@packager:~/workspace# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Empaquetado de la carpeta de trabajo&lt;/h2&gt;
&lt;p&gt;Antes de empaquetar de acuerdo a las políticas de los paquetes &lt;em&gt;.deb&lt;/em&gt;, sea en &lt;em&gt;Debian&lt;/em&gt; o en &lt;em&gt;Ubuntu&lt;/em&gt;, se requiere de una carpeta &lt;strong&gt;DEBIAN&lt;/strong&gt; con un fichero &lt;strong&gt;control&lt;/strong&gt;, que va a contener los metadatos del paquete.&lt;/p&gt;
&lt;p&gt;Para este fichero nos podemos guiar por la &lt;a href="https://www.debian.org/doc/debian-policy/ch-controlfields.html"&gt;documentación oficial&lt;/a&gt;. Como vamos a hacer un paquete mínimo, vamos a poner solamente los campos obligatorios y uno de los opcionales, que indicarán las necesidades de nuestro script:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Obligatorios&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;Package&lt;/li&gt;
&lt;li&gt;Version&lt;/li&gt;
&lt;li&gt;Architecture compilado los binarios&lt;/li&gt;
&lt;li&gt;Maintainer&lt;/li&gt;
&lt;li&gt;Description&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Opcionales&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;Depends&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para que el &lt;em&gt;script&lt;/em&gt; pueda funcionar, hay que localizar todo aquello que pueda necesitar, y añadirlo al paquete o declarar los paquetes de los que dependa, para que se puedan instalar automáticamente si no estuvieran en el sistema destino.&lt;/p&gt;
&lt;p&gt;Concretamente, este &lt;em&gt;script&lt;/em&gt; necesita dos comandos para funcionar: &lt;strong&gt;bash&lt;/strong&gt; y &lt;strong&gt;echo&lt;/strong&gt;. Vamos a localizarlos a ver de que paquete provienen. La idea es que nuestro paquete va a necesitar todos los paquetes que contengan los comandos necesarios, sin necesidad de incorporarlos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@packager:~/workspace# which bash
/bin/bash
root@packager:~/workspace# dpkg -S /bin/bash
bash: /bin/bash
root@packager:~/workspace# which &lt;span class="nb"&gt;echo&lt;/span&gt;
/bin/echo
root@packager:~/workspace# dpkg -S /bin/echo 
coreutils: /bin/echo
root@packager:~/workspace# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;De ahí deducimos que necesitamos los paquetes &lt;strong&gt;bash&lt;/strong&gt; y &lt;strong&gt;coreutils&lt;/strong&gt;, que aunque suelen venir de serie, vale la pena declararlos por si no fuera el caso. Esto es lo que va en el campo &lt;strong&gt;Depends&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Reuniendo estos datos, podemos crear el fichero &lt;strong&gt;control&lt;/strong&gt;, por ejemplo, como este:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@packager:~/workspace# mkdir -p DEBIAN
root@packager:~/workspace# cat DEBIAN/control 
Package: welcome
Version: 1.0-1
Architecture: all
Maintainer: Linux Sysadmin
Description: A fancy shell script
 To demonstrate how to package a .deb file
Depends: bash, coreutils
root@packager:~/workspace# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Adicionalmente, la carpeta &lt;strong&gt;DEBIAN&lt;/strong&gt; puede contener otros &lt;em&gt;scripts&lt;/em&gt;, como por ejemplo, &lt;strong&gt;preinst&lt;/strong&gt;, &lt;strong&gt;postinst&lt;/strong&gt;, &lt;strong&gt;prerm&lt;/strong&gt; y &lt;strong&gt;postrm&lt;/strong&gt;, que podrían, por ejemplo, crear los usuarios necesarios.&lt;/p&gt;
&lt;p&gt;Como último paso, vamos a invocar el comando &lt;strong&gt;dpkg-deb&lt;/strong&gt; para empaquetar la carpeta de trabajo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@packager:~/workspace# &lt;span class="nb"&gt;cd&lt;/span&gt; ..
root@packager:~# dpkg-deb --build workspace/ welcome_1.0-1_all.deb
dpkg-deb: construyendo el paquete &lt;span class="sb"&gt;`&lt;/span&gt;welcome&lt;span class="s1"&gt;&amp;#39; en `welcome_1.0-1_all.deb&amp;#39;&lt;/span&gt;.
root@packager:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Comprobación de que el paquete funciona&lt;/h2&gt;
&lt;p&gt;Vamos a comprobar que el paquete no está instalado, por ejemplo buscando el &lt;em&gt;script&lt;/em&gt; que hemos empaquetado:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@packager:~# which welcome
root@packager:~# welcome 
bash: /usr/bin/welcome: No existe el fichero o el directorio
root@packager:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Efectivamente, no lo está; ahora se trata de invocar &lt;strong&gt;dpkg&lt;/strong&gt; para instalar nuestro paquete.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@packager:~# dpkg -i welcome_1.0-1_all.deb 
Seleccionando el paquete welcome previamente no seleccionado.
&lt;span class="o"&gt;(&lt;/span&gt;Leyendo la base de datos ... &lt;span class="m"&gt;9984&lt;/span&gt; ficheros o directorios instalados actualmente.&lt;span class="o"&gt;)&lt;/span&gt;
Preparando para desempaquetar welcome_1.0-1_all.deb ...
Desempaquetando welcome &lt;span class="o"&gt;(&lt;/span&gt;1.0-1&lt;span class="o"&gt;)&lt;/span&gt; ...
Configurando welcome &lt;span class="o"&gt;(&lt;/span&gt;1.0-1&lt;span class="o"&gt;)&lt;/span&gt; ...
root@packager:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y finalmente, verificamos que tenemos nuestro &lt;em&gt;script&lt;/em&gt; en &lt;em&gt;/usr/bin/&lt;/em&gt; como esperábamos:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@packager:~# which welcome
/usr/bin/welcome
root@packager:~# welcome
Hello world!
root@packager:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto tenemos nuestro paquete que podemos poner a buen recaudo.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="ubuntu"></category><category term="paquete"></category><category term=".deb"></category></entry><entry><title>Utilizando apt-cacher-ng para agilizar la instalación de paquetes</title><link href="http://www.linuxsysadmin.tk/2015/12/utilizando-apt-cacher-ng-para-agilizar-la-instalacion-de-paquetes.html" rel="alternate"></link><updated>2015-12-21T10:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-12-21:2015/12/utilizando-apt-cacher-ng-para-agilizar-la-instalacion-de-paquetes.html</id><summary type="html">&lt;p&gt;Hace tiempo veo que tras usar muchas maquinas virtuales &lt;em&gt;Debian&lt;/em&gt; para el uso diario y para las demostraciones de este blog, el ancho de banda usado para bajar los paquetes se dispara. La mayoría de veces se trata de los mismos paquetes, para instalar las mismas aplicaciones, servicios o actualizaciones.&lt;/p&gt;
&lt;p&gt;En el artículo de hoy, voy a enseñar como usar un &lt;em&gt;proxy&lt;/em&gt; con una &lt;em&gt;caché&lt;/em&gt; para &lt;em&gt;apt-get&lt;/em&gt;, llamado &lt;strong&gt;apt-cacher-ng&lt;/strong&gt;, de forma que los paquetes son descargados por la primera máquina que los pida, guardados en un servidor local y aprovechados por el resto de máquinas.&lt;/p&gt;
&lt;h2&gt;Preparación de las máquinas&lt;/h2&gt;
&lt;p&gt;Partimos de la máquina habitual, llamada &lt;strong&gt;aptcacher&lt;/strong&gt;, siendo esta un contenedor LXC con una &lt;em&gt;Debian Jessie&lt;/em&gt; básica, aunque esto se podría haber puesto en una &lt;em&gt;Ubuntu&lt;/em&gt; o cualquier otra distribución que funcione con paquetes &lt;em&gt;.deb&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Otras máquinas que vamos a usar son unas máquinas cliente en donde vamos a instalar paquetes cualesquiera para demostrar el funcionamiento, llamadas &lt;strong&gt;client1&lt;/strong&gt; y &lt;strong&gt;client2&lt;/strong&gt;; estos clientes están en la misma red que la máquina &lt;strong&gt;aptcacher&lt;/strong&gt; y tienen conectividad con ella por el puerto &lt;em&gt;TCP&lt;/em&gt; 3142.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# lxc-ls -f
NAME       STATE    IPV4      IPV6  AUTOSTART  
---------------------------------------------
aptcacher  RUNNING  10.0.0.2  -     YES        
client1    RUNNING  10.0.0.3  -     YES        
client2    RUNNING  10.0.0.4  -     YES        
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Empezamos instalando el servicio &lt;strong&gt;apt-cacher-ng&lt;/strong&gt; en la máquina servidor &lt;strong&gt;aptcacher&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@aptcacher:~# apt-get install apt-cacher-ng
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias... Hecho
...  
Se instalarán los siguientes paquetes NUEVOS:
  apt-cacher-ng ed
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;2&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar &lt;span class="m"&gt;500&lt;/span&gt; kB de archivos.
Se utilizarán 1.168 kB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
root@aptcacher:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Las configuraciones que vienen por defecto son bastante adecuadas y no tuve que efectuar ningún cambio.&lt;/p&gt;
&lt;p&gt;Por otra parte, hay que configurar las máquinas que se quieran beneficiar de este servidor, añadiendo una línea de configuración en su &lt;strong&gt;apt-get&lt;/strong&gt;, por ejemplo, poniendo un fichero adicional en &lt;em&gt;/etc/apt/apt.conf.d/&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@aptcacher:~# cat /etc/apt/apt.conf.d/02proxy 
Acquire::http &lt;span class="o"&gt;{&lt;/span&gt; Proxy &lt;span class="s2"&gt;&amp;quot;http://10.0.0.2:3142&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
root@aptcacher:~# 

root@client1:~# cat /etc/apt/apt.conf.d/02proxy 
Acquire::http &lt;span class="o"&gt;{&lt;/span&gt; Proxy &lt;span class="s2"&gt;&amp;quot;http://10.0.0.2:3142&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
root@client1:~# 

root@client2:~# cat /etc/apt/apt.conf.d/02proxy 
Acquire::http &lt;span class="o"&gt;{&lt;/span&gt; Proxy &lt;span class="s2"&gt;&amp;quot;http://10.0.0.2:3142&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
root@client2:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto queda montado todo el sistema.&lt;/p&gt;
&lt;h2&gt;Funcionamiento de la caché&lt;/h2&gt;
&lt;p&gt;El funcionamiento es muy simple: basta con instalar en un cliente un paquete, por ejemplo, &lt;em&gt;python&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@client1:~# apt-get install python
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias... Hecho
...  
Se instalarán los siguientes paquetes NUEVOS:
  file libexpat1 libffi6 libmagic1 libpython-stdlib libpython2.7-minimal
  libpython2.7-stdlib libsqlite3-0 mime-support python python-minimal
  python2.7 python2.7-minimal
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;13&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar 5.010 kB de archivos.
Se utilizarán 21,3 MB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
Descargados 5.010 kB en 15s &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;327&lt;/span&gt; kB/s&lt;span class="o"&gt;)&lt;/span&gt;                                        
...
root@client1:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como estos paquetes no están en la &lt;em&gt;caché&lt;/em&gt; del servidor, se han descargado de internet en 15 segundos, de acuerdo a la velocidad de mi conexión de internet y de la velocidad de respuesta de los repositorios elegidos.&lt;/p&gt;
&lt;p&gt;Si revisamos la página de estadísticas de &lt;strong&gt;apt-cacher-ng&lt;/strong&gt;, disponible en &lt;em&gt;http://aptcacher:3142/acng-report.html&lt;/em&gt; podemos ver que se han descargado 4,78mb en 13 paquetes; todos son &lt;strong&gt;miss&lt;/strong&gt; de la cache, es decir, se han ido a buscar al repositorio oficial.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Estadísticas web de apt-cacher" src="http://www.linuxsysadmin.tk/images/apt-cacher-ng-1.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Ahora vamos a instalar &lt;em&gt;python&lt;/em&gt; en otro de los clientes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@client2:~# apt-get install python
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias... Hecho
...
Se instalarán los siguientes paquetes NUEVOS:
  file libexpat1 libffi6 libmagic1 libpython-stdlib libpython2.7-minimal
  libpython2.7-stdlib libsqlite3-0 mime-support python python-minimal
  python2.7 python2.7-minimal
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;13&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar 5.010 kB de archivos.
Se utilizarán 21,3 MB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
Descargados 5.010 kB en 1s &lt;span class="o"&gt;(&lt;/span&gt;3.902 kB/s&lt;span class="o"&gt;)&lt;/span&gt;
root@client2:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hemos elegido el paquete &lt;em&gt;python&lt;/em&gt; para asegurar que ambas máquinas instalan lo mismo; como se puede ver, se ha descargado la misma cantidad de datos, pero en vez de los 15 segundos anteriores, ahora se ha tardado 1 segundo. Eso es porque los paquetes solicitados estaban en el &lt;em&gt;proxy&lt;/em&gt;, es decir, en el servidor &lt;strong&gt;aptcacher&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Podemos ver en la misma página de administración el resultado: ahora hay 13 &lt;strong&gt;hits&lt;/strong&gt; adicionales, ya que los paquetes solicitados estaban en local.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Estadísticas web de apt-cacher" src="http://www.linuxsysadmin.tk/images/apt-cacher-ng-2.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;De esta forma, si tenemos un elevado número de máquinas del mismo tipo, solo consumiremos el ancho de banda necesario para traerlos de internet &lt;strong&gt;una sola vez&lt;/strong&gt;.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="apt-cacher-ng"></category><category term="cache"></category></entry><entry><title>Construyendo un RAID 10 en linux</title><link href="http://www.linuxsysadmin.tk/2015/12/construyendo-un-raid-10-en-linux.html" rel="alternate"></link><updated>2015-12-17T23:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-12-17:2015/12/construyendo-un-raid-10-en-linux.html</id><summary type="html">&lt;p&gt;El otro día estaba habilitando un servidor de &lt;em&gt;mongodb&lt;/em&gt; para un entorno de producción. Como me interesaba mejorar el rendimiento de los accesos a disco y no disponía de discos SSD con una durabilidad aceptable, me propuse montar un &lt;em&gt;array de discos&lt;/em&gt; en configuración de &lt;strong&gt;RAID 10&lt;/strong&gt;, como se recomienda.&lt;/p&gt;
&lt;p&gt;Para este tutorial vamos a tener una máquina virtual (es una &lt;em&gt;Debian&lt;/em&gt;, pero vale cualquier otra distribución) con 5 discos, 1 de sistema y otros 4 para usar en la configuración &lt;strong&gt;RAID 10&lt;/strong&gt;, cada uno con 8gb, a efecto de demostración.&lt;/p&gt;
&lt;p&gt;En este caso, el sistema operativo estaba en &lt;em&gt;/dev/sda&lt;/em&gt; y sus particiones, mientras que los discos para los datos de &lt;em&gt;mongodb&lt;/em&gt; fueron &lt;em&gt;/dev/sdb&lt;/em&gt;, &lt;em&gt;/dev/sdc&lt;/em&gt;, &lt;em&gt;/dev/sdd&lt;/em&gt;, &lt;em&gt;/dev/sde&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# ls /dev/sd* -1
/dev/sda
/dev/sda1
/dev/sdb
/dev/sdc
/dev/sdd
/dev/sde
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creación del dispositivo RAID 10&lt;/h2&gt;
&lt;p&gt;Empezamos instalando el controlador de &lt;strong&gt;RAID&lt;/strong&gt; por software:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# apt-get install mdadm
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias       
Leyendo la información de estado... Hecho
..
Se instalarán los siguientes paquetes NUEVOS:
  bsd-mailx exim4-base exim4-config exim4-daemon-light liblockfile-bin
  liblockfile1 mdadm psmisc
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;8&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
...
update-initramfs: Generating /boot/initrd.img-3.16.0-4-586
W: mdadm: /etc/mdadm/mdadm.conf defines no arrays.
W: mdadm: no arrays defined in configuration file.
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Con las herramientas instaladas, procedemos a crear un &lt;em&gt;/dev/md0&lt;/em&gt; que será nuestro &lt;strong&gt;disco RAID&lt;/strong&gt;, indicando el nivel &lt;strong&gt;RAID 10&lt;/strong&gt; y los 4 discos reales que van a formarlo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mdadm -v --create /dev/md0 --level&lt;span class="o"&gt;=&lt;/span&gt;raid10 --raid-devices&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt; /dev/sdb /dev/sdc /dev/sdd /dev/sde
mdadm: layout defaults to n2
mdadm: layout defaults to n2
mdadm: chunk size defaults to 512K
mdadm: size &lt;span class="nb"&gt;set &lt;/span&gt;to 8380416K
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para que ese array de discos sea reconocido en cada inicio del sistema, hay que añadir en &lt;em&gt;/etc/mdadm/mdadm.conf&lt;/em&gt; la información relacionada al array, de la misma forma que la tengamos en este momento.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mdadm --detail --scan --verbose &amp;gt;&amp;gt; /etc/mdadm/mdadm.conf
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y ya tenemos nuestro dispositivo &lt;strong&gt;RAID 10&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Preparación del dispositivo&lt;/h2&gt;
&lt;p&gt;Ahora disponemos de un &lt;strong&gt;RAID 10&lt;/strong&gt; de 4 discos de 8gb, que corresponden a una capacidad total de 16gb utilizables, como el dispositivo &lt;em&gt;/dev/md0&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Este dispositivo es transparente para nosotros y no es diferente de cualquier otro dispositivo de bloques, con lo que se puede particionar, formatear e incluso actuar como un &lt;em&gt;physical volume&lt;/em&gt; en caso de usar &lt;strong&gt;LVM&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Para esta demostración, se creará una única partición que ocupe todo el disco y que será montada en &lt;em&gt;/data&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Así pues, sin mas preámbulo la particionamos; en mi caso lo hice con &lt;em&gt;cfdisk&lt;/em&gt;. Este es el resultado:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# fdisk -l /dev/md0

Disco /dev/md0: &lt;span class="m"&gt;16&lt;/span&gt; GiB, &lt;span class="m"&gt;17163091968&lt;/span&gt; bytes, &lt;span class="m"&gt;33521664&lt;/span&gt; sectores
Unidades: sectores de &lt;span class="m"&gt;1&lt;/span&gt; * &lt;span class="nv"&gt;512&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;512&lt;/span&gt; bytes
Tamaño de sector &lt;span class="o"&gt;(&lt;/span&gt;lógico/físico&lt;span class="o"&gt;)&lt;/span&gt;: &lt;span class="m"&gt;512&lt;/span&gt; bytes / &lt;span class="m"&gt;512&lt;/span&gt; bytes
Tamaño de E/S &lt;span class="o"&gt;(&lt;/span&gt;mínimo/óptimo&lt;span class="o"&gt;)&lt;/span&gt;: &lt;span class="m"&gt;524288&lt;/span&gt; bytes / &lt;span class="m"&gt;1048576&lt;/span&gt; bytes
Tipo de etiqueta de disco: gpt
Identificador del disco: E3FE7B0A-0F5D-4151-84E8-49670C33B65E

Device     Start      End  Sectors Size Type
/dev/md0p1  &lt;span class="m"&gt;2048&lt;/span&gt; &lt;span class="m"&gt;33521630&lt;/span&gt; &lt;span class="m"&gt;33519583&lt;/span&gt;  16G Linux filesystem

root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La primera (y única partición) se llama &lt;em&gt;/dev/md0p1&lt;/em&gt; y es el dispositivo que vamos a formatear, para posteriormente montarlo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkfs.ext4 /dev/md0p1 
mke2fs 1.42.12 &lt;span class="o"&gt;(&lt;/span&gt;29-Aug-2014&lt;span class="o"&gt;)&lt;/span&gt;
Se está creando El sistema de ficheros con &lt;span class="m"&gt;4189947&lt;/span&gt; 4k bloques y &lt;span class="m"&gt;1048576&lt;/span&gt; nodos-i

UUID del sistema de ficheros: 11e454ce-72c4-41f8-a7bc-4d4a78b873c0
Respaldo del superbloque guardado en los bloques: 
    32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 
    4096000

Reservando las tablas de grupo: hecho                           
Escribiendo las tablas de nodos-i: hecho                           
Creando el fichero de transacciones &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;32768&lt;/span&gt; bloques&lt;span class="o"&gt;)&lt;/span&gt;: hecho
Escribiendo superbloques y la información contable del sistema de ficheros:   hecho  

root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Creamos la carpeta que va a servir de &lt;em&gt;mountpoint&lt;/em&gt; para esta nueva partición:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkdir /data
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Añadimos la partición en el fichero &lt;em&gt;/etc/fstab&lt;/em&gt;, para que se monte automáticamente tras cada reinicio:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# grep md0p1 /etc/fstab 
/dev/md0p1 /data ext4 defaults &lt;span class="m"&gt;0&lt;/span&gt; 0
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente la montamos. Como esta información ya está en el fichero &lt;em&gt;/etc/fstab&lt;/em&gt; no es necesario especificar los detalles.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mount /data
root@server:~# df -h
S.ficheros     Tamaño Usados  Disp Uso% Montado en
/dev/sda1        2,0G   651M  1,2G  35% /
udev              10M      &lt;span class="m"&gt;0&lt;/span&gt;   10M   0% /dev
tmpfs             50M   4,4M   46M   9% /run
tmpfs            124M      &lt;span class="m"&gt;0&lt;/span&gt;  124M   0% /dev/shm
tmpfs            5,0M      &lt;span class="m"&gt;0&lt;/span&gt;  5,0M   0% /run/lock
tmpfs            124M      &lt;span class="m"&gt;0&lt;/span&gt;  124M   0% /sys/fs/cgroup
/dev/md0p1        16G    44M   15G   1% /data
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como detalle, al no tratarse de una partición raíz de sistema operativo, no hace falta reservar bloques de emergencia; se trata de un 5% de la capacidad que podemos liberar (5% de 16gb son 800mb que podemos usar).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# tune2fs -m &lt;span class="m"&gt;0&lt;/span&gt; /dev/md0p1 
tune2fs 1.42.12 &lt;span class="o"&gt;(&lt;/span&gt;29-Aug-2014&lt;span class="o"&gt;)&lt;/span&gt;
Se pone el porcentaje de bloques reservados a 0% &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; bloques&lt;span class="o"&gt;)&lt;/span&gt;
root@server:~# df -h
S.ficheros     Tamaño Usados  Disp Uso% Montado en
/dev/sda1        2,0G   651M  1,2G  35% /
udev              10M      &lt;span class="m"&gt;0&lt;/span&gt;   10M   0% /dev
tmpfs             50M   4,4M   46M   9% /run
tmpfs            124M      &lt;span class="m"&gt;0&lt;/span&gt;  124M   0% /dev/shm
tmpfs            5,0M      &lt;span class="m"&gt;0&lt;/span&gt;  5,0M   0% /run/lock
tmpfs            124M      &lt;span class="m"&gt;0&lt;/span&gt;  124M   0% /sys/fs/cgroup
/dev/md0p1        16G    44M   16G   1% /data
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Verificación&lt;/h2&gt;
&lt;p&gt;Podemos ver la información de estado del array de discos con el mismo comando &lt;em&gt;mdadm&lt;/em&gt;, como sigue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mdadm --detail /dev/md0
/dev/md0:
        Version : 1.2
  Creation Time : Sat Dec &lt;span class="m"&gt;12&lt;/span&gt; 21:19:42 2015
     Raid Level : raid10
     Array Size : &lt;span class="m"&gt;16760832&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;15.98 GiB 17.16 GB&lt;span class="o"&gt;)&lt;/span&gt;
  Used Dev Size : &lt;span class="m"&gt;8380416&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;7.99 GiB 8.58 GB&lt;span class="o"&gt;)&lt;/span&gt;
   Raid Devices : 4
  Total Devices : 4
    Persistence : Superblock is persistent

    Update Time : Sat Dec &lt;span class="m"&gt;12&lt;/span&gt; 21:30:11 2015
          State : clean 
 Active Devices : 4
Working Devices : 4
 Failed Devices : 0
  Spare Devices : 0

         Layout : &lt;span class="nv"&gt;near&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2
     Chunk Size : 512K

           Name : server:0  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local &lt;/span&gt;to host server&lt;span class="o"&gt;)&lt;/span&gt;
           UUID : 217558a7:bc1cb1d4:9530ecda:ea477a6b
         Events : 19

    Number   Major   Minor   RaidDevice State
       &lt;span class="m"&gt;0&lt;/span&gt;       &lt;span class="m"&gt;8&lt;/span&gt;       &lt;span class="m"&gt;16&lt;/span&gt;        &lt;span class="m"&gt;0&lt;/span&gt;      active sync &lt;span class="nb"&gt;set&lt;/span&gt;-A   /dev/sdb
       &lt;span class="m"&gt;1&lt;/span&gt;       &lt;span class="m"&gt;8&lt;/span&gt;       &lt;span class="m"&gt;32&lt;/span&gt;        &lt;span class="m"&gt;1&lt;/span&gt;      active sync &lt;span class="nb"&gt;set&lt;/span&gt;-B   /dev/sdc
       &lt;span class="m"&gt;2&lt;/span&gt;       &lt;span class="m"&gt;8&lt;/span&gt;       &lt;span class="m"&gt;48&lt;/span&gt;        &lt;span class="m"&gt;2&lt;/span&gt;      active sync &lt;span class="nb"&gt;set&lt;/span&gt;-A   /dev/sdd
       &lt;span class="m"&gt;3&lt;/span&gt;       &lt;span class="m"&gt;8&lt;/span&gt;       &lt;span class="m"&gt;64&lt;/span&gt;        &lt;span class="m"&gt;3&lt;/span&gt;      active sync &lt;span class="nb"&gt;set&lt;/span&gt;-B   /dev/sde
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RESUMEN&lt;/strong&gt;: Ahora tengo un disco doble de rápido, doble de capacidad y con doble copia de datos. Afortunadamente, los discos duros son baratos...&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="raid"></category></entry><entry><title>Construyendo una replica set en mongodb</title><link href="http://www.linuxsysadmin.tk/2015/12/construyendo-una-replica-set-en-mongodb.html" rel="alternate"></link><updated>2015-12-08T12:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-12-08:2015/12/construyendo-una-replica-set-en-mongodb.html</id><summary type="html">&lt;p&gt;Muchas veces nos interesa obtener alta disponibilidad en los servicios que gestionamos. No hay nada mas desagradable que una llamada a las tantas de la noche porque se ha caído un nodo de una base de datos y no damos servicio. Para eso &lt;em&gt;mongodb&lt;/em&gt; nos ofrece el mecanismo de replicación.&lt;/p&gt;
&lt;p&gt;En este artículo vamos a montar una &lt;em&gt;replica set&lt;/em&gt;, de forma que si se cayera un nodo de la base de datos, otro asumiría su rol, de forma que se seguiría dando servicio.&lt;/p&gt;
&lt;p&gt;Nuestra &lt;em&gt;replica set&lt;/em&gt; va a tener 3 nodos, que vamos a alojar en 3 máquinas distintas, de forma que la caída de una máquina afecte solamente a 1 proceso de &lt;em&gt;mongodb&lt;/em&gt;. La caonfiguración de 3 nodos nos da una tolerancia a fallos de 1 máquina; mientras queden 2, el clúster va a seguir operativo.&lt;/p&gt;
&lt;h2&gt;Descripción del entorno&lt;/h2&gt;
&lt;p&gt;Disponemos de 3 máquinas que vamos a llamar &lt;strong&gt;mongo1&lt;/strong&gt;, &lt;strong&gt;mongo2&lt;/strong&gt; y &lt;strong&gt;mongo3&lt;/strong&gt;. Cada una funciona con un sistema operativo &lt;em&gt;Debian jessie&lt;/em&gt; con &lt;em&gt;systemd&lt;/em&gt; y cuenta 1 gb de disco y con 256 mb de memoria; para esta demostración no se necesita mas.&lt;/p&gt;
&lt;p&gt;Como pequeño detalle, las máquinas se van referir entre ellas por nombre, pero como no me interesa poner una solución completa de &lt;em&gt;DNS&lt;/em&gt;, he puesto en el fichero &lt;em&gt;/etc/hosts&lt;/em&gt; de todas las máquinas las equivalencias.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# grep mongo /etc/hosts
10.0.0.2    mongo1
10.0.0.3    mongo2
10.0.0.4    mongo3
root@mongo1:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Consideraciones de seguridad&lt;/h2&gt;
&lt;p&gt;Estas máquinas se comunican entre sí por el puerto TCP en el que corran sus procesos; para seguir con el puerto "titular" vamos a ponerlos en el puerto 27017. Es importante que las 3 máquinas puedan acceder al puerto de las otras 2. Adicionalmente, la máquina que vaya a usar este clúster también debe pode acceder al puerto 27017 de las 3 máquinas.&lt;/p&gt;
&lt;h2&gt;Preparación de las máquinas individuales&lt;/h2&gt;
&lt;p&gt;Queremos una versión de &lt;em&gt;mongodb&lt;/em&gt; un poco reciente, así que no vamos a usar los paquetes oficiales de la distribución, y la empresa de &lt;em&gt;mongodb&lt;/em&gt; no ofrece paquete para &lt;em&gt;Debian jessie&lt;/em&gt;. Por ello vamos a montar un esqueleto de ficheros como se describe en &lt;a href="http://www.linuxsysadmin.tk/2015/11/escribiendo-units-en-systemd.html"&gt;un artículo anterior&lt;/a&gt;. Vamos a describir el proceso en la máquina &lt;strong&gt;mongo1&lt;/strong&gt;, para replicarlo a posteriori en las otras 2.&lt;/p&gt;
&lt;p&gt;Creamos la estructura de carpetas que van a contener todo lo relativo a &lt;strong&gt;mongodb&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# mkdir -p /opt/mongodb/&lt;span class="o"&gt;{&lt;/span&gt;bin,conf,data/replica,logs&lt;span class="o"&gt;}&lt;/span&gt;
root@mongo1:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Copiamos el binario &lt;strong&gt;mongod&lt;/strong&gt; que encontraremos en el fichero &lt;em&gt;.tar.gz&lt;/em&gt; de la página de descargas de la página web.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# cp mongod /opt/mongodb/bin/
root@mongo1:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Creamos un fichero de configuración con el que vamos a levantar el proceso en esta máquina.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# cat /opt/mongodb/conf/replica.conf
systemLog:
    path: /opt/mongodb/logs/replica.log
    logAppend: &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="nb"&gt;    &lt;/span&gt;destination: file

net:
    port: 27017
    bindIp: 0.0.0.0

storage:
    dbPath: /opt/mongodb/data/replica
    smallFiles: &lt;span class="nb"&gt;true&lt;/span&gt;

replication:
    replSetName: replica
root@mongo1:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Por razones de seguridad vamos a lanzar el servicio con un usuario propio de sistema.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# useradd -s /usr/sbin/nologin -r -M mongo -d /opt/mongodb/
root@mongo1:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y para ahorrarnos problemas de permisos, lo hacemos propietario de todo lo referente al servicio:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# chown -R mongo:mongo /opt/mongodb/
root@mongo1:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a crearle una &lt;strong&gt;unit&lt;/strong&gt; para que el sistema se encargue de levantar automáticamente el servicio en caso de reinicio de la máquina:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# cat /etc/systemd/system/mongo.service
&lt;span class="o"&gt;[&lt;/span&gt;Unit&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;MongoDB

&lt;span class="o"&gt;[&lt;/span&gt;Service&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;mongo
&lt;span class="nv"&gt;LimitFSIZE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitCPU&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitNOFILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;LimitNPROC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;ExecStartPre&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/bin/rm -f /opt/mongodb/data/replica/mongod.lock
&lt;span class="nv"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/opt/mongodb/bin/mongod -f /opt/mongodb/conf/replica.conf

&lt;span class="o"&gt;[&lt;/span&gt;Install&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;multi-user.target
root@mongo1:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente activamos la &lt;strong&gt;unit&lt;/strong&gt; e iniciamos el servicio.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@mongo1:~# systemctl &lt;span class="nb"&gt;enable &lt;/span&gt;mongo
Created symlink from /etc/systemd/system/multi-user.target.wants/mongo.service to /etc/systemd/system/mongo.service.
root@mongo1:~# systemctl start mongo
root@mongo1:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora toca repetir el proceso en las otras 2 máquinas, exactamente igual.&lt;/p&gt;
&lt;h2&gt;Configuración del clúster&lt;/h2&gt;
&lt;p&gt;Accedemos a una de las máquinas del futuro clúster desde cualquier máquina que pueda hacerlo y que disponga del binario &lt;strong&gt;mongo&lt;/strong&gt; (el mongo shell), que también viene en el archivo &lt;em&gt;.tar.gz&lt;/em&gt; descargado de la página oficial; este shell no es necesario para la aplicación que use el clúster ya que el &lt;strong&gt;driver&lt;/strong&gt; de cada lenguaje suple sus funciones, pero es muy útil tenerlo a mano para tareas de administración y consultas varias.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@client:~# ./mongo --host 10.0.0.2
MongoDB shell version: 3.0.7
connecting to: 10.0.0.2:27017/test
Welcome to the MongoDB shell.
For interactive &lt;span class="nb"&gt;help&lt;/span&gt;, &lt;span class="nb"&gt;type&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;help&amp;quot;&lt;/span&gt;.
&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hay dos formas de crear la configuración del clúster: pasando el documento de configuración en el método &lt;em&gt;initiate&lt;/em&gt; o añadir los nodos a posteriori con el método &lt;em&gt;add&lt;/em&gt;. Voy a usar este método por ser mas fácil.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt; rs.initiate&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;info2&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;no configuration explicitly specified -- making one&amp;quot;&lt;/span&gt;,
    &lt;span class="s2"&gt;&amp;quot;me&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;mongo1:27017&amp;quot;&lt;/span&gt;,
    &lt;span class="s2"&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; : 1
&lt;span class="o"&gt;}&lt;/span&gt;
replica:PRIMARY&amp;gt; rs.add&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mongo2:27017&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; : &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
replica:PRIMARY&amp;gt; rs.add&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mongo3:27017&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; : &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
replica:PRIMARY&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a lanzar el método &lt;em&gt;status&lt;/em&gt; hasta que todos los nodos sean primarios o secundarios, momento en el que la &lt;em&gt;replica&lt;/em&gt; va a quedar correctamente montada.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;replica:PRIMARY&amp;gt; rs.status&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;set&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;replica&amp;quot;&lt;/span&gt;,
...
    &lt;span class="s2"&gt;&amp;quot;members&amp;quot;&lt;/span&gt; : &lt;span class="o"&gt;[&lt;/span&gt;
        &lt;span class="o"&gt;{&lt;/span&gt;
...
            &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;mongo1:27017&amp;quot;&lt;/span&gt;,
            &lt;span class="s2"&gt;&amp;quot;stateStr&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;PRIMARY&amp;quot;&lt;/span&gt;,
            &lt;span class="s2"&gt;&amp;quot;self&amp;quot;&lt;/span&gt; : &lt;span class="nb"&gt;true&lt;/span&gt;
...
        &lt;span class="o"&gt;}&lt;/span&gt;,
        &lt;span class="o"&gt;{&lt;/span&gt;
...
            &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;mongo2:27017&amp;quot;&lt;/span&gt;,
            &lt;span class="s2"&gt;&amp;quot;stateStr&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;SECONDARY&amp;quot;&lt;/span&gt;,
            &lt;span class="s2"&gt;&amp;quot;syncingTo&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;mongo1:27017&amp;quot;&lt;/span&gt;,
...
        &lt;span class="o"&gt;}&lt;/span&gt;,
        &lt;span class="o"&gt;{&lt;/span&gt;
...
            &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;mongo3:27017&amp;quot;&lt;/span&gt;,
            &lt;span class="s2"&gt;&amp;quot;stateStr&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;SECONDARY&amp;quot;&lt;/span&gt;,
            &lt;span class="s2"&gt;&amp;quot;syncingTo&amp;quot;&lt;/span&gt; : &lt;span class="s2"&gt;&amp;quot;mongo1:27017&amp;quot;&lt;/span&gt;,
...
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;]&lt;/span&gt;,
    &lt;span class="s2"&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; : 1
&lt;span class="o"&gt;}&lt;/span&gt;
replica:PRIMARY&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esta salida del método &lt;em&gt;status&lt;/em&gt; ya lo tenemos todo funcionando correctamente.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="mongodb"></category><category term="replica set"></category><category term="systemd"></category></entry><entry><title>Creación de un livecd con Debian</title><link href="http://www.linuxsysadmin.tk/2015/12/creacion-de-un-livecd-con-debian.html" rel="alternate"></link><updated>2015-12-02T12:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-12-02:2015/12/creacion-de-un-livecd-con-debian.html</id><summary type="html">&lt;p&gt;Tras ver como las actualizaciones de mis máquinas virtuales &lt;em&gt;VirtualBox&lt;/em&gt; expandían mis discos &lt;em&gt;.vdi&lt;/em&gt; sin control, quise pasar la herramienta &lt;em&gt;zerofree&lt;/em&gt; y un compactado con la herramienta oficial &lt;em&gt;VBoxManage&lt;/em&gt;. No quería instalar &lt;em&gt;zerofree&lt;/em&gt; de forma permanente y no pude encontrar un &lt;em&gt;livecd&lt;/em&gt; que lo tuviera, así que decidí crear uno.&lt;/p&gt;
&lt;p&gt;Para conseguirlo, se va a usar un sistema de ficheros creado con &lt;em&gt;debootstrap&lt;/em&gt; y compactado mediante &lt;em&gt;SquashFS&lt;/em&gt;; este sistema de ficheros se va a empaquetar en un &lt;em&gt;.iso&lt;/em&gt; junto con un &lt;em&gt;kernel&lt;/em&gt;, un &lt;em&gt;initrd&lt;/em&gt; y el bootloader &lt;em&gt;isolinux&lt;/em&gt;. La herramienta que hace eso es &lt;em&gt;genisoimage&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Este tutorial se ejecutó en una distribución &lt;em&gt;Debian&lt;/em&gt;, pero no hay ningún problema en hacerlo en una &lt;em&gt;Ubuntu&lt;/em&gt; u otra distribución, siempre que sepamos como crear la imagen base para empaquetar.&lt;/p&gt;
&lt;h2&gt;Preparación del entorno&lt;/h2&gt;
&lt;p&gt;Todo el proceso va a ser ejecutado con el usuario &lt;em&gt;root&lt;/em&gt; por comodidad.&lt;/p&gt;
&lt;p&gt;Empezaremos por instalar todas las tecnologías que hemos mencionado:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~# apt-get install debootstrap isolinux squashfs-tools genisoimage
...
root@desktop:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Creamos una carpeta de trabajo para contener todos los ficheros temporales y el producto final, por limpieza:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~# mkdir live_boot
root@desktop:~# &lt;span class="nb"&gt;cd &lt;/span&gt;live_boot
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Todos los comandos que se detallan a continuación se hacen desde dentro de esta carpeta.&lt;/p&gt;
&lt;h2&gt;Preparación del sistema de ficheros, el kernel y el initrd&lt;/h2&gt;
&lt;p&gt;El sistema de ficheros se hace a partir de una jaula estándar de una distribución normal. En este paso, las distribuciones que usan &lt;em&gt;debootstrap&lt;/em&gt; nos facilitan mucho las cosas (aunque esta es la operación mas larga de este tutorial):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# debootstrap --variant&lt;span class="o"&gt;=&lt;/span&gt;minbase jessie chroot
I: Retrieving Release 
I: Retrieving Release.gpg 
I: Checking Release signature
I: Valid Release signature &lt;span class="o"&gt;(&lt;/span&gt;key id 75DDC3C4A499F1A18CB5F3C8CBF8D6FD518E17E1&lt;span class="o"&gt;)&lt;/span&gt;
I: Retrieving Packages 
I: Validating Packages 
I: Resolving dependencies of required packages...
I: Resolving dependencies of base packages...
...
I: Base system installed successfully.
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora se trata de preparar esta jaula con los paquetes que necesitemos y las configuraciones adecuadas. Vamos a montar los pseudo sistemas de ficheros &lt;em&gt;/proc&lt;/em&gt;, &lt;em&gt;/sys&lt;/em&gt;, &lt;em&gt;/dev&lt;/em&gt; y &lt;em&gt;/dev/pts&lt;/em&gt;, que posiblemente nos van a hacer falta cuando estemos dentro de la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# mount -o &lt;span class="nb"&gt;bind&lt;/span&gt; /proc/ chroot/proc/
root@desktop:~/live_boot# mount -o &lt;span class="nb"&gt;bind&lt;/span&gt; /sys/ chroot/sys/
root@desktop:~/live_boot# mount -o &lt;span class="nb"&gt;bind&lt;/span&gt; /dev/ chroot/dev/
root@desktop:~/live_boot# mount -o &lt;span class="nb"&gt;bind&lt;/span&gt; /dev/pts/ chroot/dev/pts/
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Entramos en la jaula:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# chroot chroot
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;CUIDADO&lt;/strong&gt;: A partir de ahora, y hasta nuevo aviso, todos los comandos se hacen &lt;strong&gt;dentro&lt;/strong&gt; de la jaula.&lt;/p&gt;
&lt;p&gt;Antes de nada, vamos a asignar una password al usuario &lt;em&gt;root&lt;/em&gt;, porque sino, no vamos a poder entrar en el &lt;em&gt;livecd&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# passwd    
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Asignamos el nombre de máquina que mostrará el &lt;em&gt;livecd&lt;/em&gt; una vez haya hecho el &lt;em&gt;boot&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;zerofree&amp;quot;&lt;/span&gt; &amp;gt; /etc/hostname
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para que el &lt;em&gt;livecd&lt;/em&gt; pueda hacer &lt;em&gt;boot&lt;/em&gt;, vamos a necesitar el paquete &lt;strong&gt;live-boot&lt;/strong&gt; y un &lt;em&gt;kernel&lt;/em&gt; adecuado a la máquina que va a usar el &lt;em&gt;livecd&lt;/em&gt;. El paquete del &lt;em&gt;kernel&lt;/em&gt; ya nos va a dotar de un &lt;em&gt;initrd&lt;/em&gt; que también vamos a necesitar para el &lt;em&gt;livecd&lt;/em&gt;. Este paso también tarda un poco.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# apt-get install linux-image-486 live-boot
Reading package lists... Done
Building dependency tree... Done
...
Setting up linux-image-3.16.0-4-586 &lt;span class="o"&gt;(&lt;/span&gt;3.16.7-ckt11-1+deb8u3&lt;span class="o"&gt;)&lt;/span&gt; ...
...  
/etc/kernel/postinst.d/initramfs-tools:
update-initramfs: Generating /boot/initrd.img-3.16.0-4-586
...
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora vamos a instalar los paquetes que queramos en el &lt;em&gt;livecd&lt;/em&gt;; yo voy a poner &lt;em&gt;zerofree&lt;/em&gt; que es la herramienta que motivó este &lt;em&gt;livecd&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# apt-get install zerofree
...
Unpacking zerofree &lt;span class="o"&gt;(&lt;/span&gt;1.0.3-1&lt;span class="o"&gt;)&lt;/span&gt; ...
Setting up zerofree &lt;span class="o"&gt;(&lt;/span&gt;1.0.3-1&lt;span class="o"&gt;)&lt;/span&gt; ...
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;OPCIONAL&lt;/strong&gt;: Para reducir el tamaño final, voy a limpiar todos los archivos temporales que usa &lt;em&gt;apt&lt;/em&gt;, tanto los archivos &lt;em&gt;.deb&lt;/em&gt; en &lt;em&gt;/var/cache/apt&lt;/em&gt;, como las listas de paquetes disponibles en &lt;em&gt;/var/lib/apt&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# cat /dev/null &amp;gt; /etc/apt/sources.list
root@desktop:/# apt-get update
Reading package lists... Done
root@desktop:/# apt-get clean 
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y finalmente salimos de la jaula:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# &lt;span class="nb"&gt;exit&lt;/span&gt;
&lt;span class="nb"&gt;exit&lt;/span&gt;
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;CUIDADO&lt;/strong&gt;: A partir de ahora, todos los comandos se hacen &lt;strong&gt;fuera&lt;/strong&gt; de la jaula.&lt;/p&gt;
&lt;p&gt;Vamos a desmontar los pseudo sistemas de ficheros que ya no son necesarios, y que van a molestar cuando compactemos la jaula. Como apunte, la jaula había levantado un proceso &lt;em&gt;/usr/sbin/uuidd&lt;/em&gt; que evitaba desmontar &lt;em&gt;chroot/dev&lt;/em&gt;, por lo que tuve que finalizar el proceso con un &lt;em&gt;kill&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# umount chroot/dev/pts/
root@desktop:~/live_boot# umount chroot/dev/
root@desktop:~/live_boot# umount chroot/sys/
root@desktop:~/live_boot# umount chroot/proc/
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;OPCIONAL&lt;/strong&gt;: Sabiendo que mis máquinas virtuales son clones y el comando que va a correr siempre el comando &lt;em&gt;zerofree&lt;/em&gt; contra el disco &lt;em&gt;/dev/sda1&lt;/em&gt;, se puede poner los comandos en el &lt;em&gt;.bash_history&lt;/em&gt; de &lt;em&gt;root&lt;/em&gt; para poderlos recuperar mediante el uso de flechas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# cat chroot/root/.bash_history 
zerofree /dev/sda1
poweroff
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Empaquetando la imagen&lt;/h2&gt;
&lt;p&gt;Vamos a crear una carpeta contenedora, que va a servir como raíz del &lt;em&gt;livecd&lt;/em&gt;. Dentro le vamos a poner una carpeta &lt;em&gt;live&lt;/em&gt; (para el sistema de ficheros, el &lt;em&gt;kernel&lt;/em&gt; y el &lt;em&gt;initrd&lt;/em&gt;) y una carpeta &lt;em&gt;isolinux&lt;/em&gt; (para todo lo referente al &lt;em&gt;bootloader&lt;/em&gt;).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# mkdir -p image/&lt;span class="o"&gt;{&lt;/span&gt;live,isolinux&lt;span class="o"&gt;}&lt;/span&gt;
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a poner el sistema de ficheros en formato &lt;em&gt;SquashFS&lt;/em&gt;. Como apunte, el &lt;em&gt;kernel&lt;/em&gt; y el &lt;em&gt;initrd&lt;/em&gt; (ambos en la carpeta &lt;em&gt;/boot&lt;/em&gt;) se excluyen porque el &lt;em&gt;bootloader&lt;/em&gt; es incapaz de leerlos de allí; así que los copiamos a la misma carpeta.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# mksquashfs chroot image/live/filesystem.squashfs -e boot
Parallel mksquashfs: Using &lt;span class="m"&gt;1&lt;/span&gt; processor
Creating 4.0 filesystem on image/live/filesystem.squashfs, block size 131072.
...  
root@desktop:~/live_boot# cp chroot/boot/vmlinuz-3.16.0-4-586 image/live/vmlinuz
root@desktop:~/live_boot# cp chroot/boot/initrd.img-3.16.0-4-586 image/live/initrd
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora vamos con el &lt;em&gt;bootloader&lt;/em&gt;. Lo primero es poner una configuración para saber qué menú nos va a mostrar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# cat image/isolinux/isolinux.cfg 
UI menu.c32

prompt 0
menu title Debian Zerofree

timeout 50

label Debian Live 3.16.0-4-586
menu label ^Debian Live 3.16.0-4-586
menu default
kernel /live/vmlinuz
append &lt;span class="nv"&gt;initrd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/live/initrd &lt;span class="nv"&gt;boot&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;live
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Copiamos la imagen del &lt;em&gt;bootloader&lt;/em&gt; &lt;strong&gt;isolinux&lt;/strong&gt; y los módulos que se necesitan, tanto porque nuestra configuración los usa o porque se usan desde otros módulos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# cp /usr/lib/ISOLINUX/isolinux.bin image/isolinux/
root@desktop:~/live_boot# cp /usr/lib/syslinux/modules/bios/ldlinux.c32 image/isolinux/
root@desktop:~/live_boot# cp /usr/lib/syslinux/modules/bios/menu.c32 image/isolinux/
root@desktop:~/live_boot# cp /usr/lib/syslinux/modules/bios/libutil.c32 image/isolinux/
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente empaquetamos la imagen &lt;em&gt;.iso&lt;/em&gt;. Para ello usaremos la herramienta &lt;em&gt;genisoimage&lt;/em&gt; en la carpeta raíz de lo que sería el &lt;em&gt;livecd&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# &lt;span class="nb"&gt;cd &lt;/span&gt;image/
root@desktop:~/live_boot/image# genisoimage -rational-rock -volid &lt;span class="s2"&gt;&amp;quot;Debian Zerofree&amp;quot;&lt;/span&gt; -cache-inodes -joliet -full-iso9660-filenames -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size &lt;span class="m"&gt;4&lt;/span&gt; -boot-info-table -output ../debian-zerofree.iso .
I: -input-charset not specified, using utf-8 &lt;span class="o"&gt;(&lt;/span&gt;detected in locale settings&lt;span class="o"&gt;)&lt;/span&gt;
Size of boot image is &lt;span class="m"&gt;4&lt;/span&gt; sectors -&amp;gt; No emulation
  9.24% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:43 2015
 18.48% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:38 2015
 27.69% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:36 2015
 36.94% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:38 2015
 46.15% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:37 2015
 55.40% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:36 2015
 64.61% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:37 2015
 73.85% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:37 2015
 83.07% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:37 2015
 92.30% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:38 2015
Total translation table size: 2048
Total rockridge attributes bytes: 1335
Total directory bytes: 4570
Path table size&lt;span class="o"&gt;(&lt;/span&gt;bytes&lt;span class="o"&gt;)&lt;/span&gt;: 38
Max brk space used 1a000
&lt;span class="m"&gt;54178&lt;/span&gt; extents written &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;105&lt;/span&gt; MB&lt;span class="o"&gt;)&lt;/span&gt;
root@desktop:~/live_boot/image# &lt;span class="nb"&gt;cd&lt;/span&gt; ..
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y nuestra imagen &lt;em&gt;.iso&lt;/em&gt; queda en la carpeta de trabajo, junto a la jaula y a la estructura del &lt;em&gt;livecd&lt;/em&gt;. Solo necesitamos la imagen &lt;em&gt;.iso&lt;/em&gt;, pero podemos dejar los ficheros intermedios hasta que estemos satisfechos con la imagen; es mas fácil modificar la jaula, el empaquetado &lt;em&gt;filesystem.squashfs&lt;/em&gt; y la imagen &lt;em&gt;.iso&lt;/em&gt; que volver a hacer un &lt;em&gt;debootstrap&lt;/em&gt; entero...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# ls -lh
total 106M
drwxr-xr-x &lt;span class="m"&gt;20&lt;/span&gt; root root 4,0K dic  &lt;span class="m"&gt;2&lt;/span&gt; 11:30 chroot
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; root root 106M dic  &lt;span class="m"&gt;2&lt;/span&gt; 12:06 debian-zerofree.iso
drwxr-xr-x  &lt;span class="m"&gt;4&lt;/span&gt; root root 4,0K dic  &lt;span class="m"&gt;2&lt;/span&gt; 11:53 image
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusión&lt;/h2&gt;
&lt;p&gt;Copiando esta imagen &lt;em&gt;.iso&lt;/em&gt; a mi máquina con &lt;em&gt;VirtualBox&lt;/em&gt; y montándola antes de hacer el &lt;em&gt;boot&lt;/em&gt; de cada máquina, puedo usar la herramienta &lt;em&gt;zerofree&lt;/em&gt; libremente, sin instalarla en las máquinas virtuales. Tras ello, el compactado de los ficheros &lt;em&gt;.vdi&lt;/em&gt; libera los megabytes a cientos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@virtualbox:~/VirtualBox VMs&lt;span class="nv"&gt;$ &lt;/span&gt;VBoxManage modifyvdi Debian/Debian.vdi --compact
...
gerard@virtualbox:~/VirtualBox VMs&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En este caso concreto, la máquina &lt;strong&gt;Debian&lt;/strong&gt; (&lt;em&gt;netinstall&lt;/em&gt;) volvió a ocupar 700 mb, que es mucho mas interesante teniendo en cuenta que es la imagen que suelo clonar para hacer otras máquinas virtuales.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="zerofree"></category><category term="debootstrap"></category><category term="squashfs"></category><category term="genisoimage"></category><category term="isolinux"></category><category term="iso"></category><category term="livecd"></category></entry><entry><title>Virtualizando contenedores LXC tras bridge interno</title><link href="http://www.linuxsysadmin.tk/2015/11/virtualizando-contenedores-lxc-tras-bridge-interno.html" rel="alternate"></link><updated>2015-11-23T23:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-11-23:2015/11/virtualizando-contenedores-lxc-tras-bridge-interno.html</id><summary type="html">&lt;p&gt;En un artículo anterior propusimos virtualizar contenedores en la red de la máquina &lt;em&gt;host&lt;/em&gt;. Sin embargo, puede ser mas interesante esconder los contenedores detrás de una máquina que haga las funciones de &lt;em&gt;host&lt;/em&gt; y de &lt;em&gt;firewall&lt;/em&gt;. Expondremos una serie de puertos tras la misma dirección &lt;em&gt;IP&lt;/em&gt; mediante el protocolo &lt;em&gt;NAT&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Para conseguir este objetivo, se van a usar las siguientes tecnologías:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Debian jessie&lt;/strong&gt;: Es necesario usar alguna distribución de linux para hacer funcionar LXC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LXC&lt;/strong&gt;: Tecnología que permite aislar los contenedores entre sí y darles entidad propia&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bridges&lt;/strong&gt;: Un bridge es en software el equivalente a un switch hardware&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Firehol&lt;/strong&gt;: Una serie de scripts para construir firewalls basados en iptables de forma fácil&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En cuanto a las capacidades hardware, vamos a hacer el tutorial con un equipo de capacidades modestas, virtualizado en una máquina virtual VirtualBox.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPUs&lt;/strong&gt;: 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria&lt;/strong&gt;: 256 Mb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Disco&lt;/strong&gt;: 2 Gb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Red&lt;/strong&gt;: 1 interfaz (&lt;em&gt;eth0&lt;/em&gt;) &lt;em&gt;host-only&lt;/em&gt; o &lt;em&gt;bridged&lt;/em&gt; con IP fija&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Partimos de una distribución &lt;em&gt;Debian jessie&lt;/em&gt; instalada con un CD &lt;em&gt;netinstall&lt;/em&gt; y con el único paquete instalado &lt;em&gt;openssh-server&lt;/em&gt;, para mi comodidad.&lt;/p&gt;
&lt;h2&gt;Preparar el servidor&lt;/h2&gt;
&lt;p&gt;El primer paso consiste en instalar las tecnologías usadas:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# apt-get install bridge-utils firehol lxc
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias       
Leyendo la información de estado... Hecho
...
Configurando lxc &lt;span class="o"&gt;(&lt;/span&gt;1:1.0.6-6+deb8u2&lt;span class="o"&gt;)&lt;/span&gt; ...
Configurando dh-python &lt;span class="o"&gt;(&lt;/span&gt;1.20141111-2&lt;span class="o"&gt;)&lt;/span&gt; ...
Procesando disparadores para libc-bin &lt;span class="o"&gt;(&lt;/span&gt;2.19-18+deb8u1&lt;span class="o"&gt;)&lt;/span&gt; ...
Procesando disparadores para systemd &lt;span class="o"&gt;(&lt;/span&gt;215-17+deb8u2&lt;span class="o"&gt;)&lt;/span&gt; ...
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora vamos a modificar la configuración de red, para habilitar el &lt;em&gt;bridge&lt;/em&gt; en el que vamos a conectar el resto de contenedores virtualizados. Como dato importante, se define una interfaz falsa en la directiva &lt;em&gt;bridge_ports&lt;/em&gt; para que la &lt;em&gt;unit&lt;/em&gt; de red lo levante automáticamente.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ANTES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/network/interfaces
&lt;span class="nb"&gt;source&lt;/span&gt; /etc/network/interfaces.d/*

auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
    address 192.168.56.4
    netmask 255.255.255.0
    gateway 192.168.56.1
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;DESPUES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/network/interfaces
&lt;span class="nb"&gt;source&lt;/span&gt; /etc/network/interfaces.d/*

auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
    address 192.168.56.4
    netmask 255.255.255.0
    gateway 192.168.56.1

auto lxc0
iface lxc0 inet static
    bridge_ports dummy
    address 10.0.0.1
    netmask 255.255.255.0
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora toca reiniciar el servicio de red, para que el nuevo &lt;em&gt;bridge&lt;/em&gt; quede configurado como debe estarlo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# service networking restart
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El siguiente paso consiste en poner las reglas de &lt;em&gt;firewall&lt;/em&gt; necesarias para proteger al equipo anfitrión y para permitirle actuar como &lt;em&gt;gateway&lt;/em&gt; para los contenedores tras el &lt;em&gt;bridge&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/firehol/firehol.conf 
interface eth0 world
    policy drop
    protection strong
    server ssh accept
    client all accept

interface lxc0 lan
    policy drop
    client all accept

router lan2world inface lxc0 outface eth0
    masquerade
    route all accept
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hay que modificar otro fichero para permitir el inicio del &lt;em&gt;firewall&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ANTES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# grep START /etc/default/firehol 
&lt;span class="c"&gt;#To enable firehol at startup set START_FIREHOL=YES&lt;/span&gt;
&lt;span class="nv"&gt;START_FIREHOL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;NO
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;DESPUES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# grep START /etc/default/firehol 
&lt;span class="c"&gt;#To enable firehol at startup set START_FIREHOL=YES&lt;/span&gt;
&lt;span class="nv"&gt;START_FIREHOL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;YES
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y para acabar, reiniciamos el servicio &lt;em&gt;firehol&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# service firehol restart
...
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creación de contenedores&lt;/h2&gt;
&lt;p&gt;La creación de contenedores pasa por usar las herramientas estándar de la distribución, a lo solo tendremos que modificar algunas configuraciones propias de nuestra red.&lt;/p&gt;
&lt;p&gt;Creamos un contenedor &lt;em&gt;webserver&lt;/em&gt; como demostración. La primera que se crea es un poco lenta porque hace un &lt;em&gt;debootstrap&lt;/em&gt; de una distribución &lt;em&gt;Debian estable&lt;/em&gt; para crear una cache en &lt;em&gt;/var/cache/lxc&lt;/em&gt;; las siguientes se benefician de esta caché y solo la actualizan, acelerando el proceso.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# lxc-create -n webserver -t debian
debootstrap is /usr/sbin/debootstrap
Checking cache download in /var/cache/lxc/debian/rootfs-jessie-i386 ... 
Downloading debian minimal ...
...

I: Base system installed successfully.
Download complete.
Copying rootfs to /var/lib/lxc/webserver/rootfs...
...
Current default &lt;span class="nb"&gt;time &lt;/span&gt;zone: &lt;span class="s1"&gt;&amp;#39;Europe/Madrid&amp;#39;&lt;/span&gt;
Local &lt;span class="nb"&gt;time &lt;/span&gt;is now:      Mon Nov &lt;span class="m"&gt;23&lt;/span&gt; 16:29:36 CET 2015.
Universal Time is now:  Mon Nov &lt;span class="m"&gt;23&lt;/span&gt; 15:29:36 UTC 2015.

Root password is &lt;span class="s1"&gt;&amp;#39;E3+K9SpU&amp;#39;&lt;/span&gt;, please change !
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Acabada la generación del contenedor, vamos a configurarle algunos parámetros; que tenga una interfaz &lt;em&gt;eth0&lt;/em&gt; activa y enchufada al bridge &lt;em&gt;lxc0&lt;/em&gt;, y que el contenedor se inicie automáticamente en cada reinicio del anfitrión.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /var/lib/lxc/webserver/config 
...
lxc.start.auto &lt;span class="o"&gt;=&lt;/span&gt; 1
lxc.network.type &lt;span class="o"&gt;=&lt;/span&gt; veth
lxc.network.flags &lt;span class="o"&gt;=&lt;/span&gt; up
lxc.network.link &lt;span class="o"&gt;=&lt;/span&gt; lxc0
lxc.network.name &lt;span class="o"&gt;=&lt;/span&gt; eth0
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y para que su interfaz de red sea funcional, vamos a configurarle una dirección IP. Todo esto se hace en los ficheros habituales, teniendo en cuenta que un contenedor es una jaula, y que esta se encuentra en &lt;em&gt;/var/lib/lxc/webserver/rootfs/&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /var/lib/lxc/webserver/rootfs/etc/network/interfaces
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
    address 10.0.0.2
    netmask 255.255.255.0
    gateway 10.0.0.1
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El contenedor ya está funcional, y se puede levantar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# lxc-start -n webserver -d
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Supongamos que este nuevo contenedor tiene un servidor web y queremos hacerlo disponible en puerto 80 del &lt;em&gt;host&lt;/em&gt;, mediante el protocolo &lt;em&gt;NAT&lt;/em&gt;. También se necesita definir una regla de &lt;em&gt;forward&lt;/em&gt; para permitir ese tráfico. Se reinicia el servicio &lt;em&gt;firehol&lt;/em&gt; para aplicar las nuevas reglas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/firehol/firehol.conf 
dnat 10.0.0.2:80 proto tcp dst 192.168.56.4 dport 80

interface eth0 world
    policy drop
    protection strong
    server ssh accept
    client all accept

interface lxc0 lan
    policy drop
    client all accept

router lan2world inface lxc0 outface eth0
    masquerade
    route all accept

router world2lan inface eth0 outface lxc0
    route http accept dst 10.0.0.2
root@lxc:~# service firehol restart
...
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora podemos acceder al servidor web instalado en el contenedor &lt;em&gt;webserver&lt;/em&gt; mediante el puerto 80 del &lt;em&gt;host&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Supongamos que tenemos otro contenedor con un servidor de aplicaciones escuchando en el puerto 8080 con dirección 10.0.0.3 y pretendemos que el contenedor original haga de &lt;em&gt;proxy HTTP&lt;/em&gt;. Esta funcionalidad requiere que el contenedor &lt;em&gt;webserver&lt;/em&gt; pueda conectarse al puerto 8080 del nuevo contenedor &lt;em&gt;appserver&lt;/em&gt;. Esta regla de &lt;em&gt;forward&lt;/em&gt; aplica a todas las conexiones que inician y finalizan en el &lt;em&gt;bridge&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/firehol/firehol.conf 
dnat 10.0.0.2:80 proto tcp dst 192.168.56.4 dport 80

interface eth0 world
    policy drop
    protection strong
    server ssh accept
    client all accept

interface lxc0 lan
    policy drop
    client all accept

router lan2world inface lxc0 outface eth0
    masquerade
    route all accept

router world2lan inface eth0 outface lxc0
    route http accept dst 10.0.0.2

router internal inface lxc0 outface lxc0
    route webcache accept src 10.0.0.2 dst 10.0.0.3
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con eso tenemos nuestro &lt;em&gt;proxy HTTP&lt;/em&gt; funcionando.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="lxc"></category><category term="bridge"></category><category term="firehol"></category></entry><entry><title>Creando sistemas de ficheros temporales con tmpfs</title><link href="http://www.linuxsysadmin.tk/2015/11/creando-sistemas-de-ficheros-temporales-con-tmpfs.html" rel="alternate"></link><updated>2015-11-16T23:15:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-11-16:2015/11/creando-sistemas-de-ficheros-temporales-con-tmpfs.html</id><summary type="html">&lt;p&gt;A veces nos podemos encontrar con un sistema de ficheros lleno que no nos permite completar alguna acción por falta de espacio en disco. En un caso así, existe la posibilidad de sacar un sistema de ficheros completo de memoria, de una forma temporal, usando el sistema de ficheros &lt;em&gt;tmpfs&lt;/em&gt;. Otra opción es la de tener un sistema de ficheros temporal, en donde podamos dejar ficheros cuya persistencia no sea necesaria entre reinicios.&lt;/p&gt;
&lt;p&gt;El primer paso es tener un &lt;em&gt;punto de montaje&lt;/em&gt;, que sea la carpeta en la que se va a montar el nuevo sistema de fichero. Por ejemplo podemos usar el punto de montaje &lt;em&gt;/mnt/auxiliar&lt;/em&gt;; empezaremos creándolo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkdir /mnt/auxiliar
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Observemos como la carpeta creada se construye sobre el mismo dispositivo que la partición raíz:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# df -h /mnt/auxiliar/
S.ficheros     Tamaño Usados  Disp Uso% Montado en
/dev/sda1        2,0G   640M  1,2G  35% /
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creando el sistema de ficheros de forma temporal&lt;/h2&gt;
&lt;p&gt;Como prueba de concepto, podemos crear este sistema de ficheros de forma temporal. En caso de no salir bien, los efectos no serían permanentes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mount -o &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;100M -t tmpfs auxiliar /mnt/auxiliar/
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Podemos ver como la carpeta pertenece ahora a un sistema de ficheros nuevo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# df -h /mnt/auxiliar/
S.ficheros     Tamaño Usados  Disp Uso% Montado en
auxiliar            100M      &lt;span class="m"&gt;0&lt;/span&gt;  100M   0% /mnt/auxiliar
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cuando nos cansemos del nuevo sistema de ficheros, haya cumplido con su utilidad y ya no necesitemos su contenido, la podemos desmontar; vamos a perder todos los ficheros dentro del sistema de ficheros temporal.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# umount /mnt/auxiliar/
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Haciendo el cambio permanente&lt;/h2&gt;
&lt;p&gt;Si nos interesa que este sistema de fichero se &lt;em&gt;monte&lt;/em&gt; y se &lt;em&gt;desmonte&lt;/em&gt; cada vez que la máquina se inicie y se apague, basta con usar el mecanismo estándar de todo sistema de ficheros &lt;em&gt;Linux&lt;/em&gt;: el fichero &lt;em&gt;/etc/fstab&lt;/em&gt;. Basta con añadir una línea nueva con las especificaciones de este punto de montaje, por ejemplo en el final del mismo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# tail -1 /etc/fstab 
auxiliar /mnt/auxiliar tmpfs &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;100M &lt;span class="m"&gt;0&lt;/span&gt; 0
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Con este cambio es suficiente para las sesiones venideras. En caso de querer disponer inmediatamente del sistema de ficheros podemos solicitar el montaje con un comando &lt;em&gt;mount&lt;/em&gt; normal, comando que va a usar las especificaciones del fichero &lt;em&gt;/etc/fstab&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mount /mnt/auxiliar
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto queda completado nuestro objetivo.&lt;/p&gt;</summary><category term="linux"></category><category term="tmpfs"></category></entry><entry><title>Escribiendo units en systemd</title><link href="http://www.linuxsysadmin.tk/2015/11/escribiendo-units-en-systemd.html" rel="alternate"></link><updated>2015-11-09T22:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-11-09:2015/11/escribiendo-units-en-systemd.html</id><summary type="html">&lt;p&gt;Cuando se anunció &lt;em&gt;systemd&lt;/em&gt; me llamó la atención que además de las funciones estándares de otros sistemas de &lt;em&gt;init&lt;/em&gt; (por ejemplo &lt;em&gt;sysvinit&lt;/em&gt;), también se ofrecían otras funcionalidades normalmente delegadas a otros procesos, como por ejemplo, la posibilidad de reiniciar procesos automáticamente o de lanzar procesos temporales al estilo de &lt;em&gt;cron&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;En este artículo se explica como escribir estos ficheros que rigen las tareas propias del sistema &lt;em&gt;init&lt;/em&gt; para iniciar procesos que no disponen de tales facilidades. Adicionalmente, vamos a ver como beneficiarnos del sistema de plantillas de estos mismos ficheros para evitarnos tener que repetirnos, de acuerdo con el principio &lt;a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"&gt;DRY (don't repeat yourself)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Como ejemplo, vamos a utilizar un sistema básico de &lt;em&gt;Linux&lt;/em&gt; con &lt;em&gt;systemd&lt;/em&gt;; que podría ser &lt;em&gt;RedHat 7&lt;/em&gt;, &lt;em&gt;ArchLinux&lt;/em&gt; o &lt;em&gt;Debian 8&lt;/em&gt;. En este caso, se va a utilizar un sistema &lt;em&gt;Debian Jessie&lt;/em&gt; con una instalación básica &lt;em&gt;netinstall&lt;/em&gt; con &lt;em&gt;SSH&lt;/em&gt; y nada mas.&lt;/p&gt;
&lt;p&gt;Vamos a suponer que queremos montar un servidor con 2 instancias de &lt;em&gt;MongoDB&lt;/em&gt;, escuchando en los puertos 27001 y 27002. Empecemos con montar una estructura en &lt;em&gt;/opt/&lt;/em&gt; para contener todo lo relacionado con este despliegue. La idea es que vamos a levantar el binario &lt;em&gt;mongod&lt;/em&gt; con dos configuraciones distintas. Por eso, de momento basta con poner el binario &lt;em&gt;mongod&lt;/em&gt;, las dos configuraciones y las dos carpetas de datos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# tree /opt/
/opt/
└── mongodb
    ├── bin
    │   └── mongod
    ├── conf
    │   ├── mongo1.conf
    │   └── mongo2.conf
    ├── data
    │   ├── mongo1
    │   └── mongo2
    └── logs

&lt;span class="m"&gt;7&lt;/span&gt; directories, &lt;span class="m"&gt;3&lt;/span&gt; files
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La configuración de ambos procesos va a ser la mínima necesaria para que los procesos no entren en conflicto entre ellos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /opt/mongodb/conf/mongo1.conf 
systemLog:
    path: /opt/mongodb/logs/mongo1.log
    logAppend: &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="nb"&gt;    &lt;/span&gt;destination: file

net:
    port: 27001

storage:
    dbPath: /opt/mongodb/data/mongo1
    smallFiles: &lt;span class="nb"&gt;true&lt;/span&gt;
root@server:~# cat /opt/mongodb/conf/mongo2.conf 
systemLog:
    path: /opt/mongodb/logs/mongo2.log
    logAppend: &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="nb"&gt;    &lt;/span&gt;destination: file

net:
    port: 27002

storage:
    dbPath: /opt/mongodb/data/mongo2
    smallFiles: &lt;span class="nb"&gt;true&lt;/span&gt;
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como apunte importante, no se ha definido un archivo para guardar el &lt;em&gt;PID&lt;/em&gt; del proceso; &lt;em&gt;systemd&lt;/em&gt; no lo necesita y conoce el &lt;em&gt;PID&lt;/em&gt; de los procesos que levanta.&lt;/p&gt;
&lt;p&gt;Siguiendo las directivas de seguridad mínimas, los dos procesos &lt;em&gt;mongod&lt;/em&gt; van a levantarse con un usuario estándar que no sea &lt;em&gt;root&lt;/em&gt;. En este caso, toda la carpeta &lt;em&gt;/opt/mongodb/&lt;/em&gt; pertenece al usuario &lt;em&gt;mongo&lt;/em&gt;, aunque bastaría con la carpeta de datos y la de logs.&lt;/p&gt;
&lt;p&gt;Ponemos la definición de nuestras &lt;strong&gt;units&lt;/strong&gt; en la carpeta designada según el estándar, que es &lt;em&gt;/etc/systemd/system/&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/systemd/system/mongo1.service 
&lt;span class="o"&gt;[&lt;/span&gt;Unit&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;MongoDB

&lt;span class="o"&gt;[&lt;/span&gt;Service&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;mongo
&lt;span class="nv"&gt;LimitFSIZE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitCPU&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitNOFILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;LimitNPROC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;ExecStartPre&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/bin/rm -f /opt/mongodb/data/mongo1/mongod.lock
&lt;span class="nv"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/opt/mongodb/bin/mongod -f /opt/mongodb/conf/mongo1.conf

&lt;span class="o"&gt;[&lt;/span&gt;Install&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;multi-user.target
root@server:~# cat /etc/systemd/system/mongo2.service 
&lt;span class="o"&gt;[&lt;/span&gt;Unit&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;MongoDB

&lt;span class="o"&gt;[&lt;/span&gt;Service&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;mongo
&lt;span class="nv"&gt;LimitFSIZE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitCPU&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitNOFILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;LimitNPROC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;ExecStartPre&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/bin/rm -f /opt/mongodb/data/mongo2/mongod.lock
&lt;span class="nv"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/opt/mongodb/bin/mongod -f /opt/mongodb/conf/mongo2.conf

&lt;span class="o"&gt;[&lt;/span&gt;Install&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;multi-user.target
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Es especialmente interesante ver que el lenguaje de la &lt;strong&gt;units&lt;/strong&gt; de &lt;em&gt;systemd&lt;/em&gt; es declarativo, y que no son &lt;em&gt;init scripts&lt;/em&gt;; &lt;em&gt;systemd&lt;/em&gt; se encarga de todo por nosotros. Basta con declarar el comando con el que levantar el servicio y el usuario con el que hacerlo.&lt;/p&gt;
&lt;p&gt;La directiva &lt;strong&gt;WantedBy&lt;/strong&gt; indica que se tiene que levantar con el &lt;strong&gt;target&lt;/strong&gt; &lt;em&gt;multi-user&lt;/em&gt;, que es el que usa &lt;em&gt;Debian&lt;/em&gt; por defecto. Un &lt;strong&gt;target&lt;/strong&gt; viene a ser el equivalente a un &lt;em&gt;runlevel&lt;/em&gt; de &lt;em&gt;sysvinit&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Hay una directiva &lt;strong&gt;ExecStartPre&lt;/strong&gt; que se encarga de eliminar el &lt;em&gt;lock file&lt;/em&gt; de &lt;em&gt;MongoDB&lt;/em&gt; por si el proceso hubiera acabado de forma inesperada. El binario &lt;em&gt;mongod&lt;/em&gt; no levanta si este fichero existe, ya que cree que ya hay una instancia de &lt;em&gt;mongod&lt;/em&gt; usando la carpeta de datos.&lt;/p&gt;
&lt;p&gt;El resto de directivas se limitan a modificar los límites de los procesos a levantar, de acuerdo a la documentación de &lt;em&gt;MongoDB&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A partir de ahora, son &lt;strong&gt;units&lt;/strong&gt; normales del sistema y se pueden activar e iniciar. Si ya estuvieran cargados, habría que recargar la configuración de &lt;em&gt;systemd&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# systemctl &lt;span class="nb"&gt;enable &lt;/span&gt;mongo1
root@server:~# systemctl &lt;span class="nb"&gt;enable &lt;/span&gt;mongo2
root@server:~# systemctl start mongo1
root@server:~# systemctl start mongo2
root@server:~# systemctl daemon-reload
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Uso de plantillas para evitar repetirnos&lt;/h2&gt;
&lt;p&gt;Toda &lt;strong&gt;unit&lt;/strong&gt; cuyo nombre acabe en &lt;strong&gt;arroba&lt;/strong&gt; seguido por &lt;em&gt;.service&lt;/em&gt; o cualquier otro tipo de &lt;strong&gt;unit&lt;/strong&gt;, es por convención, una &lt;strong&gt;plantilla&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;La idea es que vamos a crear un &lt;em&gt;link&lt;/em&gt; a la &lt;strong&gt;plantilla&lt;/strong&gt;, que ponga un texto detrás de la &lt;strong&gt;arroba&lt;/strong&gt;. Este texto va a estar disponible en la plantilla como &lt;strong&gt;%i&lt;/strong&gt;. De esta forma podemos "pasar un parámetro" a la plantilla, usando ese parámetro como diferenciador de los dos procesos.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Veamos un ejemplo:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Creamos dos &lt;em&gt;links&lt;/em&gt; a la &lt;strong&gt;plantilla&lt;/strong&gt; &lt;em&gt;mongodb@.service&lt;/em&gt;, con los nombres &lt;em&gt;mongodb@mongo1.service&lt;/em&gt; y &lt;em&gt;mongodb@mongo2.service&lt;/em&gt;, que son nuestras instancias. Estas instancias se rigen con las directivas de la &lt;strong&gt;plantilla&lt;/strong&gt;, con la variable &lt;strong&gt;%i&lt;/strong&gt; conteniendo los valores &lt;em&gt;mongo1&lt;/em&gt; y &lt;em&gt;mongo2&lt;/em&gt; respectivamente.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# ls -l /etc/systemd/system/mongodb&lt;span class="se"&gt;\@&lt;/span&gt;*
lrwxrwxrwx &lt;span class="m"&gt;1&lt;/span&gt; root root  &lt;span class="m"&gt;16&lt;/span&gt; nov  &lt;span class="m"&gt;3&lt;/span&gt; 12:46 /etc/systemd/system/mongodb@mongo1.service -&amp;gt; mongodb@.service
lrwxrwxrwx &lt;span class="m"&gt;1&lt;/span&gt; root root  &lt;span class="m"&gt;16&lt;/span&gt; nov  &lt;span class="m"&gt;3&lt;/span&gt; 12:46 /etc/systemd/system/mongodb@mongo2.service -&amp;gt; mongodb@.service
-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;207&lt;/span&gt; nov  &lt;span class="m"&gt;3&lt;/span&gt; 12:45 /etc/systemd/system/mongodb@.service
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora redactamos la plantilla, teniendo en cuenta los valores que se van a cambiarse por la variable &lt;strong&gt;%i&lt;/strong&gt;, que vamos a usar para identificar el fichero de configuración de cada instancia. También es posible poner otras variables en la &lt;strong&gt;plantilla&lt;/strong&gt;, como por ejemplo, el nombre de la máquina o la versión del &lt;em&gt;kernel&lt;/em&gt; de la máquina.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/systemd/system/mongodb&lt;span class="se"&gt;\@&lt;/span&gt;.service 
&lt;span class="o"&gt;[&lt;/span&gt;Unit&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;MongoDB

&lt;span class="o"&gt;[&lt;/span&gt;Service&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;mongo
&lt;span class="nv"&gt;LimitFSIZE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitCPU&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitNOFILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;LimitNPROC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;ExecStartPre&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/bin/rm -f /opt/mongodb/data/%i/mongod.lock
&lt;span class="nv"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/opt/mongodb/bin/mongod -f /opt/mongodb/conf/%i.conf

&lt;span class="o"&gt;[&lt;/span&gt;Install&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;multi-user.target
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora solo falta activar las instancias e iniciarlas, con los comandos habituales del demonio &lt;em&gt;systemd&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# systemctl &lt;span class="nb"&gt;enable &lt;/span&gt;mongodb@mongo1
Created symlink from /etc/systemd/system/multi-user.target.wants/mongodb@mongo1.service to /etc/systemd/system/mongodb@.service.
root@server:~# systemctl &lt;span class="nb"&gt;enable &lt;/span&gt;mongodb@mongo2
Created symlink from /etc/systemd/system/multi-user.target.wants/mongodb@mongo2.service to /etc/systemd/system/mongodb@.service.
root@server:~# systemctl start mongodb@mongo1
root@server:~# systemctl start mongodb@mongo2
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto lo hemos conseguido.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="systemd"></category><category term="mongodb"></category></entry><entry><title>Restart automático de servicios con systemd</title><link href="http://www.linuxsysadmin.tk/2015/11/restart-automatico-de-servicios-con-systemd.html" rel="alternate"></link><updated>2015-11-05T22:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-11-05:2015/11/restart-automatico-de-servicios-con-systemd.html</id><summary type="html">&lt;p&gt;Cuando estamos gestionando un servidor, es posible que se caiga alguno de sus servicios. Esto es especialmente molesto cuando nos interesa tener un &lt;em&gt;uptime&lt;/em&gt; elevado. Para conseguirlo, se han utilizado diferentes maneras, desde poner personas a monitorizar en modo 24x7 hasta herramientas auxiliares como gestores tipo &lt;em&gt;runit&lt;/em&gt;, &lt;em&gt;supervisor&lt;/em&gt; o &lt;em&gt;monit&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Con la entrada en escena de &lt;em&gt;systemd&lt;/em&gt; en la mayoría de distribuciones grandes de &lt;em&gt;linux&lt;/em&gt; este problema se ha acabado; el mismo proceso que hace de &lt;strong&gt;init&lt;/strong&gt; puede encargarse de mantener los procesos levantados, y reiniciarlos en caso de caída.&lt;/p&gt;
&lt;p&gt;En este tutorial pretendo hacer que un servicio estándar se vea beneficiado de un &lt;strong&gt;override&lt;/strong&gt;, que permita el inicio automático de un servicio cuando se cae, sin tener que reescribir la &lt;strong&gt;unit&lt;/strong&gt; que se encarga del servicio o proceso.&lt;/p&gt;
&lt;p&gt;Partimos de un servidor básico &lt;em&gt;Linux&lt;/em&gt; con &lt;em&gt;systemd&lt;/em&gt;. En este caso vamos a utilizar la última versión estable de &lt;em&gt;Debian&lt;/em&gt;, a la que le vamos a instalar un servicio estándar como &lt;em&gt;nginx&lt;/em&gt; que nos va a servir como conejillo de indias.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# apt-get install nginx-light
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Procedimiento&lt;/h2&gt;
&lt;p&gt;Como comprobación previa, observemos como este &lt;strong&gt;restart&lt;/strong&gt; automático no funciona; tenemos el servicio en ejecución, lo matamos y observamos que no se levanta de nuevo, por mucho que esperemos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;685&lt;/span&gt;  0.0  0.8   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2240&lt;/span&gt; pts/0    S+   11:41   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;662&lt;/span&gt;  0.0  0.7   &lt;span class="m"&gt;6356&lt;/span&gt;  &lt;span class="m"&gt;1856&lt;/span&gt; ?        Ss   11:41   0:00 nginx: master process /usr/sbin/nginx -g daemon on&lt;span class="p"&gt;;&lt;/span&gt; master_process on&lt;span class="p"&gt;;&lt;/span&gt;
www-data   &lt;span class="m"&gt;663&lt;/span&gt;  0.1  0.9   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2456&lt;/span&gt; ?        S    11:41   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;664&lt;/span&gt;  0.0  0.9   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2456&lt;/span&gt; ?        S    11:41   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;665&lt;/span&gt;  0.0  0.9   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2456&lt;/span&gt; ?        S    11:41   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;666&lt;/span&gt;  0.1  0.9   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2456&lt;/span&gt; ?        S    11:41   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
root@server:~# &lt;span class="nb"&gt;kill &lt;/span&gt;662
root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;691&lt;/span&gt;  0.0  0.8   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2220&lt;/span&gt; pts/0    S+   11:41   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora necesitamos localizar el nombre de la &lt;strong&gt;unit&lt;/strong&gt; que se encarga de ese servicio, puesto que la carpeta de &lt;strong&gt;overrides&lt;/strong&gt; debe llamarse igual.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# systemctl list-units -a &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
  nginx.service    loaded    inactive dead    A high performance web server and a reverse proxy server
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como curiosidad, este fichero se encuentra en &lt;em&gt;/lib/systemd/system/&lt;/em&gt;, siguiendo las convenciones del empaquetado de &lt;em&gt;Debian&lt;/em&gt;. Alternativamente, podemos localizar los ficheros instalados por un paquete con el comando &lt;em&gt;dpkg -L nginx-light&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# ls -lh /lib/systemd/system/nginx.service 
-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;986&lt;/span&gt; dic  &lt;span class="m"&gt;1&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; /lib/systemd/system/nginx.service
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En caso de ser una &lt;strong&gt;unit&lt;/strong&gt; escrita por nosotros, se encontraría en &lt;em&gt;/etc/systemd/system/&lt;/em&gt;. Esta es la convención:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;/lib/systemd/system/&lt;/em&gt; &amp;rarr; &lt;strong&gt;units&lt;/strong&gt; de sistema, puestas por los paquetes instalados&lt;/li&gt;
&lt;li&gt;&lt;em&gt;/etc/systemd/system/&lt;/em&gt; &amp;rarr; &lt;strong&gt;units&lt;/strong&gt; o &lt;strong&gt;overrides&lt;/strong&gt; puestos por el usuario (nosotros)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para añadir nuevas directivas (&lt;strong&gt;overrides&lt;/strong&gt;) a una &lt;strong&gt;unit&lt;/strong&gt; sin reescribirla entera, basta con crear una carpeta con su mismo nombre, concatenando &lt;strong&gt;.d&lt;/strong&gt;. Dentro podemos poner tantos ficheros &lt;em&gt;.conf&lt;/em&gt; como creamos necesarios, añadiendo las directivas que queramos añadir o modificar.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkdir /etc/systemd/system/nginx.service.d
root@server:~# cat /etc/systemd/system/nginx.service.d/autorestart.conf
&lt;span class="o"&gt;[&lt;/span&gt;Service&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;Restart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;always
&lt;span class="nv"&gt;RestartSec&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En este caso, se ha indicado que queremos un &lt;strong&gt;restart&lt;/strong&gt; siempre, sean cuales sean las circunstancias en las que se cayó el proceso, y que espere 1 segundo antes de intentarlo. Por como está hecho &lt;em&gt;systemd&lt;/em&gt;, &lt;strong&gt;no&lt;/strong&gt; va a levantar un servicio que hemos parado invocando el comando &lt;em&gt;systemctl&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Para que los cambios en el fichero de configuración se apliquen es necesario recargar las configuraciones, indicando a &lt;em&gt;systemd&lt;/em&gt; que tienen que recargarlas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# systemctl daemon-reload
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Comprobación&lt;/h2&gt;
&lt;p&gt;Básicamente vamos a repetir el paso de la comprobación; se localiza el proceso &lt;strong&gt;master&lt;/strong&gt; y se finaliza (por ejemplo, con un &lt;strong&gt;SIGTERM&lt;/strong&gt; normal).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;782&lt;/span&gt;  0.0  0.8   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2252&lt;/span&gt; pts/0    S+   11:56   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;776&lt;/span&gt;  0.0  0.7   &lt;span class="m"&gt;6356&lt;/span&gt;  &lt;span class="m"&gt;1936&lt;/span&gt; ?        Ss   11:56   0:00 nginx: master process /usr/sbin/nginx -g daemon on&lt;span class="p"&gt;;&lt;/span&gt; master_process on&lt;span class="p"&gt;;&lt;/span&gt;
www-data   &lt;span class="m"&gt;777&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2536&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;778&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2536&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;779&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2536&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;780&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2536&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
root@server:~# &lt;span class="nb"&gt;kill &lt;/span&gt;776
root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;787&lt;/span&gt;  0.0  0.9   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2280&lt;/span&gt; pts/0    S+   11:56   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora solo hay que esperar el paso de los segundos configurados, y volver a ver si el servicio está corriendo; aunque en este esperé algo menos de lo configurado; la paciencia no es una de mis virtudes...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;789&lt;/span&gt;  0.0  0.8   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2192&lt;/span&gt; pts/0    S+   11:56   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;791&lt;/span&gt;  0.0  0.9   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2280&lt;/span&gt; pts/0    S+   11:56   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;802&lt;/span&gt;  0.0  0.8   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2236&lt;/span&gt; pts/0    S+   11:56   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;796&lt;/span&gt;  0.0  0.7   &lt;span class="m"&gt;6356&lt;/span&gt;  &lt;span class="m"&gt;1932&lt;/span&gt; ?        Ss   11:56   0:00 nginx: master process /usr/sbin/nginx -g daemon on&lt;span class="p"&gt;;&lt;/span&gt; master_process on&lt;span class="p"&gt;;&lt;/span&gt;
www-data   &lt;span class="m"&gt;797&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2592&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;798&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2592&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;799&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2592&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;800&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2532&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto tenemos nuestro &lt;strong&gt;autorestart&lt;/strong&gt; para este servicio.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="systemd"></category><category term="nginx"></category></entry><entry><title>Liberando memoria caché</title><link href="http://www.linuxsysadmin.tk/2015/11/liberando-memoria-cache.html" rel="alternate"></link><updated>2015-11-02T14:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-11-02:2015/11/liberando-memoria-cache.html</id><summary type="html">&lt;p&gt;A veces nos encontramos que nuestro sistema linux parece tener la memoria &lt;em&gt;virtual&lt;/em&gt; ocupada, cuando no tenemos nada de memoria &lt;em&gt;RSS&lt;/em&gt;; esto no es un problema, ya que por la forma de funcionar del &lt;em&gt;memory manager&lt;/em&gt; de linux, se conserva "por si acaso" y se libera cuando realmente se necesita.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;free -m
             total       used       free     shared    buffers     cached
Mem:          &lt;span class="m"&gt;3858&lt;/span&gt;       &lt;span class="m"&gt;3226&lt;/span&gt;        &lt;span class="m"&gt;632&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;        &lt;span class="m"&gt;114&lt;/span&gt;       2545
-/+ buffers/cache:        &lt;span class="m"&gt;566&lt;/span&gt;       3291
Swap:         &lt;span class="m"&gt;2381&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;       2381
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sin embargo este detalle nos puede resultar molesto y puede que queramos &lt;strong&gt;liberar&lt;/strong&gt; esa memoria de verdad, por ejemplo, para comparar memoria real ocupada por el sistema o sencillamente porque así lo queremos.&lt;/p&gt;
&lt;p&gt;En este caso no tenemos mas remedio que solicitar el &lt;em&gt;memory manager&lt;/em&gt; que la libere, escribiendo en el fichero de control habilitado para ello, de acuerdo a la &lt;a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt"&gt;documentación del &lt;em&gt;kernel&lt;/em&gt; de linux&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;drop_caches

Writing to this will cause the kernel to drop clean caches, as well as
reclaimable slab objects like dentries and inodes.  Once dropped, their
memory becomes free.

To free pagecache:
    &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &amp;gt; /proc/sys/vm/drop_caches
To free reclaimable slab objects &lt;span class="o"&gt;(&lt;/span&gt;includes dentries and inodes&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt; &amp;gt; /proc/sys/vm/drop_caches
To free slab objects and pagecache:
    &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt; &amp;gt; /proc/sys/vm/drop_caches

This is a non-destructive operation and will not free any dirty objects.
To increase the number of objects freed by this operation, the user may run
&lt;span class="sb"&gt;`&lt;/span&gt;sync&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; prior to writing to /proc/sys/vm/drop_caches.  This will minimize the
number of dirty objects on the system and create more candidates to be
dropped.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Este fichero viene por defecto con permisos de escritura solamente para el usuario &lt;strong&gt;root&lt;/strong&gt; y no se puede escribir sin el mismo. Como no queremos trabajar con el usuario &lt;strong&gt;root&lt;/strong&gt;, vamos a usar el comando &lt;em&gt;sudo&lt;/em&gt; con un usuario normal:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;sudo bash -c &lt;span class="s2"&gt;&amp;quot;echo 3 &amp;gt; /proc/sys/vm/drop_caches&amp;quot;&lt;/span&gt;
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Alternativamente, podemos utilizar el comando &lt;em&gt;tee&lt;/em&gt; para realizar la misma operación, sin el envoltorio de &lt;em&gt;bash&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sudo tee /proc/sys/vm/drop_caches
3
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y finalmente nuestra memoria queda vacía de todo aquello que no era indispensable para la ejecución del sistema.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;free -m
             total       used       free     shared    buffers     cached
Mem:          &lt;span class="m"&gt;3858&lt;/span&gt;        &lt;span class="m"&gt;752&lt;/span&gt;       &lt;span class="m"&gt;3105&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;          &lt;span class="m"&gt;2&lt;/span&gt;        207
-/+ buffers/cache:        &lt;span class="m"&gt;542&lt;/span&gt;       3315
Swap:         &lt;span class="m"&gt;2381&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;       2381
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;¡Acabamos de liberar 2 gigabytes de memoria!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CUIDADO&lt;/strong&gt;: Esta operación puede afectar el rendimiento puntual del sistema, ya que en caso de volver a necesitar la información &lt;em&gt;cacheada&lt;/em&gt;, deberá volver a recargar la memoria, probablemente desde disco.&lt;/p&gt;</summary><category term="linux"></category><category term="kernel"></category><category term="memory manager"></category><category term="drop caches"></category></entry><entry><title>Ocultando puertos con port knocking</title><link href="http://www.linuxsysadmin.tk/2015/10/ocultando-puertos-con-port-knocking.html" rel="alternate"></link><updated>2015-10-29T11:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-10-29:2015/10/ocultando-puertos-con-port-knocking.html</id><summary type="html">&lt;p&gt;En este artículo vamos a enseñar como ocultar un puerto tras el firewall, de forma que solamente se abra tras utilizar el protocolo &lt;em&gt;port knocking&lt;/em&gt;. Las tecnologías usadas van a ser &lt;em&gt;firehol&lt;/em&gt; como firewall y el demonio &lt;em&gt;knockd&lt;/em&gt; ocultando el &lt;em&gt;SSH&lt;/em&gt;, aunque vamos a permitir acceder al puerto de HTTP.&lt;/p&gt;
&lt;p&gt;El protocolo de &lt;em&gt;port knocking&lt;/em&gt; es un sistema en el que para abrir la conectividad en un puerto se debe primero abrir una secuencia concreta a otros puertos, sean &lt;em&gt;TCP&lt;/em&gt; o &lt;em&gt;UDP&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Para conseguir este objetivo, se van a usar las siguientes tecnologías:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Debian jessie&lt;/strong&gt;: Como distribución base; podría ser cualquier otra&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Firehol&lt;/strong&gt;: Scripts para levantar un firewall basado en &lt;em&gt;iptables&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El hardware va a ser uno con capacidades limitadas, virtualizado en VirtualBox.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPUs&lt;/strong&gt;: 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria&lt;/strong&gt;: 256 Mb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Disco&lt;/strong&gt;: 2 Gb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Red&lt;/strong&gt;: 1 interfaz (&lt;em&gt;eth0&lt;/em&gt;) &lt;em&gt;host-only&lt;/em&gt; o &lt;em&gt;bridged&lt;/em&gt; con IP fija&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La instalación base es una &lt;em&gt;Debian&lt;/em&gt; mínima instalada con el CD netinstall, con todo desmarcado y con el servidor de &lt;em&gt;SSH&lt;/em&gt; previamente instalado.&lt;/p&gt;
&lt;h2&gt;Instalación del servidor&lt;/h2&gt;
&lt;p&gt;Para empezar, vamos a instalar los dos servicios implicados:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# apt-get install firehol knockd
...
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Configuramos las reglas del firewall, de acuerdo a la documentación relacionada con &lt;em&gt;port knocking&lt;/em&gt;. Se define un nivel de protección máximo, ya que se trata de la interfaz que deberá estar accesible desde internet; esto nos evita la mayoría de ataques conocidos en la capa 3 y 4.&lt;/p&gt;
&lt;p&gt;En cuanto a las conectividad, vamos a permitir que este servidor acceda a servicios &lt;em&gt;DNS&lt;/em&gt; y &lt;em&gt;HTTP&lt;/em&gt;, que es lo justo para actualizarse. Como servidor vamos a permitir el acceso a &lt;em&gt;HTTP&lt;/em&gt; (ya que en el ejemplo, esta máquina va a servir como servidor &lt;em&gt;HTTP&lt;/em&gt;) y a &lt;em&gt;SSH&lt;/em&gt; siempre y cuando se cumpla con el protocolo de seguridad.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/firehol/firehol.conf 
version 5

interface any world
    protection strong
    client &lt;span class="s2"&gt;&amp;quot;dns http&amp;quot;&lt;/span&gt; accept
    server http accept
    server ssh accept with knock hidden
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Acto seguido vamos a definir las reglas para que se abra el &lt;em&gt;knock hidden&lt;/em&gt; (que corresponde con el puerto &lt;em&gt;SSH&lt;/em&gt;) si se completa la secuencia de &lt;em&gt;knock&lt;/em&gt;. En este caso concreto, se indica una secuencia de los puertos &lt;em&gt;TCP&lt;/em&gt; 123, 456 y 789; aunque es posible definir puertos &lt;em&gt;UDP&lt;/em&gt;, dejamos sin indicarlo, que nos los va a definir como &lt;em&gt;TCP&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Como medida de seguridad vamos a indicar un tiempo máximo de 10 segundos para completar la secuencia de &lt;em&gt;knock&lt;/em&gt; y un autocierre del puerto a los 5 segundos (aunque firehol va a permitir las conexiones que se hayan establecido en esos 5 segundos).&lt;/p&gt;
&lt;p&gt;Es especialmente interesante ver que la regla incluye la dirección origen, con lo que la apertura de puerto solo será visible desde la máquina que completó la secuencia de &lt;em&gt;knock&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/knockd.conf 
&lt;span class="o"&gt;[&lt;/span&gt;options&lt;span class="o"&gt;]&lt;/span&gt;
    UseSyslog

&lt;span class="o"&gt;[&lt;/span&gt;SSH&lt;span class="o"&gt;]&lt;/span&gt;
    &lt;span class="nv"&gt;sequence&lt;/span&gt;      &lt;span class="o"&gt;=&lt;/span&gt; 123,456,789
    &lt;span class="nv"&gt;seq_timeout&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; 10
    &lt;span class="nv"&gt;start_command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; iptables -A knock_hidden -s %IP% -j ACCEPT
    &lt;span class="nv"&gt;cmd_timeout&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; 5
    &lt;span class="nv"&gt;stop_command&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; iptables -D knock_hidden -s %IP% -j ACCEPT
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como medida de seguridad, &lt;em&gt;Debian&lt;/em&gt; tiene una protección para levantar ambos servicios, así que tenemos que indicarle que queremos que se puedan levantar, editando otros ficheros de configuración.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/default/knockd 
...
&lt;span class="nv"&gt;START_KNOCKD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1
...
root@server:~# cat /etc/default/firehol 
...
&lt;span class="nv"&gt;START_FIREHOL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;YES
...
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente podemos levantar los servicios de &lt;em&gt;port knocking&lt;/em&gt; y de &lt;em&gt;firewall&lt;/em&gt;, usando las herramientas estándares que nos ofrece la distribución.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# service knockd restart
root@server:~# service firehol restart
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Comprobación de funcionamiento&lt;/h2&gt;
&lt;p&gt;Para comprobar el funcionamiento basta con comprobar que el puerto está normalmente cerrado. Personalmente he usado &lt;em&gt;nmap&lt;/em&gt;, aunque se podría usar &lt;em&gt;netcat&lt;/em&gt; o &lt;em&gt;telnet&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;nmap -PN 192.168.56.3 -p 22

Starting Nmap 5.21 &lt;span class="o"&gt;(&lt;/span&gt; http://nmap.org &lt;span class="o"&gt;)&lt;/span&gt; at 2015-10-28 17:33 CET
Nmap scan report &lt;span class="k"&gt;for&lt;/span&gt; server &lt;span class="o"&gt;(&lt;/span&gt;192.168.56.3&lt;span class="o"&gt;)&lt;/span&gt;
Host is up.
PORT   STATE    SERVICE
22/tcp filtered ssh

Nmap &lt;span class="k"&gt;done&lt;/span&gt;: &lt;span class="m"&gt;1&lt;/span&gt; IP address &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; host up&lt;span class="o"&gt;)&lt;/span&gt; scanned in 2.13 seconds
gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vemos que sale &lt;strong&gt;filtered&lt;/strong&gt;, que significa que el firewall lo está bloqueando. Ahora vamos a lanzar la secuencia de &lt;em&gt;knock&lt;/em&gt; usando el helper &lt;strong&gt;knock&lt;/strong&gt;, que en &lt;em&gt;Debian&lt;/em&gt; se encuentra en el mismo paquete &lt;em&gt;knockd&lt;/em&gt;. Acto seguido, el puerto de &lt;em&gt;SSH&lt;/em&gt; queda abierto (en otras palabras: escuchando). Ahora sería posible iniciar sesión por &lt;em&gt;SSH&lt;/em&gt; en la máquina.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;knock 192.168.56.3 &lt;span class="m"&gt;123&lt;/span&gt; &lt;span class="m"&gt;456&lt;/span&gt; 789
gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;nmap -PN 192.168.56.3 -p 22

Starting Nmap 5.21 &lt;span class="o"&gt;(&lt;/span&gt; http://nmap.org &lt;span class="o"&gt;)&lt;/span&gt; at 2015-10-28 17:34 CET
Nmap scan report &lt;span class="k"&gt;for&lt;/span&gt; server &lt;span class="o"&gt;(&lt;/span&gt;192.168.56.3&lt;span class="o"&gt;)&lt;/span&gt;
Host is up &lt;span class="o"&gt;(&lt;/span&gt;0.0011s latency&lt;span class="o"&gt;)&lt;/span&gt;.
PORT   STATE SERVICE
22/tcp open  ssh

Nmap &lt;span class="k"&gt;done&lt;/span&gt;: &lt;span class="m"&gt;1&lt;/span&gt; IP address &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; host up&lt;span class="o"&gt;)&lt;/span&gt; scanned in 0.07 seconds
gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente comprobamos que, transcurridos los 5 segundos configurados, el puerto vuelve a verse como &lt;strong&gt;filtrado&lt;/strong&gt;, con lo que no se puede establecer nuevas conexiones en este puerto.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;nmap -PN 192.168.56.3 -p 22

Starting Nmap 5.21 &lt;span class="o"&gt;(&lt;/span&gt; http://nmap.org &lt;span class="o"&gt;)&lt;/span&gt; at 2015-10-28 17:34 CET
Nmap scan report &lt;span class="k"&gt;for&lt;/span&gt; server &lt;span class="o"&gt;(&lt;/span&gt;192.168.56.3&lt;span class="o"&gt;)&lt;/span&gt;
Host is up.
PORT   STATE    SERVICE
22/tcp filtered ssh

Nmap &lt;span class="k"&gt;done&lt;/span&gt;: &lt;span class="m"&gt;1&lt;/span&gt; IP address &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; host up&lt;span class="o"&gt;)&lt;/span&gt; scanned in 2.08 seconds
gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto queda protegido el acceso por &lt;em&gt;SSH&lt;/em&gt; a la máquina.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="firehol"></category><category term="port knocking"></category><category term="ssh"></category><category term="nmap"></category></entry><entry><title>Virtualizando contenedores LXC con acceso a la red local</title><link href="http://www.linuxsysadmin.tk/2015/10/virtualizando-contenedores-lxc-con-acceso-red-local.html" rel="alternate"></link><updated>2015-10-15T12:00:00+02:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-10-15:2015/10/virtualizando-contenedores-lxc-con-acceso-red-local.html</id><summary type="html">&lt;p&gt;En este tutorial se propone montar un servidor de contenedores LXC, de forma que todos los contenedores queden expuestos a la misma red que el servidor que los aloja. Para protegerlos de posibles ataques de esta red, pondremos un firewall basado en &lt;em&gt;iptables&lt;/em&gt; mediante una capa de abstracción llamada &lt;em&gt;firehol&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Para conseguir este objetivo, se van a usar las siguientes tecnologías:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Debian jessie&lt;/strong&gt;: Es necesario usar alguna distribución de linux para hacer funcionar LXC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LXC&lt;/strong&gt;: Tecnología que permite aislar los contenedores entre sí y darles entidad propia&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bridges&lt;/strong&gt;: Un bridge es en software el equivalente a un switch hardware&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Firehol&lt;/strong&gt;: Una serie de scripts para construir firewalls basados en iptables de forma fácil&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En cuanto a las capacidades hardware, vamos a hacer el tutorial con un equipo de capacidades modestas, virtualizado en una máquina virtual VirtualBox.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPUs&lt;/strong&gt;: 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria&lt;/strong&gt;: 256 Mb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Disco&lt;/strong&gt;: 2 Gb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Red&lt;/strong&gt;: 1 interfaz (&lt;em&gt;eth0&lt;/em&gt;) &lt;em&gt;host-only&lt;/em&gt; o &lt;em&gt;bridged&lt;/em&gt; con IP fija&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Partimos de una distribución &lt;em&gt;Debian jessie&lt;/em&gt; instalada con un CD &lt;em&gt;netinstall&lt;/em&gt; y con el único paquete instalado &lt;em&gt;openssh-server&lt;/em&gt;, para mi comodidad.&lt;/p&gt;
&lt;h2&gt;Preparar el servidor&lt;/h2&gt;
&lt;p&gt;El primer paso consiste en instalar las tecnologías usadas:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# apt-get install bridge-utils firehol lxc
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias       
Leyendo la información de estado... Hecho
...
Configurando lxc &lt;span class="o"&gt;(&lt;/span&gt;1:1.0.6-6+deb8u1&lt;span class="o"&gt;)&lt;/span&gt; ...
Configurando dh-python &lt;span class="o"&gt;(&lt;/span&gt;1.20141111-2&lt;span class="o"&gt;)&lt;/span&gt; ...
Procesando disparadores para libc-bin &lt;span class="o"&gt;(&lt;/span&gt;2.19-18+deb8u1&lt;span class="o"&gt;)&lt;/span&gt; ...
Procesando disparadores para systemd &lt;span class="o"&gt;(&lt;/span&gt;215-17+deb8u2&lt;span class="o"&gt;)&lt;/span&gt; ...
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Acto seguido debemos modificar la configuración de red, para que la interfaz de red de la máquina represente la salida de todas las IPs que maneja el bridge y para que el host obtenga una dirección de red en el bridge.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ANTES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/network/interfaces
&lt;span class="nb"&gt;source&lt;/span&gt; /etc/network/interfaces.d/*

auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
    address 192.168.56.4
    netmask 255.255.255.0
    gateway 192.168.56.1
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;DESPUES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/network/interfaces
&lt;span class="nb"&gt;source&lt;/span&gt; /etc/network/interfaces.d/*

auto lo
iface lo inet loopback

auto lxc0
iface lxc0 inet static
    bridge_ports eth0
    address 192.168.56.4
    netmask 255.255.255.0
    gateway 192.168.56.1
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En este punto es necesario reconfigurar la red, siendo especialmente importante que &lt;em&gt;eth0&lt;/em&gt; quede sin dirección IP asignada (en mi caso tuve que reiniciar la máquina).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span class="m"&gt;65536&lt;/span&gt; qdisc noqueue state UNKNOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class="m"&gt;1500&lt;/span&gt; qdisc pfifo_fast master lxc0 state UP group default qlen 1000
    link/ether 08:00:27:e4:0a:60 brd ff:ff:ff:ff:ff:ff
3: lxc0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class="m"&gt;1500&lt;/span&gt; qdisc noqueue state UP group default 
    link/ether 08:00:27:e4:0a:60 brd ff:ff:ff:ff:ff:ff
    inet 192.168.56.4/24 brd 192.168.56.255 scope global lxc0
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fee4:a60/64 scope link 
       valid_lft forever preferred_lft forever
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El último paso consiste en activar el firewall con unas reglas básicas, para proteger el equipo anfitrión de posibles ataques o intrusiones, dejando solamente el acceso a SSH. Con firehol es posible combinar el demonio &lt;em&gt;knockd&lt;/em&gt; para ocultar el puerto tras una secuencia de port knocking; en principio sería suficiente con forzar la entrada SSH por claves RSA.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/firehol/firehol.conf 
interface lxc0 world
    policy drop
    protection strong
    server ssh accept
    client all accept
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hay que modificar otro fichero para permitir el inicio del firewall:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ANTES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# grep START /etc/default/firehol 
&lt;span class="c"&gt;#To enable firehol at startup set START_FIREHOL=YES&lt;/span&gt;
&lt;span class="nv"&gt;START_FIREHOL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;NO
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;DESPUES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# grep START /etc/default/firehol 
&lt;span class="c"&gt;#To enable firehol at startup set START_FIREHOL=YES&lt;/span&gt;
&lt;span class="nv"&gt;START_FIREHOL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;YES
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y para acabar, (re)iniciamos el servicio firehol.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# service firehol restart

Broadcast message from systemd-journald@lxc &lt;span class="o"&gt;(&lt;/span&gt;Wed 2015-10-14 16:59:30 CEST&lt;span class="o"&gt;)&lt;/span&gt;:

FireHOL&lt;span class="o"&gt;[&lt;/span&gt;620&lt;span class="o"&gt;]&lt;/span&gt;: Firewall has been stopped. Policy is ACCEPT EVERYTHING!


Message from syslogd@lxc at Oct &lt;span class="m"&gt;14&lt;/span&gt; 16:59:30 ...
 FireHOL&lt;span class="o"&gt;[&lt;/span&gt;493&lt;span class="o"&gt;]&lt;/span&gt;: Firewall has been stopped. Policy is ACCEPT EVERYTHING!
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creación de contenedores&lt;/h2&gt;
&lt;p&gt;La creación de contenedores pasa por usar las herramientas estándar de la distribución, a lo solo tendremos que modificar algunas configuraciones propias de nuestra red.&lt;/p&gt;
&lt;p&gt;Creamos un contenedor &lt;em&gt;webserver&lt;/em&gt; como demostración. La primera que se crea es un poco lenta porque hace un &lt;em&gt;debootstrap&lt;/em&gt; de una distribución debian estable para crear una cache en &lt;em&gt;/var/cache/lxc&lt;/em&gt;; las siguientes se benefician de esta caché y solo la actualizan, acelerando el proceso.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# lxc-create -n webserver -t debian
debootstrap is /usr/sbin/debootstrap
Checking cache download in /var/cache/lxc/debian/rootfs-jessie-i386 ... 
Downloading debian minimal ...
...
I: Base system installed successfully.
Download complete.
Copying rootfs to /var/lib/lxc/webserver/rootfs...
...
Current default &lt;span class="nb"&gt;time &lt;/span&gt;zone: &lt;span class="s1"&gt;&amp;#39;Europe/Madrid&amp;#39;&lt;/span&gt;
Local &lt;span class="nb"&gt;time &lt;/span&gt;is now:      Wed Oct &lt;span class="m"&gt;14&lt;/span&gt; 17:26:37 CEST 2015.
Universal Time is now:  Wed Oct &lt;span class="m"&gt;14&lt;/span&gt; 15:26:37 UTC 2015.

Root password is &lt;span class="s1"&gt;&amp;#39;sFj7Jm9N&amp;#39;&lt;/span&gt;, please change !
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Acabada la generación del contenedor, vamos a configurarle algunos parámetros; que tenga una interfaz &lt;em&gt;eth0&lt;/em&gt; activa y enchufada al bridge &lt;em&gt;lxc0&lt;/em&gt;, y que el contenedor se autoinicie en cada reinicio del anfitrión.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /var/lib/lxc/webserver/config 
...
lxc.start.auto &lt;span class="o"&gt;=&lt;/span&gt; 1
lxc.network.type &lt;span class="o"&gt;=&lt;/span&gt; veth
lxc.network.flags &lt;span class="o"&gt;=&lt;/span&gt; up
lxc.network.link &lt;span class="o"&gt;=&lt;/span&gt; lxc0
lxc.network.name &lt;span class="o"&gt;=&lt;/span&gt; eth0
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y para que su interfaz de red sea funcional, vamos a configurarle una dirección IP. Todo esto se hace en los ficheros habituales, teniendo en cuenta que un contenedor es una jaula, y que esta se encuentra en &lt;em&gt;/var/lib/lxc/webserver/rootfs/&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /var/lib/lxc/webserver/rootfs/etc/network/interfaces
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
    address 192.168.56.10
    netmask 255.255.255.0
    gateway 192.168.56.1
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El contenedor ya está funcional, y se puede levantar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# lxc-start -n webserver -d
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sin embargo, el firewall impide que se llegue al mismo; tendremos que poner reglas para permitir el flujo de red hacia la nueva dirección IP configurada para el contenedor. Esto se consigue con reglas de &lt;em&gt;forward&lt;/em&gt; que entren por el bridge y salgan por el mismo hacia nuestro contenedor.&lt;/p&gt;
&lt;p&gt;Ya de paso habilitamos reglas para que todo lo que pase por el bridge hacia internet se permita. Como particularidad de nuestra red, el servidor anfitrión tiene un servidor DNS &lt;em&gt;dnsmasq&lt;/em&gt;; así que añadimos también esa ruta.&lt;/p&gt;
&lt;p&gt;Por ejemplo, suponiendo que queremos habilitar el servicio &lt;em&gt;SSH&lt;/em&gt; (tcp 22) y el puerto del servicio &lt;em&gt;HTTP&lt;/em&gt; (tcp 80), pondremos lo siguiente en la configuración del firewall (tras lo cual lo reiniciaremos):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/firehol/firehol.conf 
interface lxc0 world
    policy drop
    protection strong
    server ssh accept
    client all accept

router internal inface lxc0 outface lxc0
    policy drop
    client all accept
    group with dst not &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;UNROUTABLE_IPS&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
        route all accept
    group end
    group with dst 192.168.56.1
        route dns accept
    group end
    group with dst 192.168.56.10
        route ssh accept
        route http accept
    group end
root@lxc:~# service firehol restart

Broadcast message from systemd-journald@lxc &lt;span class="o"&gt;(&lt;/span&gt;Wed 2015-10-14 17:43:38 CEST&lt;span class="o"&gt;)&lt;/span&gt;:

FireHOL&lt;span class="o"&gt;[&lt;/span&gt;8690&lt;span class="o"&gt;]&lt;/span&gt;: Firewall has been stopped. Policy is ACCEPT EVERYTHING!


Message from syslogd@lxc at Oct &lt;span class="m"&gt;14&lt;/span&gt; 17:43:38 ...
 FireHOL&lt;span class="o"&gt;[&lt;/span&gt;8565&lt;span class="o"&gt;]&lt;/span&gt;: Firewall has been stopped. Policy is ACCEPT EVERYTHING!
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y solamente queda entrar al contenedor, por ejemplo por &lt;em&gt;SSH&lt;/em&gt; para instalar lo que se necesite; en este caso con un &lt;em&gt;nginx&lt;/em&gt; sería suficiente como demostración.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;ssh root@192.168.56.10
root@192.168.56.10&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s password: 

The programs included with the Debian GNU/Linux system are free software&lt;span class="p"&gt;;&lt;/span&gt;
the exact distribution terms &lt;span class="k"&gt;for&lt;/span&gt; each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
root@webserver:~# apt-get install nginx-light
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias... Hecho
Se instalarán los siguientes paquetes extras:
  nginx-common
Paquetes sugeridos:
  fcgiwrap nginx-doc ssl-cert
Se instalarán los siguientes paquetes NUEVOS:
  nginx-common nginx-light
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;2&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar &lt;span class="m"&gt;439&lt;/span&gt; kB de archivos.
Se utilizarán 1.040 kB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
Configurando nginx-common &lt;span class="o"&gt;(&lt;/span&gt;1.6.2-5&lt;span class="o"&gt;)&lt;/span&gt; ...
Configurando nginx-light &lt;span class="o"&gt;(&lt;/span&gt;1.6.2-5&lt;span class="o"&gt;)&lt;/span&gt; ...
Procesando disparadores para systemd &lt;span class="o"&gt;(&lt;/span&gt;215-17+deb8u2&lt;span class="o"&gt;)&lt;/span&gt; ...
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto ya tenemos nuestro contenedor en marcha y ofreciendo servicios en nuestra red local de forma segura.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="lxc"></category><category term="bridge"></category><category term="firehol"></category></entry></feed>