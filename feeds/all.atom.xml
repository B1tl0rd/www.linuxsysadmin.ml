<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Linux Sysadmin</title><link href="http://www.linuxsysadmin.tk/" rel="alternate"></link><link href="http://www.linuxsysadmin.tk/feeds/all.atom.xml" rel="self"></link><id>http://www.linuxsysadmin.tk/</id><updated>2015-11-02T14:00:00+01:00</updated><entry><title>Liberando memoria caché</title><link href="http://www.linuxsysadmin.tk/2015/11/liberando-memoria-cache.html" rel="alternate"></link><updated>2015-11-02T14:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-11-02:2015/11/liberando-memoria-cache.html</id><summary type="html">&lt;p&gt;A veces nos encontramos que nuestro sistema linux parece tener la
memoria &lt;em&gt;virtual&lt;/em&gt; ocupada, cuando no tenemos nada de memoria &lt;em&gt;RSS&lt;/em&gt;;
esto no es un problema, ya que por la forma de funcionar del
&lt;em&gt;memory manager&lt;/em&gt; de linux, se conserva "por si acaso" y se libera
cuando realmente se necesita.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;free -m
             total       used       free     shared    buffers     cached
Mem:          &lt;span class="m"&gt;3858&lt;/span&gt;       &lt;span class="m"&gt;3226&lt;/span&gt;        &lt;span class="m"&gt;632&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;        &lt;span class="m"&gt;114&lt;/span&gt;       2545
-/+ buffers/cache:        &lt;span class="m"&gt;566&lt;/span&gt;       3291
Swap:         &lt;span class="m"&gt;2381&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;       2381
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sin embargo este detalle nos puede resultar molesto y puede que queramos
&lt;strong&gt;liberar&lt;/strong&gt; esa memoria de verdad, por ejemplo, para comparar memoria
real ocupada por el sistema o sencillamente porque así lo queremos.&lt;/p&gt;
&lt;p&gt;En este caso no tenemos mas remedio que solicitar el &lt;em&gt;memory manager&lt;/em&gt;
que la libere, escribiendo en el fichero de control habilitado para ello,
de acuerdo a la &lt;a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt"&gt;documentación del &lt;em&gt;kernel&lt;/em&gt; de linux&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;drop_caches

Writing to this will cause the kernel to drop clean caches, as well as
reclaimable slab objects like dentries and inodes.  Once dropped, their
memory becomes free.

To free pagecache:
    &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &amp;gt; /proc/sys/vm/drop_caches
To free reclaimable slab objects &lt;span class="o"&gt;(&lt;/span&gt;includes dentries and inodes&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt; &amp;gt; /proc/sys/vm/drop_caches
To free slab objects and pagecache:
    &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt; &amp;gt; /proc/sys/vm/drop_caches

This is a non-destructive operation and will not free any dirty objects.
To increase the number of objects freed by this operation, the user may run
&lt;span class="sb"&gt;`&lt;/span&gt;sync&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; prior to writing to /proc/sys/vm/drop_caches.  This will minimize the
number of dirty objects on the system and create more candidates to be
dropped.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Este fichero viene por defecto con permisos de escritura solamente para
el usuario &lt;strong&gt;root&lt;/strong&gt; y no se puede escribir sin el mismo. Como no queremos
trabajar con el usuario &lt;strong&gt;root&lt;/strong&gt;, vamos a usar el comando &lt;em&gt;sudo&lt;/em&gt; con un
usuario normal:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;sudo bash -c &lt;span class="s2"&gt;&amp;quot;echo 3 &amp;gt; /proc/sys/vm/drop_caches&amp;quot;&lt;/span&gt;
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Alternativamente, podemos utilizar el comando &lt;em&gt;tee&lt;/em&gt; para realizar la
misma operación, sin el envoltorio de &lt;em&gt;bash&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sudo tee /proc/sys/vm/drop_caches
3
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y finalmente nuestra memoria queda vacía de todo aquello que no era
indispensable para la ejecución del sistema.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;free -m
             total       used       free     shared    buffers     cached
Mem:          &lt;span class="m"&gt;3858&lt;/span&gt;        &lt;span class="m"&gt;752&lt;/span&gt;       &lt;span class="m"&gt;3105&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;          &lt;span class="m"&gt;2&lt;/span&gt;        207
-/+ buffers/cache:        &lt;span class="m"&gt;542&lt;/span&gt;       3315
Swap:         &lt;span class="m"&gt;2381&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;       2381
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;¡Acabamos de liberar 2 gigabytes de memoria!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CUIDADO&lt;/strong&gt;: Esta operación puede afectar el rendimiento puntual del
sistema, ya que en caso de volver a necesitar la información &lt;em&gt;cacheada&lt;/em&gt;,
deberá volver a recargar la memoria, probablemente desde disco.&lt;/p&gt;</summary><category term="linux"></category><category term="kernel"></category><category term="memory manager"></category><category term="drop caches"></category></entry><entry><title>Ocultando puertos con port knocking</title><link href="http://www.linuxsysadmin.tk/2015/10/ocultando-puertos-con-port-knocking.html" rel="alternate"></link><updated>2015-10-29T11:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-10-29:2015/10/ocultando-puertos-con-port-knocking.html</id><summary type="html">&lt;p&gt;En este artículo vamos a enseñar como ocultar un puerto tras el firewall,
de forma que solamente se abra tras utilizar el protocolo &lt;em&gt;port knocking&lt;/em&gt;.
Las tecnologías usadas van a ser &lt;em&gt;firehol&lt;/em&gt; como firewall y el demonio
&lt;em&gt;knockd&lt;/em&gt; ocultando el &lt;em&gt;SSH&lt;/em&gt;, aunque vamos a permitir acceder al puerto
de HTTP.&lt;/p&gt;
&lt;p&gt;El protocolo de &lt;em&gt;port knocking&lt;/em&gt; es un sistema en el que para abrir la
conectividad en un puerto se debe primero abrir una secuencia concreta
a otros puertos, sean &lt;em&gt;TCP&lt;/em&gt; o &lt;em&gt;UDP&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Para conseguir este objetivo, se van a usar las siguientes tecnologías:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Debian jessie&lt;/strong&gt;: Como distribución base; podría ser cualquier otra&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Firehol&lt;/strong&gt;: Scripts para levantar un firewall basado en &lt;em&gt;iptables&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El hardware va a ser uno con capacidades limitadas, virtualizado en VirtualBox.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPUs&lt;/strong&gt;: 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria&lt;/strong&gt;: 256 Mb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Disco&lt;/strong&gt;: 2 Gb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Red&lt;/strong&gt;: 1 interfaz (&lt;em&gt;eth0&lt;/em&gt;) &lt;em&gt;host-only&lt;/em&gt; o &lt;em&gt;bridged&lt;/em&gt; con IP fija&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La instalación base es una &lt;em&gt;Debian&lt;/em&gt; mínima instalada con el CD netinstall,
con todo desmarcado y con el servidor de &lt;em&gt;SSH&lt;/em&gt; previamente instalado.&lt;/p&gt;
&lt;h2&gt;Instalación del servidor&lt;/h2&gt;
&lt;p&gt;Para empezar, vamos a instalar los dos servicios implicados:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# apt-get install firehol knockd
...
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Configuramos las reglas del firewall, de acuerdo a la documentación
relacionada con &lt;em&gt;port knocking&lt;/em&gt;. Se define un nivel de protección máximo,
ya que se trata de la interfaz que deberá estar accesible desde internet;
esto nos evita la mayoría de ataques conocidos en la capa 3 y 4.&lt;/p&gt;
&lt;p&gt;En cuanto a las conectividad, vamos a permitir que este servidor acceda
a servicios &lt;em&gt;DNS&lt;/em&gt; y &lt;em&gt;HTTP&lt;/em&gt;, que es lo justo para actualizarse. Como
servidor vamos a permitir el acceso a &lt;em&gt;HTTP&lt;/em&gt; (ya que en el ejemplo, esta
máquina va a servir como servidor &lt;em&gt;HTTP&lt;/em&gt;) y a &lt;em&gt;SSH&lt;/em&gt; siempre y cuando se
cumpla con el protocolo de seguridad.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/firehol/firehol.conf 
version 5

interface any world
    protection strong
    client &lt;span class="s2"&gt;&amp;quot;dns http&amp;quot;&lt;/span&gt; accept
    server http accept
    server ssh accept with knock hidden
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Acto seguido vamos a definir las reglas para que se abra el &lt;em&gt;knock hidden&lt;/em&gt;
(que corresponde con el puerto &lt;em&gt;SSH&lt;/em&gt;) si se completa la secuencia de &lt;em&gt;knock&lt;/em&gt;.
En este caso concreto, se indica una secuencia de los puertos &lt;em&gt;TCP&lt;/em&gt; 123,
456 y 789; aunque es posible definir puertos &lt;em&gt;UDP&lt;/em&gt;, dejamos sin indicarlo,
que nos los va a definir como &lt;em&gt;TCP&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Como medida de seguridad vamos a indicar un tiempo máximo de 10 segundos
para completar la secuencia de &lt;em&gt;knock&lt;/em&gt; y un autocierre del puerto a los
5 segundos (aunque firehol va a permitir las conexiones que se hayan
establecido en esos 5 segundos).&lt;/p&gt;
&lt;p&gt;Es especialmente interesante ver que la regla incluye la dirección
origen, con lo que la apertura de puerto solo será visible desde la
máquina que completó la secuencia de &lt;em&gt;knock&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/knockd.conf 
&lt;span class="o"&gt;[&lt;/span&gt;options&lt;span class="o"&gt;]&lt;/span&gt;
    UseSyslog

&lt;span class="o"&gt;[&lt;/span&gt;SSH&lt;span class="o"&gt;]&lt;/span&gt;
    &lt;span class="nv"&gt;sequence&lt;/span&gt;      &lt;span class="o"&gt;=&lt;/span&gt; 123,456,789
    &lt;span class="nv"&gt;seq_timeout&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; 10
    &lt;span class="nv"&gt;start_command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; iptables -A knock_hidden -s %IP% -j ACCEPT
    &lt;span class="nv"&gt;cmd_timeout&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; 5
    &lt;span class="nv"&gt;stop_command&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; iptables -D knock_hidden -s %IP% -j ACCEPT
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como medida de seguridad, &lt;em&gt;Debian&lt;/em&gt; tiene una protección para levantar
ambos servicios, así que tenemos que indicarle que queremos que se
puedan levantar, editando otros ficheros de configuración.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/default/knockd 
...
&lt;span class="nv"&gt;START_KNOCKD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1
...
root@server:~# cat /etc/default/firehol 
...
&lt;span class="nv"&gt;START_FIREHOL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;YES
...
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente podemos levantar los servicios de &lt;em&gt;port knocking&lt;/em&gt; y de
&lt;em&gt;firewall&lt;/em&gt;, usando las herramientas estándares que nos ofrece la distribución.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# service knockd restart
root@server:~# service firehol restart
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Comprobación de funcionamiento&lt;/h2&gt;
&lt;p&gt;Para comprobar el funcionamiento basta con comprobar que el puerto está
normalmente cerrado. Personalmente he usado &lt;em&gt;nmap&lt;/em&gt;, aunque se podría usar
&lt;em&gt;netcat&lt;/em&gt; o &lt;em&gt;telnet&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;nmap -PN 192.168.56.3 -p 22

Starting Nmap 5.21 &lt;span class="o"&gt;(&lt;/span&gt; http://nmap.org &lt;span class="o"&gt;)&lt;/span&gt; at 2015-10-28 17:33 CET
Nmap scan report &lt;span class="k"&gt;for&lt;/span&gt; server &lt;span class="o"&gt;(&lt;/span&gt;192.168.56.3&lt;span class="o"&gt;)&lt;/span&gt;
Host is up.
PORT   STATE    SERVICE
22/tcp filtered ssh

Nmap &lt;span class="k"&gt;done&lt;/span&gt;: &lt;span class="m"&gt;1&lt;/span&gt; IP address &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; host up&lt;span class="o"&gt;)&lt;/span&gt; scanned in 2.13 seconds
gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vemos que sale &lt;strong&gt;filtered&lt;/strong&gt;, que significa que el firewall lo está
bloqueando. Ahora vamos a lanzar la secuencia de &lt;em&gt;knock&lt;/em&gt; usando el
helper &lt;strong&gt;knock&lt;/strong&gt;, que en &lt;em&gt;Debian&lt;/em&gt; se encuentra en el mismo paquete
&lt;em&gt;knockd&lt;/em&gt;. Acto seguido, el puerto de &lt;em&gt;SSH&lt;/em&gt; queda abierto (en otras
palabras: escuchando). Ahora sería posible iniciar sesión por &lt;em&gt;SSH&lt;/em&gt; en
la máquina.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;knock 192.168.56.3 &lt;span class="m"&gt;123&lt;/span&gt; &lt;span class="m"&gt;456&lt;/span&gt; 789
gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;nmap -PN 192.168.56.3 -p 22

Starting Nmap 5.21 &lt;span class="o"&gt;(&lt;/span&gt; http://nmap.org &lt;span class="o"&gt;)&lt;/span&gt; at 2015-10-28 17:34 CET
Nmap scan report &lt;span class="k"&gt;for&lt;/span&gt; server &lt;span class="o"&gt;(&lt;/span&gt;192.168.56.3&lt;span class="o"&gt;)&lt;/span&gt;
Host is up &lt;span class="o"&gt;(&lt;/span&gt;0.0011s latency&lt;span class="o"&gt;)&lt;/span&gt;.
PORT   STATE SERVICE
22/tcp open  ssh

Nmap &lt;span class="k"&gt;done&lt;/span&gt;: &lt;span class="m"&gt;1&lt;/span&gt; IP address &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; host up&lt;span class="o"&gt;)&lt;/span&gt; scanned in 0.07 seconds
gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente comprobamos que, transcurridos los 5 segundos configurados,
el puerto vuelve a verse como &lt;strong&gt;filtrado&lt;/strong&gt;, con lo que no se puede
establecer nuevas conexiones en este puerto.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;nmap -PN 192.168.56.3 -p 22

Starting Nmap 5.21 &lt;span class="o"&gt;(&lt;/span&gt; http://nmap.org &lt;span class="o"&gt;)&lt;/span&gt; at 2015-10-28 17:34 CET
Nmap scan report &lt;span class="k"&gt;for&lt;/span&gt; server &lt;span class="o"&gt;(&lt;/span&gt;192.168.56.3&lt;span class="o"&gt;)&lt;/span&gt;
Host is up.
PORT   STATE    SERVICE
22/tcp filtered ssh

Nmap &lt;span class="k"&gt;done&lt;/span&gt;: &lt;span class="m"&gt;1&lt;/span&gt; IP address &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; host up&lt;span class="o"&gt;)&lt;/span&gt; scanned in 2.08 seconds
gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto queda protegido el acceso por &lt;em&gt;SSH&lt;/em&gt; a la máquina.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="firehol"></category><category term="port knocking"></category><category term="ssh"></category><category term="nmap"></category></entry><entry><title>Virtualizando contenedores LXC con acceso a la red local</title><link href="http://www.linuxsysadmin.tk/2015/10/virtualizando-contenedores-lxc-con-acceso-red-local.html" rel="alternate"></link><updated>2015-10-15T12:00:00+02:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-10-15:2015/10/virtualizando-contenedores-lxc-con-acceso-red-local.html</id><summary type="html">&lt;p&gt;En este tutorial se propone montar un servidor de contenedores LXC,
de forma que todos los contenedores queden expuestos a la misma red
que el servidor que los aloja. Para protegerlos de posibles ataques
de esta red, pondremos un firewall basado en &lt;em&gt;iptables&lt;/em&gt; mediante una
capa de abstracción llamada &lt;em&gt;firehol&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Para conseguir este objetivo, se van a usar las siguientes tecnologías:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Debian jessie&lt;/strong&gt;: Es necesario usar alguna distribución de linux para hacer funcionar LXC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LXC&lt;/strong&gt;: Tecnología que permite aislar los contenedores entre sí y darles entidad propia&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bridges&lt;/strong&gt;: Un bridge es en software el equivalente a un switch hardware&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Firehol&lt;/strong&gt;: Una serie de scripts para construir firewalls basados en iptables de forma fácil&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En cuanto a las capacidades hardware, vamos a hacer el tutorial con un equipo
de capacidades modestas, virtualizado en una máquina virtual VirtualBox.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPUs&lt;/strong&gt;: 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria&lt;/strong&gt;: 256 Mb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Disco&lt;/strong&gt;: 2 Gb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Red&lt;/strong&gt;: 1 interfaz (&lt;em&gt;eth0&lt;/em&gt;) &lt;em&gt;host-only&lt;/em&gt; o &lt;em&gt;bridged&lt;/em&gt; con IP fija&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Partimos de una distribución &lt;em&gt;Debian jessie&lt;/em&gt; instalada con un CD &lt;em&gt;netinstall&lt;/em&gt;
y con el único paquete instalado &lt;em&gt;openssh-server&lt;/em&gt;, para mi comodidad.&lt;/p&gt;
&lt;h2&gt;Preparar el servidor&lt;/h2&gt;
&lt;p&gt;El primer paso consiste en instalar las tecnologías usadas:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# apt-get install bridge-utils firehol lxc
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias       
Leyendo la información de estado... Hecho
...
Configurando lxc &lt;span class="o"&gt;(&lt;/span&gt;1:1.0.6-6+deb8u1&lt;span class="o"&gt;)&lt;/span&gt; ...
Configurando dh-python &lt;span class="o"&gt;(&lt;/span&gt;1.20141111-2&lt;span class="o"&gt;)&lt;/span&gt; ...
Procesando disparadores para libc-bin &lt;span class="o"&gt;(&lt;/span&gt;2.19-18+deb8u1&lt;span class="o"&gt;)&lt;/span&gt; ...
Procesando disparadores para systemd &lt;span class="o"&gt;(&lt;/span&gt;215-17+deb8u2&lt;span class="o"&gt;)&lt;/span&gt; ...
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Acto seguido debemos modificar la configuración de red, para que la interfaz
de red de la máquina represente la salida de todas las IPs que maneja el bridge
y para que el host obtenga una dirección de red en el bridge.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ANTES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/network/interfaces
&lt;span class="nb"&gt;source&lt;/span&gt; /etc/network/interfaces.d/*

auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
    address 192.168.56.4
    netmask 255.255.255.0
    gateway 192.168.56.1
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;DESPUES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/network/interfaces
&lt;span class="nb"&gt;source&lt;/span&gt; /etc/network/interfaces.d/*

auto lo
iface lo inet loopback

auto lxc0
iface lxc0 inet static
    bridge_ports eth0
    address 192.168.56.4
    netmask 255.255.255.0
    gateway 192.168.56.1
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En este punto es necesario reconfigurar la red, siendo especialmente importante
que &lt;em&gt;eth0&lt;/em&gt; quede sin dirección IP asignada (en mi caso tuve que reiniciar la máquina).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span class="m"&gt;65536&lt;/span&gt; qdisc noqueue state UNKNOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class="m"&gt;1500&lt;/span&gt; qdisc pfifo_fast master lxc0 state UP group default qlen 1000
    link/ether 08:00:27:e4:0a:60 brd ff:ff:ff:ff:ff:ff
3: lxc0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class="m"&gt;1500&lt;/span&gt; qdisc noqueue state UP group default 
    link/ether 08:00:27:e4:0a:60 brd ff:ff:ff:ff:ff:ff
    inet 192.168.56.4/24 brd 192.168.56.255 scope global lxc0
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fee4:a60/64 scope link 
       valid_lft forever preferred_lft forever
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El último paso consiste en activar el firewall con unas reglas básicas,
para proteger el equipo anfitrión de posibles ataques o intrusiones, dejando
solamente el acceso a SSH. Con firehol es posible combinar el demonio &lt;em&gt;knockd&lt;/em&gt;
para ocultar el puerto tras una secuencia de port knocking; en principio
sería suficiente con forzar la entrada SSH por claves RSA.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/firehol/firehol.conf 
interface lxc0 world
    policy drop
    protection strong
    server ssh accept
    client all accept
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hay que modificar otro fichero para permitir el inicio del firewall:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ANTES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# grep START /etc/default/firehol 
&lt;span class="c"&gt;#To enable firehol at startup set START_FIREHOL=YES&lt;/span&gt;
&lt;span class="nv"&gt;START_FIREHOL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;NO
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;DESPUES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# grep START /etc/default/firehol 
&lt;span class="c"&gt;#To enable firehol at startup set START_FIREHOL=YES&lt;/span&gt;
&lt;span class="nv"&gt;START_FIREHOL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;YES
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y para acabar, (re)iniciamos el servicio firehol.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# service firehol restart

Broadcast message from systemd-journald@lxc &lt;span class="o"&gt;(&lt;/span&gt;Wed 2015-10-14 16:59:30 CEST&lt;span class="o"&gt;)&lt;/span&gt;:

FireHOL&lt;span class="o"&gt;[&lt;/span&gt;620&lt;span class="o"&gt;]&lt;/span&gt;: Firewall has been stopped. Policy is ACCEPT EVERYTHING!


Message from syslogd@lxc at Oct &lt;span class="m"&gt;14&lt;/span&gt; 16:59:30 ...
 FireHOL&lt;span class="o"&gt;[&lt;/span&gt;493&lt;span class="o"&gt;]&lt;/span&gt;: Firewall has been stopped. Policy is ACCEPT EVERYTHING!
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creación de contenedores&lt;/h2&gt;
&lt;p&gt;La creación de contenedores pasa por usar las herramientas estándar
de la distribución, a lo solo tendremos que modificar algunas
configuraciones propias de nuestra red.&lt;/p&gt;
&lt;p&gt;Creamos un contenedor &lt;em&gt;webserver&lt;/em&gt; como demostración. La primera que se
crea es un poco lenta porque hace un &lt;em&gt;debootstrap&lt;/em&gt; de una distribución
debian estable para crear una cache en &lt;em&gt;/var/cache/lxc&lt;/em&gt;; las siguientes
se benefician de esta caché y solo la actualizan, acelerando el proceso.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# lxc-create -n webserver -t debian
debootstrap is /usr/sbin/debootstrap
Checking cache download in /var/cache/lxc/debian/rootfs-jessie-i386 ... 
Downloading debian minimal ...
...
I: Base system installed successfully.
Download complete.
Copying rootfs to /var/lib/lxc/webserver/rootfs...
...
Current default &lt;span class="nb"&gt;time &lt;/span&gt;zone: &lt;span class="s1"&gt;&amp;#39;Europe/Madrid&amp;#39;&lt;/span&gt;
Local &lt;span class="nb"&gt;time &lt;/span&gt;is now:      Wed Oct &lt;span class="m"&gt;14&lt;/span&gt; 17:26:37 CEST 2015.
Universal Time is now:  Wed Oct &lt;span class="m"&gt;14&lt;/span&gt; 15:26:37 UTC 2015.

Root password is &lt;span class="s1"&gt;&amp;#39;sFj7Jm9N&amp;#39;&lt;/span&gt;, please change !
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Acabada la generación del contenedor, vamos a configurarle algunos
parámetros; que tenga una interfaz &lt;em&gt;eth0&lt;/em&gt; activa y enchufada al bridge
&lt;em&gt;lxc0&lt;/em&gt;, y que el contenedor se autoinicie en cada reinicio del anfitrión.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /var/lib/lxc/webserver/config 
...
lxc.start.auto &lt;span class="o"&gt;=&lt;/span&gt; 1
lxc.network.type &lt;span class="o"&gt;=&lt;/span&gt; veth
lxc.network.flags &lt;span class="o"&gt;=&lt;/span&gt; up
lxc.network.link &lt;span class="o"&gt;=&lt;/span&gt; lxc0
lxc.network.name &lt;span class="o"&gt;=&lt;/span&gt; eth0
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y para que su interfaz de red sea funcional, vamos a configurarle una
dirección IP. Todo esto se hace en los ficheros habituales, teniendo
en cuenta que un contenedor es una jaula, y que esta se encuentra en
&lt;em&gt;/var/lib/lxc/webserver/rootfs/&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /var/lib/lxc/webserver/rootfs/etc/network/interfaces
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
    address 192.168.56.10
    netmask 255.255.255.0
    gateway 192.168.56.1
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El contenedor ya está funcional, y se puede levantar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# lxc-start -n webserver -d
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sin embargo, el firewall impide que se llegue al mismo; tendremos que
poner reglas para permitir el flujo de red hacia la nueva dirección IP
configurada para el contenedor. Esto se consigue con reglas de &lt;em&gt;forward&lt;/em&gt;
que entren por el bridge y salgan por el mismo hacia nuestro contenedor.&lt;/p&gt;
&lt;p&gt;Ya de paso habilitamos reglas para que todo lo que pase por el bridge
hacia internet se permita. Como particularidad de nuestra red, el
servidor anfitrión tiene un servidor DNS &lt;em&gt;dnsmasq&lt;/em&gt;; así que añadimos
también esa ruta.&lt;/p&gt;
&lt;p&gt;Por ejemplo, suponiendo que queremos habilitar el servicio &lt;em&gt;SSH&lt;/em&gt; (tcp 22)
y el puerto del servicio &lt;em&gt;HTTP&lt;/em&gt; (tcp 80), pondremos lo siguiente en la
configuración del firewall (tras lo cual lo reiniciaremos):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@lxc:~# cat /etc/firehol/firehol.conf 
interface lxc0 world
    policy drop
    protection strong
    server ssh accept
    client all accept

router internal inface lxc0 outface lxc0
    policy drop
    client all accept
    group with dst not &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;UNROUTABLE_IPS&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
        route all accept
    group end
    group with dst 192.168.56.1
        route dns accept
    group end
    group with dst 192.168.56.10
        route ssh accept
        route http accept
    group end
root@lxc:~# service firehol restart

Broadcast message from systemd-journald@lxc &lt;span class="o"&gt;(&lt;/span&gt;Wed 2015-10-14 17:43:38 CEST&lt;span class="o"&gt;)&lt;/span&gt;:

FireHOL&lt;span class="o"&gt;[&lt;/span&gt;8690&lt;span class="o"&gt;]&lt;/span&gt;: Firewall has been stopped. Policy is ACCEPT EVERYTHING!


Message from syslogd@lxc at Oct &lt;span class="m"&gt;14&lt;/span&gt; 17:43:38 ...
 FireHOL&lt;span class="o"&gt;[&lt;/span&gt;8565&lt;span class="o"&gt;]&lt;/span&gt;: Firewall has been stopped. Policy is ACCEPT EVERYTHING!
root@lxc:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y solamente queda entrar al contenedor, por ejemplo por &lt;em&gt;SSH&lt;/em&gt; para
instalar lo que se necesite; en este caso con un &lt;em&gt;nginx&lt;/em&gt; sería
suficiente como demostración.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@workstation:~&lt;span class="nv"&gt;$ &lt;/span&gt;ssh root@192.168.56.10
root@192.168.56.10&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s password: 

The programs included with the Debian GNU/Linux system are free software&lt;span class="p"&gt;;&lt;/span&gt;
the exact distribution terms &lt;span class="k"&gt;for&lt;/span&gt; each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
root@webserver:~# apt-get install nginx-light
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias... Hecho
Se instalarán los siguientes paquetes extras:
  nginx-common
Paquetes sugeridos:
  fcgiwrap nginx-doc ssl-cert
Se instalarán los siguientes paquetes NUEVOS:
  nginx-common nginx-light
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;2&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar &lt;span class="m"&gt;439&lt;/span&gt; kB de archivos.
Se utilizarán 1.040 kB de espacio de disco adicional después de esta operación.
¿Desea continuar? &lt;span class="o"&gt;[&lt;/span&gt;S/n&lt;span class="o"&gt;]&lt;/span&gt; s
...
Configurando nginx-common &lt;span class="o"&gt;(&lt;/span&gt;1.6.2-5&lt;span class="o"&gt;)&lt;/span&gt; ...
Configurando nginx-light &lt;span class="o"&gt;(&lt;/span&gt;1.6.2-5&lt;span class="o"&gt;)&lt;/span&gt; ...
Procesando disparadores para systemd &lt;span class="o"&gt;(&lt;/span&gt;215-17+deb8u2&lt;span class="o"&gt;)&lt;/span&gt; ...
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto ya tenemos nuestro contenedor en marcha y ofreciendo
servicios en nuestra red local de forma segura.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="lxc"></category><category term="bridge"></category><category term="firehol"></category></entry></feed>