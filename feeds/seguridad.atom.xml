<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Linux Sysadmin</title><link href="http://www.linuxsysadmin.tk/" rel="alternate"></link><link href="http://www.linuxsysadmin.tk/feeds/seguridad.atom.xml" rel="self"></link><id>http://www.linuxsysadmin.tk/</id><updated>2016-09-19T08:00:00+02:00</updated><entry><title>Crear jaulas de forma fácil basadas en Debian y Ubuntu con debootstrap</title><link href="http://www.linuxsysadmin.tk/2016/09/crear-jaulas-de-forma-facil-basadas-en-debian-y-ubuntu-con-debootstrap.html" rel="alternate"></link><published>2016-09-19T08:00:00+02:00</published><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-09-19:2016/09/crear-jaulas-de-forma-facil-basadas-en-debian-y-ubuntu-con-debootstrap.html</id><summary type="html">&lt;p&gt;Cuando creamos jaulas nos enfrentamos siempre al mismo dilema: usar una imagen de dudoso origen o perder nuestro tiempo investigando y buscando librerías que falten. Sin embargo, hay una forma mejor, que es descargar un sistema básico con herramientas oficiales que nos van a dar hasta un gestor de paquetes.&lt;/p&gt;
&lt;p&gt;Hay algunas distribuciones que nos ofrecen herramientas para descargar un sistema base a partir de sus repositorios, y que a menudo son la base de sus propias instalaciones. En el caso de las distribuciones &lt;strong&gt;Debian&lt;/strong&gt; y derivadas (&lt;strong&gt;Ubuntu&lt;/strong&gt;, &lt;strong&gt;Knoppix&lt;/strong&gt;, ...) esta herramienta se llama &lt;strong&gt;debootstrap&lt;/strong&gt; y de uso bastante sencillo.&lt;/p&gt;
&lt;p&gt;De hecho, otras herramientas parten de estas herramientas para usar como base para las suyas. Un ejemplo serían las imágenes de &lt;strong&gt;docker&lt;/strong&gt;, que no son mas que el resultado de la ejecución de &lt;strong&gt;debootstrap&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Este tutorial se ha ejecutado en un contenedor &lt;strong&gt;docker&lt;/strong&gt; de usar y tirar, para no polucionar mi máquina con herramientas innecesarias. También se asume que se dispone de la herramienta instalada que, por si no la tuvierais, se instala así:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# apt-get install debootstrap
Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following extra packages will be installed:
  ca-certificates libffi6 libgmp10 libgnutls-deb0-28 libhogweed2 libicu52 libidn11 libnettle4 libp11-kit0 libpsl0 libssl1.0.0 libtasn1-6 openssl wget
Suggested packages:
  gnutls-bin
The following NEW packages will be installed:
  ca-certificates debootstrap libffi6 libgmp10 libgnutls-deb0-28 libhogweed2 libicu52 libidn11 libnettle4 libp11-kit0 libpsl0 libssl1.0.0 libtasn1-6 openssl wget
&lt;span class="m"&gt;0&lt;/span&gt; upgraded, &lt;span class="m"&gt;15&lt;/span&gt; newly installed, &lt;span class="m"&gt;0&lt;/span&gt; to remove and &lt;span class="m"&gt;0&lt;/span&gt; not upgraded.
Need to get 10.8 MB of archives.
After this operation, 39.1 MB of additional disk space will be used.
Do you want to &lt;span class="k"&gt;continue&lt;/span&gt;? &lt;span class="o"&gt;[&lt;/span&gt;Y/n&lt;span class="o"&gt;]&lt;/span&gt; y
...
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esta herramienta viene acompañada de los diferentes &lt;em&gt;scripts&lt;/em&gt; que conocen la forma de llegar al resultado deseado. Cabe remarcar que cuando mas reciente es la versión, mas &lt;em&gt;scripts&lt;/em&gt; lleva incorporados. En mi caso, usé &lt;strong&gt;Debian Jessie&lt;/strong&gt;, que como podéis ver, sabe construir &lt;strong&gt;Ubuntu 9.10 (Karmic Koala)&lt;/strong&gt;, pero no &lt;strong&gt;Ubuntu 16.04 (Xenial Xerus)&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# dpkg -L debootstrap &lt;span class="p"&gt;|&lt;/span&gt; grep scripts
/usr/share/debootstrap/scripts
/usr/share/debootstrap/scripts/hoary
/usr/share/debootstrap/scripts/woody.buildd
/usr/share/debootstrap/scripts/feisty
/usr/share/debootstrap/scripts/warty.buildd
/usr/share/debootstrap/scripts/potato
/usr/share/debootstrap/scripts/sarge.fakechroot
/usr/share/debootstrap/scripts/hoary.buildd
/usr/share/debootstrap/scripts/gutsy
/usr/share/debootstrap/scripts/warty
/usr/share/debootstrap/scripts/sarge
/usr/share/debootstrap/scripts/sid
/usr/share/debootstrap/scripts/sarge.buildd
/usr/share/debootstrap/scripts/edgy
/usr/share/debootstrap/scripts/dapper
/usr/share/debootstrap/scripts/breezy
/usr/share/debootstrap/scripts/woody
/usr/share/debootstrap/scripts/saucy
/usr/share/debootstrap/scripts/testing
/usr/share/debootstrap/scripts/unstable
/usr/share/debootstrap/scripts/oneiric
/usr/share/debootstrap/scripts/stretch
/usr/share/debootstrap/scripts/stable
/usr/share/debootstrap/scripts/etch-m68k
/usr/share/debootstrap/scripts/maverick
/usr/share/debootstrap/scripts/raring
/usr/share/debootstrap/scripts/lenny
/usr/share/debootstrap/scripts/hardy
/usr/share/debootstrap/scripts/wheezy
/usr/share/debootstrap/scripts/squeeze
/usr/share/debootstrap/scripts/etch
/usr/share/debootstrap/scripts/oldstable
/usr/share/debootstrap/scripts/precise
/usr/share/debootstrap/scripts/trusty
/usr/share/debootstrap/scripts/utopic
/usr/share/debootstrap/scripts/natty
/usr/share/debootstrap/scripts/jaunty
/usr/share/debootstrap/scripts/jessie
/usr/share/debootstrap/scripts/lucid
/usr/share/debootstrap/scripts/intrepid
/usr/share/debootstrap/scripts/quantal
/usr/share/debootstrap/scripts/karmic
/usr/share/debootstrap/scripts/vivid
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;TRUCO&lt;/strong&gt;: Para ejecutar &lt;strong&gt;debootstrap&lt;/strong&gt; en un contenedor &lt;strong&gt;docker&lt;/strong&gt; (de usar y tirar, por ejemplo), hace falta correr el contenedor con un &lt;em&gt;flag&lt;/em&gt; especial: &lt;em&gt;--privileged&lt;/em&gt;. Esto es debido a que &lt;strong&gt;debootstrap&lt;/strong&gt; intenta montar el sistema de ficheros &lt;em&gt;/proc&lt;/em&gt; y no dispone de permisos para hacerlo en circunstancias normales.&lt;/p&gt;
&lt;h2&gt;Un ejemplo de uso básico&lt;/h2&gt;
&lt;p&gt;A priori, este comando solo necesita saber la distribución que queremos descargar y la carpeta donde lo queremos hacer.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# debootstrap jessie jail
...
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Podemos contar con varios &lt;em&gt;flags&lt;/em&gt; que van a modificar ligeramente su comportamiento. A lo largo del tutorial vamos a utilizar el &lt;em&gt;flag --variant=minbase&lt;/em&gt; que va a descargar menos paquetes todavía, acelerando su ejecución. Yo suelo usar siempre este &lt;em&gt;flag&lt;/em&gt;, porque al instalar con &lt;em&gt;apt-get&lt;/em&gt; otros paquetes, ya se incorporarían las dependencias.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# debootstrap --variant&lt;span class="o"&gt;=&lt;/span&gt;minbase jessie jail 
I: Retrieving Release 
I: Retrieving Release.gpg 
I: Checking Release signature
I: Valid Release signature &lt;span class="o"&gt;(&lt;/span&gt;key id 75DDC3C4A499F1A18CB5F3C8CBF8D6FD518E17E1&lt;span class="o"&gt;)&lt;/span&gt;
I: Retrieving Packages 
I: Validating Packages 
I: Resolving dependencies of required packages...
I: Resolving dependencies of base packages...
I: Found additional required dependencies: acl adduser dmsetup insserv libaudit-common libaudit1 libbz2-1.0 libcap2 libcap2-bin libcryptsetup4 libdb5.3 libdebconfclient0 libdevmapper1.02.1 libgcrypt20 libgpg-error0 libkmod2 libncursesw5 libprocps3 libsemanage-common libsemanage1 libslang2 libsystemd0 libudev1 libustr-1.0-1 procps systemd systemd-sysv udev 
I: Found additional base dependencies: debian-archive-keyring gnupg gpgv libapt-pkg4.12 libreadline6 libstdc++6 libusb-0.1-4 readline-common 
I: Checking component main on http://ftp.us.debian.org/debian...
...
I: Base system installed successfully.
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Tras ejecutar el comando, podemos ver que tenemos una carpeta &lt;em&gt;jail/&lt;/em&gt; en donde podemos encontrar un sistema &lt;strong&gt;Linux&lt;/strong&gt; bastante estándar, que corresponde con la distribución &lt;strong&gt;Debian Jessie&lt;/strong&gt; pedida.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# ls -1 jail/
bin
boot
dev
etc
home
lib
lib64
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vemos que la instalación es bastante básica y tiene un tamaño reducido, ya que solo lleva lo mas básico, sin &lt;em&gt;kernel&lt;/em&gt; y sin &lt;em&gt;bootloader&lt;/em&gt;. Por no llevar, no lleva ni &lt;strong&gt;nano&lt;/strong&gt; ni &lt;strong&gt;vi&lt;/strong&gt;, por ejemplo. Usad &lt;em&gt;apt-get&lt;/em&gt; para instalar los paquetes que veáis necesarios, una vez dentro de la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# du -sh jail/
202M    jail/
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;De hecho, mucho de lo que hay en la jaula son ficheros de &lt;em&gt;apt-get&lt;/em&gt;, que sirven para acelerar la operación normal de estas herramientas, pero que resultan inútiles si queremos una imagen mínima. Son ficheros que vuelven a aparecer con el uso normal de &lt;em&gt;apt-get&lt;/em&gt; y que van cambiando con el tiempo. Como se trata de la caché de paquetes descargados y de los índices de los repositorios, nos los cargamos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# chroot jail/ apt-get clean
root@8e7b4f301aa0:~# rm -rf jail/var/lib/apt/lists/*
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esto libera un 33% del espacio ocupado. Ahora sería un buen momento para sacar un fichero comprimido para guardar la imagen.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# du -sh jail/
136M    jail/
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;TRUCO&lt;/strong&gt;: Si la carpeta &lt;em&gt;jail/&lt;/em&gt; estuviera mapeada a un dispositivo tendríamos un disco de sistema operativo casi completo. Bastaría con instalarle un &lt;em&gt;kernel&lt;/em&gt; y un &lt;em&gt;bootloader&lt;/em&gt; para tener un sistema operativo funcional.&lt;/p&gt;
&lt;h2&gt;Haciendo un fichero comprimido de paquetes descargados&lt;/h2&gt;
&lt;p&gt;Si la idea de ir copiando la jaula anterior no nos convence, podemos tener los paquetes &lt;em&gt;.deb&lt;/em&gt; descargados y comprimidos en un fichero &lt;em&gt;.tar.gz&lt;/em&gt;, para no tener que descargar todos los paquetes cada vez. Basta con poner el &lt;em&gt;flag --make-tarball&lt;/em&gt;. En este caso, la carpeta de descarga es una carpeta temporal, que va a ser eliminada al terminar.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# debootstrap --variant&lt;span class="o"&gt;=&lt;/span&gt;minbase --make-tarball&lt;span class="o"&gt;=&lt;/span&gt;debian-jessie.tgz jessie temporal
I: Retrieving Release 
I: Retrieving Release.gpg 
I: Checking Release signature
I: Valid Release signature &lt;span class="o"&gt;(&lt;/span&gt;key id 75DDC3C4A499F1A18CB5F3C8CBF8D6FD518E17E1&lt;span class="o"&gt;)&lt;/span&gt;
I: Retrieving Packages 
I: Validating Packages 
I: Resolving dependencies of required packages...
I: Resolving dependencies of base packages...
I: Found additional required dependencies: acl adduser dmsetup insserv libaudit-common libaudit1 libbz2-1.0 libcap2 libcap2-bin libcryptsetup4 libdb5.3 libdebconfclient0 libdevmapper1.02.1 libgcrypt20 libgpg-error0 libkmod2 libncursesw5 libprocps3 libsemanage-common libsemanage1 libslang2 libsystemd0 libudev1 libustr-1.0-1 procps systemd systemd-sysv udev 
I: Found additional base dependencies: debian-archive-keyring gnupg gpgv libapt-pkg4.12 libreadline6 libstdc++6 libusb-0.1-4 readline-common 
I: Checking component main on http://ftp.us.debian.org/debian...
...
I: Deleting target directory
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente obtenemos nuestro fichero comprimido, que es mas fácil de copiar a diferentes máquinas, por tamaño y por velocidad de transmisión.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# du -sh debian-jessie.tgz 
43M debian-jessie.tgz
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Este fichero contiene solamente los ficheros que descartamos al final del proceso, que son los &lt;em&gt;.deb&lt;/em&gt; ya instalados y los índices del repositorio.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# tar tf debian-jessie.tgz &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="se"&gt;\/&lt;/span&gt;$
var/lib/apt/
var/lib/apt/lists/
var/lib/apt/lists/partial/
var/cache/apt/
var/cache/apt/archives/
var/cache/apt/archives/partial/
root@8e7b4f301aa0:~# tar tf debian-jessie.tgz &lt;span class="p"&gt;|&lt;/span&gt; head
var/lib/apt/
var/lib/apt/lists/
var/lib/apt/lists/debootstrap.invalid_dists_jessie_main_binary-amd64_Packages
var/lib/apt/lists/debootstrap.invalid_dists_jessie_Release.gpg
var/lib/apt/lists/partial/
var/lib/apt/lists/debootstrap.invalid_dists_jessie_Release
var/cache/apt/
var/cache/apt/archives/
var/cache/apt/archives/libbz2-1.0_1.0.6-7+b3_amd64.deb
var/cache/apt/archives/bash_4.3-11+b1_amd64.deb
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cuando queramos utilizar este fichero comprimido para crear una jaula, basta con indicar que use los paquetes en el fichero, mediante el &lt;em&gt;flag --unpack-tarball&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# debootstrap --variant&lt;span class="o"&gt;=&lt;/span&gt;minbase --unpack-tarball&lt;span class="o"&gt;=&lt;/span&gt;/root/debian-jessie.tgz jessie rootfs
I: Retrieving Release 
I: Retrieving Release.gpg 
I: Checking Release signature
I: Valid Release signature &lt;span class="o"&gt;(&lt;/span&gt;key id 75DDC3C4A499F1A18CB5F3C8CBF8D6FD518E17E1&lt;span class="o"&gt;)&lt;/span&gt;
I: Validating Packages 
I: Resolving dependencies of required packages...
I: Resolving dependencies of base packages...
I: Found additional required dependencies: acl adduser dmsetup insserv libaudit-common libaudit1 libbz2-1.0 libcap2 libcap2-bin libcryptsetup4 libdb5.3 libdebconfclient0 libdevmapper1.02.1 libgcrypt20 libgpg-error0 libkmod2 libncursesw5 libprocps3 libsemanage-common libsemanage1 libslang2 libsystemd0 libudev1 libustr-1.0-1 procps systemd systemd-sysv udev 
I: Found additional base dependencies: debian-archive-keyring gnupg gpgv libapt-pkg4.12 libreadline6 libstdc++6 libusb-0.1-4 readline-common 
I: Checking component main on http://ftp.us.debian.org/debian...
...
I: Base system installed successfully.
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Este proceso sigue necesitando de conexión a internet, porque consulta al índice del repositorio para saber que paquetes necesita. Sin embargo, estos paquetes ya los tenemos, con lo que es un proceso bastante mas rápido y menos estresante para nuestra red.&lt;/p&gt;
&lt;h2&gt;Construyendo una jaula para otra máquina&lt;/h2&gt;
&lt;p&gt;Supongamos ahora que tenemos una máquina que es de otra arquitectura y le descargamos el sistema de ficheros en nuestro local. Normalmente no sería posible ya que podemos descargar los ficheros &lt;em&gt;.deb&lt;/em&gt; de la otra arquitectura, pero no podemos configurar los paquetes porque para esto se necesita ejecutar binarios que, por supuesto, no funcionan en nuestro local.&lt;/p&gt;
&lt;p&gt;El comando &lt;strong&gt;debootstrap&lt;/strong&gt; también nos permite esto. La idea está en "dejar listo" una estructura, de forma que solo haga falta copiar en destino y configurar los paquetes. Esto es tan fácil como indicar el &lt;em&gt;flag --foreign&lt;/em&gt;, y adicionalmente, indicar la arquitectura deseada con &lt;em&gt;--arch&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# debootstrap --variant&lt;span class="o"&gt;=&lt;/span&gt;minbase --arch&lt;span class="o"&gt;=&lt;/span&gt;armhf --foreign jessie rootfs
I: Retrieving Release 
I: Retrieving Release.gpg 
I: Checking Release signature
I: Valid Release signature &lt;span class="o"&gt;(&lt;/span&gt;key id 75DDC3C4A499F1A18CB5F3C8CBF8D6FD518E17E1&lt;span class="o"&gt;)&lt;/span&gt;
I: Retrieving Packages 
I: Validating Packages 
I: Resolving dependencies of required packages...
I: Resolving dependencies of base packages...
I: Found additional required dependencies: acl adduser dmsetup insserv libaudit-common libaudit1 libbz2-1.0 libcap2 libcap2-bin libcryptsetup4 libdb5.3 libdebconfclient0 libdevmapper1.02.1 libgcrypt20 libgpg-error0 libkmod2 libncursesw5 libprocps3 libsemanage-common libsemanage1 libslang2 libsystemd0 libudev1 libustr-1.0-1 procps systemd systemd-sysv udev 
I: Found additional base dependencies: debian-archive-keyring gnupg gpgv libapt-pkg4.12 libreadline6 libstdc++6 libusb-0.1-4 readline-common 
I: Checking component main on http://ftp.us.debian.org/debian...
...
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esto nos deja un sistema "a medias", con un &lt;em&gt;script&lt;/em&gt; que nos permita continuar a partir de este punto, una vez hayamos copiado la estructura generada en destino.&lt;/p&gt;
&lt;p&gt;Si miramos el sistema de ficheros, veremos que se trata de la jaula casi acabada, con una carpeta &lt;em&gt;debootstrap/&lt;/em&gt; que contiene lo necesario para continuar, incluido el &lt;em&gt;script&lt;/em&gt; llamado &lt;em&gt;debootstrap&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@8e7b4f301aa0:~# ls rootfs/debootstrap/
arch  base  debootstrap  debootstrap.log  debpaths  devices.tar.gz  functions  required  suite  suite-script  variant
root@8e7b4f301aa0:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para continuar el proceso en la nueva máquina, tenemos que copiar en ella toda la carpeta &lt;em&gt;rootfs/&lt;/em&gt;. Solo nos quedará usar &lt;em&gt;chroot&lt;/em&gt; para entrar en la jaula y ejecutar el &lt;em&gt;script&lt;/em&gt; para configurar lo que falte y eliminar las herramientas intermedias. Este proceso no requiere conexión a internet.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@odroid:~# chroot rootfs/
&lt;span class="c1"&gt;# /debootstrap/debootstrap --second-stage&lt;/span&gt;
I: Keyring file not available at /usr/share/keyrings/debian-archive-keyring.gpg&lt;span class="p"&gt;;&lt;/span&gt; switching to https mirror https://mirrors.kernel.org/debian
I: Installing core packages...
I: Unpacking required packages...
...
I: Base system installed successfully.
&lt;span class="c1"&gt;# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y finalmente podemos disfrutar de nuestra jaula en la nueva máquina.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ls&lt;/span&gt;
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
&lt;span class="c1"&gt;# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category><category term="debian"></category><category term="ubuntu"></category><category term="debootstrap"></category><category term="jaula"></category></entry><entry><title>Reduciendo el tamaño de nuestros binarios con musl libc</title><link href="http://www.linuxsysadmin.tk/2016/05/reduciendo-el-tamano-de-nuestros-binarios-con-musl-libc.html" rel="alternate"></link><published>2016-05-16T13:00:00+02:00</published><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-05-16:2016/05/reduciendo-el-tamano-de-nuestros-binarios-con-musl-libc.html</id><summary type="html">&lt;p&gt;Cuando construimos jaulas, por el motivo que sea, vemos que no quedan pequeñas. El problema es el conjunto de librerías que hay que poner en el caso de los binarios &lt;em&gt;dinámicos&lt;/em&gt;, o el exceso de tamaño en el caso de los &lt;em&gt;estáticos&lt;/em&gt;. Cambiando la librería base, podemos reducir su tamaño.&lt;/p&gt;
&lt;p&gt;La mayoría de los binarios de un sistema &lt;em&gt;linux&lt;/em&gt; necesitan una librería llamada &lt;em&gt;libc&lt;/em&gt;. La que suelen poner en todas las distribuciones es la &lt;strong&gt;GNU libc&lt;/strong&gt;, que es compatible con todos los proyectos de software libre y no suele dar problemas.&lt;/p&gt;
&lt;p&gt;Sin embargo, no es la única; si tenemos un binario que se puede compilar con estas otras librerías, la reducción de tamaño suele ser importante. Esto no nos preocupa en un sistema "normal" porque el disco es barato, pero es frustrante cuando tenemos que cargar cientos de megas para poner solamente un par de servicios en una jaula.&lt;/p&gt;
&lt;p&gt;Así que vamos a crear una jaula usando &lt;strong&gt;musl libc&lt;/strong&gt; como demostración, para ver como se reducen la cantidad de librerías y el tamaño de la jaula.&lt;/p&gt;
&lt;h2&gt;El compilador que enlaza con musl libc&lt;/h2&gt;
&lt;p&gt;La librería de &lt;strong&gt;musl libc&lt;/strong&gt; puede usarse de dos formas: construir una &lt;em&gt;toolchain&lt;/em&gt; dedicada o usar un &lt;em&gt;wrapper&lt;/em&gt; de la que tengamos en el sistema. Como la primera merecería un artículo por sí misma, usaremos la segunda. Es digno de mención indicar que existen &lt;em&gt;toolchains&lt;/em&gt; prefabricadas.&lt;/p&gt;
&lt;p&gt;El procedimiento para instalar el &lt;em&gt;wrapper&lt;/em&gt; de &lt;strong&gt;musl libc&lt;/strong&gt; es relativamente simple; se trata del típico procedimiento &lt;em&gt;configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install&lt;/em&gt;. Para ello vamos a necesitar algunas herramientas:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# apt-get install wget gcc make
...
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nos descargamos la versión de &lt;strong&gt;musl libc&lt;/strong&gt; que queramos utilizar usando el comando &lt;em&gt;wget&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# wget https://www.musl-libc.org/releases/musl-1.1.14.tar.gz
...
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Descomprimimos el &lt;em&gt;tarball&lt;/em&gt; descargado y nos ponemos en la carpeta creada.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# tar xzf musl-1.1.14.tar.gz
root@musl:~# &lt;span class="nb"&gt;cd&lt;/span&gt; musl-1.1.14
root@musl:~/musl-1.1.14#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a configurar el paquete, con lo que se va a generar un &lt;em&gt;Makefile&lt;/em&gt; compatible con nuestro sistema. Es un buen momento para indicar la carpeta que va a contener el "compilador".&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~/musl-1.1.14# ./configure --prefix&lt;span class="o"&gt;=&lt;/span&gt;/opt/musl/
...
root@musl:~/musl-1.1.14#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Una vez obtenido el &lt;em&gt;Makefile&lt;/em&gt;, podemos construir el "compilador" con la orden &lt;em&gt;make&lt;/em&gt;. Si tenéis la suerte de contar con mas de un procesador, podéis acelerar este paso con el &lt;em&gt;flag&lt;/em&gt; &lt;strong&gt;-j2&lt;/strong&gt;, por ejemplo (serían dos threads); lo ideal poner el número de núcleos disponibles.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~/musl-1.1.14# make
...
root@musl:~/musl-1.1.14#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con los binarios construidos, los ponemos en su sitio con &lt;em&gt;make install&lt;/em&gt;. Puesto que indicamos un &lt;em&gt;prefix&lt;/em&gt; en el &lt;em&gt;configure&lt;/em&gt;, va a crear esa carpeta, creando en ella las carpetas necesarias (por ejemplo, &lt;em&gt;bin&lt;/em&gt; y &lt;em&gt;lib&lt;/em&gt;).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~/musl-1.1.14# make install
...
root@musl:~/musl-1.1.14#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cuando el &lt;em&gt;make install&lt;/em&gt; haya funcionado, podemos salir de la carpeta de fuentes y eliminarla. En este caso, lo importante ha quedado en &lt;em&gt;/opt/musl/&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~/musl-1.1.14# &lt;span class="nb"&gt;cd&lt;/span&gt; ..
root@musl:~# rm -R musl-1.1.14*
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Construyendo una jaula de ejemplo&lt;/h2&gt;
&lt;p&gt;Supongamos que tenemos un código fuente de un ejecutable que queremos en la jaula. En este caso vamos a hacer un sencillo programa:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# cat hello.c
&lt;span class="c1"&gt;#include &amp;quot;stdio.h&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;#include &amp;quot;stdlib.h&amp;quot;&lt;/span&gt;

int main&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    printf&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Hello world!\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    exit&lt;span class="o"&gt;(&lt;/span&gt;0&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Versión estática&lt;/h3&gt;
&lt;p&gt;Compilamos nuestro binario con el &lt;em&gt;flag&lt;/em&gt; &lt;strong&gt;-static&lt;/strong&gt;. Eso hace que el binario incluya lo que necesita de &lt;strong&gt;musl libc&lt;/strong&gt;, con lo que no va a necesitar ninguna librería de sistema. Este binario debería funcionar en todas las máquinas con la misma arquitectura (en mi caso, x86). No os olvidéis del &lt;em&gt;strip&lt;/em&gt;, que va a eliminar los símbolos de &lt;em&gt;debug&lt;/em&gt; y reduce el tamaño del binario.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# /opt/musl/bin/musl-gcc -static -o hello hello.c
root@musl:~# strip hello
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Creamos una carpeta para la jaula, en la que ponemos nuestro ejecutable, sin nada mas, porque no lo necesita.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# mkdir jail_static
root@musl:~# cp hello jail_static/
root@musl:~# tree jail_static/ -h
jail_static/
└── &lt;span class="o"&gt;[&lt;/span&gt;4.9K&lt;span class="o"&gt;]&lt;/span&gt;  hello

&lt;span class="m"&gt;0&lt;/span&gt; directories, &lt;span class="m"&gt;1&lt;/span&gt; file
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Lanzamos un &lt;em&gt;chroot&lt;/em&gt; que va modificar la percepción de las carpetas; a todos los efectos, &lt;em&gt;jail_static/&lt;/em&gt; va a ser &lt;em&gt;/&lt;/em&gt; mientras el comando lanzado no acabe. Esto implica que nuestro binario estaría en la raíz de la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# chroot jail_static/ /hello
Hello world!
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vemos que funciona y que solo hemos necesitado 5 kilobytes para nuestra jaula. Obviamente, vamos a necesitar algo mas para poner un servicio completo.&lt;/p&gt;
&lt;p&gt;Hay que indicar que varios binarios posiblemente llevarían incrustados los mismos pedazos de &lt;strong&gt;musl libc&lt;/strong&gt; duplicando código, y que para actualizar la librería habría que recompilarlos todos con la nueva versión.&lt;/p&gt;
&lt;h3&gt;Versión dinámica&lt;/h3&gt;
&lt;p&gt;Que nuestro binario sea dinámico implica que no incluye ningún código de &lt;strong&gt;musl libc&lt;/strong&gt;, así que la va a necesitar cerca para funcionar. La ventaja es los binarios son independientes de la librería usada, que podemos actualizar simplemente cambiándola por la nueva, sin recompilar los binarios.&lt;/p&gt;
&lt;p&gt;Para compilar este caso no vamos a indicar ningún &lt;em&gt;flag&lt;/em&gt; de compilación, ya que el formato dinámico es el habitual.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# /opt/musl/bin/musl-gcc -o hello hello.c
root@musl:~# strip hello
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La parte mala es que este binario no funciona sin sus librerías, que podemos buscar con &lt;em&gt;ldd&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# ldd hello
./hello: error &lt;span class="k"&gt;while&lt;/span&gt; loading shared libraries: /usr/lib/i386-linux-gnu/libc.so: invalid ELF header
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Desgraciadamente, el &lt;em&gt;ldd&lt;/em&gt; del sistema funciona con la librería del sistema. La funcionalidad del &lt;em&gt;ldd&lt;/em&gt; para &lt;strong&gt;musl libc&lt;/strong&gt; la proporciona la misma librería, siempre que se llame &lt;em&gt;ldd&lt;/em&gt;. Hacer un enlace nos basta.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# ln -s /opt/musl/lib/libc.so ldd
root@musl:~# ./ldd hello
        /lib/ld-musl-i386.so.1 (0xb7757000)
        libc.so =&amp;gt; /lib/ld-musl-i386.so.1 (0xb7757000)
root@musl:~# ldd /lib/ld-musl-i386.so.1
        statically linked
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como vemos, nuestro binario necesita el fichero &lt;em&gt;/lib/ld-musl-i386.so.1&lt;/em&gt;, y este a ninguno mas. Con esta información podemos montar la jaula. Cabe decir que la librería puede reducirse con el comando &lt;em&gt;strip&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# mkdir jail_dynamic
root@musl:~# mkdir jail_dynamic/lib
root@musl:~# cp hello jail_dynamic/
root@musl:~# cp /lib/ld-musl-i386.so.1 jail_dynamic/lib/
root@musl:~# strip jail_dynamic/lib/ld-musl-i386.so.1
root@musl:~# tree jail_dynamic/ -h
jail_dynamic/
├── &lt;span class="o"&gt;[&lt;/span&gt;2.2K&lt;span class="o"&gt;]&lt;/span&gt;  hello
└── &lt;span class="o"&gt;[&lt;/span&gt;4.0K&lt;span class="o"&gt;]&lt;/span&gt;  lib
    └── &lt;span class="o"&gt;[&lt;/span&gt;531K&lt;span class="o"&gt;]&lt;/span&gt;  ld-musl-i386.so.1

&lt;span class="m"&gt;1&lt;/span&gt; directory, &lt;span class="m"&gt;2&lt;/span&gt; files
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y como es de esperar, la jaula funciona como se espera:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@musl:~# chroot jail_dynamic/ /hello
Hello world!
root@musl:~#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En este caso, la jaula ocupa mas que la versión estática. En el caso de haber mas binarios, podría salirnos a cuenta; desde luego, en este caso no hay beneficio ninguno, y además tenemos una complejidad adicional. Valorad cada caso individualmente.&lt;/p&gt;</summary><category term="linux"></category><category term="musl"></category><category term="libc"></category><category term="chroot"></category><category term="jaula"></category></entry><entry><title>Creando una jaula CentOS</title><link href="http://www.linuxsysadmin.tk/2016/01/creando-una-jaula-centos.html" rel="alternate"></link><published>2016-01-25T08:00:00+01:00</published><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-01-25:2016/01/creando-una-jaula-centos.html</id><summary type="html">&lt;p&gt;Algunas veces nos puede interesar levantar procesos o demonios en entornos controlados, por ejemplo en una jaula, o para crear un contenedor. Otras veces, por comodidad o conocimiento, nos puede interesar cambiar la distribución, por ejemplo, servicios &lt;em&gt;CentOS&lt;/em&gt; en un servidor &lt;em&gt;Ubuntu&lt;/em&gt;. Hoy vamos a construir una jaula con &lt;em&gt;CentOS&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Vamos a crear una jaula de &lt;em&gt;CentOS&lt;/em&gt;, partiendo de una distribución basada en &lt;strong&gt;yum&lt;/strong&gt;. En este caso, se trata de una distribución &lt;em&gt;RedHat&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# cat /etc/redhat-release&lt;/span&gt;
Red Hat Enterprise Linux Server release 7.2 &lt;span class="o"&gt;(&lt;/span&gt;Maipo&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creación de la jaula&lt;/h2&gt;
&lt;p&gt;Empezaremos declarando una variable para indicar donde vamos a crear la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# export JAIL=/root/jail&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a crear la carpeta de la jaula y la estructura necesaria para albergar los datos del comando &lt;strong&gt;rpm&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# mkdir -p ${JAIL}/var/lib/rpm&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como la base de datos de &lt;strong&gt;rpm&lt;/strong&gt; no existe, la vamos a recrear con el mismo comando:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# rpm --rebuilddb --root=${JAIL}&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vemos ahora que tenemos una estructura de carpetas que empieza a parecerse a lo que debería.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# tree $JAIL&lt;/span&gt;
/root/jail
&lt;span class="sb"&gt;`&lt;/span&gt;-- var
    &lt;span class="sb"&gt;`&lt;/span&gt;-- lib
        &lt;span class="sb"&gt;`&lt;/span&gt;-- rpm
            &lt;span class="sb"&gt;`&lt;/span&gt;-- Packages

&lt;span class="m"&gt;3&lt;/span&gt; directories, &lt;span class="m"&gt;1&lt;/span&gt; file
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El siguiente paso consiste en localizar el fichero &lt;em&gt;.rpm&lt;/em&gt; relativo a la &lt;em&gt;release&lt;/em&gt; de &lt;em&gt;CentOS&lt;/em&gt; que queramos en nuestra jaula. Apuntamos el navegador al servidor web con el repositorio base en &lt;a href="http://mirror.centos.org/centos/"&gt;http://mirror.centos.org/centos/&lt;/a&gt; y buscamos el &lt;em&gt;link&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Suponiendo que queramos un &lt;em&gt;CentOS&lt;/em&gt; versión 7 y con una arquitectura &lt;em&gt;x64_64&lt;/em&gt;, el &lt;em&gt;link&lt;/em&gt; podría ser &lt;a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/centos-release-7-2.1511.el7.centos.2.10.x86_64.rpm"&gt;http://mirror.centos.org/centos/7/os/x86_64/Packages/centos-release-7-2.1511.el7.centos.2.10.x86_64.rpm&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# rpm -i --root=${JAIL} --nodeps http://mirror.centos.org/centos/7/os/x86_64/Packages/centos-release-7-2.1511.el7.centos.2.10.x86_64.rpm&lt;/span&gt;
warning: Generating &lt;span class="m"&gt;12&lt;/span&gt; missing index&lt;span class="o"&gt;(&lt;/span&gt;es&lt;span class="o"&gt;)&lt;/span&gt;, please wait...
warning: /root/jail/var/tmp/rpm-tmp.Vy1z44: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El siguiente paso consiste en instalar &lt;strong&gt;yum&lt;/strong&gt; en la jaula, que va a traer todas las dependencias necesarias para completar la jaula.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: El comando &lt;strong&gt;yum&lt;/strong&gt; busca las llaves del repositorio en &lt;em&gt;/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7&lt;/em&gt;, y no en la jaula. Esto se puede solventar con un &lt;em&gt;link&lt;/em&gt; simbólico:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# ln -s ${JAIL}/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y ya podemos instalar &lt;strong&gt;yum&lt;/strong&gt; y sus dependencias:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum --installroot=${JAIL} install -y yum&lt;/span&gt;
...
Resolving Dependencies
...
Dependencies Resolved
...
Install  &lt;span class="m"&gt;1&lt;/span&gt; Package &lt;span class="o"&gt;(&lt;/span&gt;+89 Dependent packages&lt;span class="o"&gt;)&lt;/span&gt;

Total download size: &lt;span class="m"&gt;49&lt;/span&gt; M
Installed size: &lt;span class="m"&gt;245&lt;/span&gt; M
...
Complete!
&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Si queremos una jaula mas mínima todavía, en vez de &lt;em&gt;yum&lt;/em&gt; podemos instalar los paquetes necesarios, dejando que las dependencias hagan el resto:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum --installroot=${JAIL} install bash httpd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Alternativamente, se puede construir una jaula completa instalando el grupo &lt;em&gt;core&lt;/em&gt; en vez de &lt;em&gt;yum&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@mars ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum --installroot=${JAIL} groupinstall core&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ya tenemos la jaula; es un buen momento para sacar una copia  de la carpeta.&lt;/p&gt;
&lt;h2&gt;Uso de la jaula&lt;/h2&gt;
&lt;p&gt;Esta copia es transferible a otras máquinas, aunque no sean derivadas de &lt;em&gt;RedHat&lt;/em&gt;. En este caso, la jaula se puso a funcionar en una máquina con &lt;em&gt;Debian&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Declaramos la carpeta donde tenemos la jaula, copiada o descomprimida.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@uranus ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# export JAIL=/root/jail&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@uranus ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Opcionalmente, podemos copiar el esqueleto de configuración para el usuario &lt;strong&gt;root&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@uranus:~# cp &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;JAIL&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;/etc/skel/.* &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;JAIL&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;/root
cp: se omite el directorio «/root/jail/etc/skel/.»
cp: se omite el directorio «/root/jail/etc/skel/..»
root@uranus:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Es hora de entrar en la jaula para definir la contraseña de &lt;strong&gt;root&lt;/strong&gt;, configuración de red  y otros detalles.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@uranus:~# chroot &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;JAIL&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; /bin/bash -l
&lt;span class="o"&gt;[&lt;/span&gt;root@uranus /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Verificamos que estamos dentro de la jaula, por ejemplo, mirando la versión y distribución instalada.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@uranus /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# cat /etc/redhat-release &lt;/span&gt;
CentOS Linux release 7.2.1511 &lt;span class="o"&gt;(&lt;/span&gt;Core&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="o"&gt;[&lt;/span&gt;root@uranus /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# exit&lt;/span&gt;
root@uranus:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Podemos instalar cualquier paquete deseado en el interior de la jaula, sea mediante el comando &lt;strong&gt;chroot&lt;/strong&gt; o el comando &lt;strong&gt;systemd-nspawn&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Finalmente, y suponiendo que hay &lt;strong&gt;systemd&lt;/strong&gt; instalado en la máquina anfitriona, podemos ejecutar la jaula como un contenedor.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@uranus:~# systemd-nspawn -b -D jail/
Spawning container jail on /root/jail.
...
Welcome to CentOS Linux &lt;span class="m"&gt;7&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Core&lt;span class="o"&gt;)&lt;/span&gt;!
...
CentOS Linux &lt;span class="m"&gt;7&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Core&lt;span class="o"&gt;)&lt;/span&gt;
Kernel 3.16.0-4-amd64 on an x86_64

jail login: 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto ya tenemos nuestra jaula.&lt;/p&gt;</summary><category term="linux"></category><category term="centos"></category><category term="maipo"></category><category term="jaula"></category></entry><entry><title>Enjaulado de usuarios para uso de rsync</title><link href="http://www.linuxsysadmin.tk/2016/01/enjaulado-de-usuarios-para-uso-de-rsync.html" rel="alternate"></link><published>2016-01-04T10:00:00+01:00</published><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2016-01-04:2016/01/enjaulado-de-usuarios-para-uso-de-rsync.html</id><summary type="html">&lt;p&gt;Todos nos hemos encontrado alguna vez con una web, sea en &lt;em&gt;HTML&lt;/em&gt; o en &lt;em&gt;PHP&lt;/em&gt;, que se compone de centenares o miles de ficheros, y que hay que ir actualizando cada vez que cambian unos pocos ficheros. En estos casos la capacidad incremental de la herramienta &lt;strong&gt;rsync&lt;/strong&gt; puede ayudarnos mucho.&lt;/p&gt;
&lt;p&gt;Sin embargo, la herramienta &lt;strong&gt;rsync&lt;/strong&gt; funciona por el puerto de &lt;em&gt;SSH&lt;/em&gt;, y dar acceso al mismo es un problema desde el punto de vista de la seguridad del sistema. Vamos a crear una jaula para los usuarios que lo necesiten, y vamos a limitar los comandos que puede utilizar, de forma que solo pueda hacer &lt;strong&gt;rsync&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Para poder continuar, necesitamos las 2 herramientas que se van a usar: &lt;strong&gt;rsync&lt;/strong&gt; y &lt;strong&gt;rssh&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# apt-get install rssh rsync
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias       
Leyendo la información de estado... Hecho
...
Se instalarán los siguientes paquetes NUEVOS:
  libpopt0 rssh rsync
&lt;span class="m"&gt;0&lt;/span&gt; actualizados, &lt;span class="m"&gt;3&lt;/span&gt; nuevos se instalarán, &lt;span class="m"&gt;0&lt;/span&gt; para eliminar y &lt;span class="m"&gt;0&lt;/span&gt; no actualizados.
Se necesita descargar &lt;span class="m"&gt;505&lt;/span&gt; kB de archivos.
Se utilizarán &lt;span class="m"&gt;962&lt;/span&gt; kB de espacio de disco adicional después de esta operación.
...
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Preparación del sistema de enjaulado&lt;/h2&gt;
&lt;p&gt;Como decisión de diseño, he decidido que voy a enjaular todos los usuarios que pertenezcan a un grupo, al que llamaremos &lt;em&gt;restricted&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# groupadd restricted
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora vamos a configurar el demonio &lt;strong&gt;SSH&lt;/strong&gt; para que todos los usuarios del grupo &lt;em&gt;restricted&lt;/em&gt; queden enjaulados en &lt;em&gt;/srv/jails/&lt;/em&gt;, en una carpeta por usuario. La directiva &lt;em&gt;X11Forwarding&lt;/em&gt; y &lt;em&gt;AllowTcpForwarding&lt;/em&gt; son restricciones adicionales y no son necesarias.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# cat /etc/ssh/sshd_config 
...
Match group restricted
    ChrootDirectory /srv/jails/%u
    X11Forwarding no
    AllowTcpForwarding no
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y reiniciamos el demonio para que se apliquen las modificaciones en la configuración.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# service ssh restart
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creando una jaula para el primer usuario&lt;/h2&gt;
&lt;p&gt;Para tener un usuario enjaulado, necesitamos un usuario, en este caso, el usuario &lt;em&gt;web&lt;/em&gt;. Le vamos a poner &lt;em&gt;rssh&lt;/em&gt; como shell, su carpeta personal como &lt;em&gt;/&lt;/em&gt; y le asignamos el grupo &lt;em&gt;restricted&lt;/em&gt; para que quede enjaulado.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# useradd -d / -s /usr/bin/rssh -G restricted web
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para que el usuario &lt;em&gt;web&lt;/em&gt; pueda entrar en esta máquina, necesita una contraseña. Alternativamente, podríamos haber montado una autenticación por claves &lt;em&gt;SSH&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# passwd web
Introduzca la nueva contraseña de UNIX: 
Vuelva a escribir la nueva contraseña de UNIX: 
passwd: contraseña actualizada correctamente
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y ahora vamos a crearle una estructura de carpetas muy básica en donde deberá estar su jaula. Puesto que se trata del usuario &lt;em&gt;web&lt;/em&gt;, la carpeta de la jaula (la que el usuario verá como &lt;em&gt;/&lt;/em&gt;) va a ser &lt;em&gt;/srv/jails/web/&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IMPORTANTE&lt;/strong&gt;: Esta carpeta y todas las de la ruta deben perteneces al usuario &lt;em&gt;root&lt;/em&gt; y tener permisos de escritura solo por el &lt;em&gt;owner&lt;/em&gt;; de otra manera, el &lt;em&gt;SSH&lt;/em&gt; falla al enjaular.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# mkdir -p /srv/jails/web/&lt;span class="o"&gt;{&lt;/span&gt;usr/bin,etc,lib&lt;span class="o"&gt;}&lt;/span&gt;
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para limitar que el usuario solo pueda hacer &lt;em&gt;rsync&lt;/em&gt; vamos a necesitar la ayuda de &lt;em&gt;rssh&lt;/em&gt;; así pues, vamos a poner ambos binarios en la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# cp /usr/bin/rssh /srv/jails/web/usr/bin/
root@webserver:~# cp /usr/bin/rsync /srv/jails/web/usr/bin/
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Estos dos comandos son binarios &lt;em&gt;linkados&lt;/em&gt; dinámicamente que necesitan librerías. Vamos a buscarlos con el comando &lt;strong&gt;ldd&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# ldd /usr/bin/rssh 
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb7789000&lt;span class="o"&gt;)&lt;/span&gt;
    libc.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libc.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0xb760a000&lt;span class="o"&gt;)&lt;/span&gt;
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb778c000&lt;span class="o"&gt;)&lt;/span&gt;
root@webserver:~# ldd /usr/bin/rsync 
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb7741000&lt;span class="o"&gt;)&lt;/span&gt;
    libattr.so.1 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libattr.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb76a3000&lt;span class="o"&gt;)&lt;/span&gt;
    libacl.so.1 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libacl.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb7699000&lt;span class="o"&gt;)&lt;/span&gt;
    libpopt.so.0 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libpopt.so.0 &lt;span class="o"&gt;(&lt;/span&gt;0xb768a000&lt;span class="o"&gt;)&lt;/span&gt;
    libc.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libc.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0xb7519000&lt;span class="o"&gt;)&lt;/span&gt;
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb7744000&lt;span class="o"&gt;)&lt;/span&gt;
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y las copiamos en la carpeta &lt;em&gt;lib&lt;/em&gt; de la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# cp /lib/ld-linux.so.2 /srv/jails/web/lib/
root@webserver:~# cp /lib/i386-linux-gnu/libc.so.6 /srv/jails/web/lib/
root@webserver:~# cp /lib/i386-linux-gnu/libattr.so.1 /srv/jails/web/lib/
root@webserver:~# cp /lib/i386-linux-gnu/libacl.so.1 /srv/jails/web/lib/
root@webserver:~# cp /lib/i386-linux-gnu/libpopt.so.0 /srv/jails/web/lib/
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Voy a quitar los permisos de ejecución de la librería &lt;em&gt;libc&lt;/em&gt; porque no lo necesita.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# chmod &lt;span class="m"&gt;644&lt;/span&gt; /srv/jails/web/lib/libc.so.6 
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora que tenemos las librerías en la jaula, volvemos a mirar que otras librerías puedan necesitar con &lt;strong&gt;ldd&lt;/strong&gt;, para evitar dejarnos ninguna.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# ldd /srv/jails/web/lib/*
/srv/jails/web/lib/ld-linux.so.2:
    statically linked
/srv/jails/web/lib/libacl.so.1:
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb77b3000&lt;span class="o"&gt;)&lt;/span&gt;
    libattr.so.1 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libattr.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb779e000&lt;span class="o"&gt;)&lt;/span&gt;
    libc.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libc.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0xb762d000&lt;span class="o"&gt;)&lt;/span&gt;
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb77b6000&lt;span class="o"&gt;)&lt;/span&gt;
/srv/jails/web/lib/libattr.so.1:
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb7756000&lt;span class="o"&gt;)&lt;/span&gt;
    libc.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libc.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0xb75da000&lt;span class="o"&gt;)&lt;/span&gt;
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb7759000&lt;span class="o"&gt;)&lt;/span&gt;
/srv/jails/web/lib/libc.so.6:
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb779f000&lt;span class="o"&gt;)&lt;/span&gt;
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb779c000&lt;span class="o"&gt;)&lt;/span&gt;
/srv/jails/web/lib/libpopt.so.0:
    linux-gate.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0xb7782000&lt;span class="o"&gt;)&lt;/span&gt;
    libc.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/i386-linux-gnu/libc.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0xb75fe000&lt;span class="o"&gt;)&lt;/span&gt;
    /lib/ld-linux.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0xb7785000&lt;span class="o"&gt;)&lt;/span&gt;
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y como no han entrado de nuevas, hemos acabado con esto. Ahora vamos a copiar la configuración de &lt;strong&gt;rssh&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# cp /etc/rssh.conf /srv/jails/web/etc/
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a añadir la directiva &lt;em&gt;allowrsync&lt;/em&gt; ya que, por defecto, no se permite nada:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ANTES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# grep allowrsync /srv/jails/web/etc/rssh.conf 
&lt;span class="c1"&gt;#allowrsync&lt;/span&gt;
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;DESPUES&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# grep allowrsync /srv/jails/web/etc/rssh.conf 
allowrsync
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como estamos esperando que el usuario &lt;em&gt;web&lt;/em&gt; deje sus cosas en una carpeta &lt;em&gt;www&lt;/em&gt;, vamos a crearla, ya que va a ser la única en la que pueda copiar sus cosas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# mkdir /srv/jails/web/www
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y le damos permisos necesarios para que escriba en ella; por ejemplo, le damos la propiedad de la carpeta.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# chown web:web /srv/jails/web/www/
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto queda completa la jaula. Como demostración, muestro la salida del comando &lt;strong&gt;tree&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# tree /srv/jails/web/
/srv/jails/web/
├── etc
│   └── rssh.conf
├── lib
│   ├── ld-linux.so.2
│   ├── libacl.so.1
│   ├── libattr.so.1
│   ├── libc.so.6
│   └── libpopt.so.0
├── usr
│   └── bin
│       ├── rssh
│       └── rsync
└── www

&lt;span class="m"&gt;5&lt;/span&gt; directories, &lt;span class="m"&gt;8&lt;/span&gt; files
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Uso de la jaula&lt;/h2&gt;
&lt;p&gt;Supongamos que tenemos un proyecto web en una máquina &lt;em&gt;developer&lt;/em&gt;, por ejemplo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gerard@developer:~$ tree web/
web/
└── index.html

&lt;span class="m"&gt;0&lt;/span&gt; directories, &lt;span class="m"&gt;1&lt;/span&gt; file
gerard@developer:~$ 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Intentamos entrar por &lt;em&gt;SSH&lt;/em&gt; y vemos que falla:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gerard@developer:~$ ssh web@10.0.0.2
web@10.0.0.2&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s password: 

The programs included with the Debian GNU/Linux system are free software&lt;span class="p"&gt;;&lt;/span&gt;
the exact distribution terms &lt;span class="k"&gt;for&lt;/span&gt; each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Wed Dec &lt;span class="m"&gt;30&lt;/span&gt; 21:12:44 &lt;span class="m"&gt;2015&lt;/span&gt; from 10.0.0.3

This account is restricted by rssh.
Allowed commands: rsync 

If you believe this is in error, please contact your system administrator.

Connection to 10.0.0.2 closed.
gerard@developer:~$ 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a usar &lt;em&gt;rsync&lt;/em&gt; para sincronizar este proyecto con el servidor que acabamos de montar. Para eso, la máquina cliente necesita tener instalado el paquete &lt;strong&gt;rsync&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gerard@developer:~$ rsync -rvzc --delete web/ web@10.0.0.2:/www
web@10.0.0.2&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s password: 
sending incremental file list
index.html

sent &lt;span class="m"&gt;139&lt;/span&gt; bytes  received &lt;span class="m"&gt;35&lt;/span&gt; bytes  49.71 bytes/sec
total size is &lt;span class="m"&gt;12&lt;/span&gt;  speedup is 0.07
gerard@developer:~$ 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Si repetimos el comando, vemos que la lista de ficheros no incluye el &lt;em&gt;index.html&lt;/em&gt;, porque no ha cambiado respecto a lo que tenemos en el servidor, así que no lo manda.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gerard@developer:~$ rsync -rvzc --delete web/ web@10.0.0.2:/www
web@10.0.0.2&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s password: 
sending incremental file list

sent &lt;span class="m"&gt;83&lt;/span&gt; bytes  received &lt;span class="m"&gt;12&lt;/span&gt; bytes  7.60 bytes/sec
total size is &lt;span class="m"&gt;12&lt;/span&gt;  speedup is 0.13
gerard@developer:~$ 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;los &lt;em&gt;flags&lt;/em&gt; elegidos son &lt;strong&gt;-r&lt;/strong&gt; (recursivo), &lt;strong&gt;-v&lt;/strong&gt; (verbose), &lt;strong&gt;-z&lt;/strong&gt; (comprimido), &lt;strong&gt;-c&lt;/strong&gt; (diferenciar por &lt;em&gt;checksum&lt;/em&gt;) y &lt;strong&gt;--delete&lt;/strong&gt; (para borrar fichero que estén en el servidor y no deban).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IMPORTANTE&lt;/strong&gt;: la carpeta origen acaba con &lt;em&gt;/&lt;/em&gt;. Esa es la diferencia entre copiar el contenido de la carpeta y copiar la carpeta misma.&lt;/p&gt;
&lt;p&gt;Analizamos el resultado y vemos que lo hemos copiado en &lt;em&gt;/www/&lt;/em&gt;, siempre desde el punto de vista de la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@webserver:~# ls /www
ls: no se puede acceder a /www: No existe el fichero o el directorio
root@webserver:~# tree /srv/jails/web/
/srv/jails/web/
├── etc
│   └── rssh.conf
├── lib
│   ├── ld-linux.so.2
│   ├── libacl.so.1
│   ├── libattr.so.1
│   ├── libc.so.6
│   └── libpopt.so.0
├── usr
│   └── bin
│       ├── rssh
│       └── rsync
└── www
    └── index.html

&lt;span class="m"&gt;5&lt;/span&gt; directories, &lt;span class="m"&gt;9&lt;/span&gt; files
root@webserver:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto está todo hecho. Solo falta instalar el servidor web, pero eso lo dejo pendiente.&lt;/p&gt;</summary><category term="linux"></category><category term="rsync"></category><category term="rssh"></category><category term="ssh"></category><category term="ldd"></category><category term="jaula"></category></entry><entry><title>Ocultando puertos con port knocking</title><link href="http://www.linuxsysadmin.tk/2015/10/ocultando-puertos-con-port-knocking.html" rel="alternate"></link><published>2015-10-29T11:30:00+01:00</published><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-10-29:2015/10/ocultando-puertos-con-port-knocking.html</id><summary type="html">&lt;p&gt;En este artículo vamos a enseñar como ocultar un puerto tras el firewall, de forma que solamente se abra tras utilizar el protocolo &lt;em&gt;port knocking&lt;/em&gt;. Las tecnologías usadas van a ser &lt;em&gt;firehol&lt;/em&gt; como firewall y el demonio &lt;em&gt;knockd&lt;/em&gt; ocultando el &lt;em&gt;SSH&lt;/em&gt;, aunque vamos a permitir acceder al puerto de HTTP.&lt;/p&gt;
&lt;p&gt;El protocolo de &lt;em&gt;port knocking&lt;/em&gt; es un sistema en el que para abrir la conectividad en un puerto se debe primero abrir una secuencia concreta a otros puertos, sean &lt;em&gt;TCP&lt;/em&gt; o &lt;em&gt;UDP&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Para conseguir este objetivo, se van a usar las siguientes tecnologías:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Debian jessie&lt;/strong&gt;: Como distribución base; podría ser cualquier otra&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Firehol&lt;/strong&gt;: Scripts para levantar un firewall basado en &lt;em&gt;iptables&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El hardware va a ser uno con capacidades limitadas, virtualizado en VirtualBox.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPUs&lt;/strong&gt;: 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memoria&lt;/strong&gt;: 256 Mb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Disco&lt;/strong&gt;: 2 Gb&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Red&lt;/strong&gt;: 1 interfaz (&lt;em&gt;eth0&lt;/em&gt;) &lt;em&gt;host-only&lt;/em&gt; o &lt;em&gt;bridged&lt;/em&gt; con IP fija&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La instalación base es una &lt;em&gt;Debian&lt;/em&gt; mínima instalada con el CD netinstall, con todo desmarcado y con el servidor de &lt;em&gt;SSH&lt;/em&gt; previamente instalado.&lt;/p&gt;
&lt;h2&gt;Instalación del servidor&lt;/h2&gt;
&lt;p&gt;Para empezar, vamos a instalar los dos servicios implicados:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@server:~# apt-get install firehol knockd
...
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Configuramos las reglas del firewall, de acuerdo a la documentación relacionada con &lt;em&gt;port knocking&lt;/em&gt;. Se define un nivel de protección máximo, ya que se trata de la interfaz que deberá estar accesible desde internet; esto nos evita la mayoría de ataques conocidos en la capa 3 y 4.&lt;/p&gt;
&lt;p&gt;En cuanto a las conectividad, vamos a permitir que este servidor acceda a servicios &lt;em&gt;DNS&lt;/em&gt; y &lt;em&gt;HTTP&lt;/em&gt;, que es lo justo para actualizarse. Como servidor vamos a permitir el acceso a &lt;em&gt;HTTP&lt;/em&gt; (ya que en el ejemplo, esta máquina va a servir como servidor &lt;em&gt;HTTP&lt;/em&gt;) y a &lt;em&gt;SSH&lt;/em&gt; siempre y cuando se cumpla con el protocolo de seguridad.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@server:~# cat /etc/firehol/firehol.conf 
version 5

interface any world
    protection strong
    client &lt;span class="s2"&gt;&amp;quot;dns http&amp;quot;&lt;/span&gt; accept
    server http accept
    server ssh accept with knock hidden
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Acto seguido vamos a definir las reglas para que se abra el &lt;em&gt;knock hidden&lt;/em&gt; (que corresponde con el puerto &lt;em&gt;SSH&lt;/em&gt;) si se completa la secuencia de &lt;em&gt;knock&lt;/em&gt;. En este caso concreto, se indica una secuencia de los puertos &lt;em&gt;TCP&lt;/em&gt; 123, 456 y 789; aunque es posible definir puertos &lt;em&gt;UDP&lt;/em&gt;, dejamos sin indicarlo, que nos los va a definir como &lt;em&gt;TCP&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Como medida de seguridad vamos a indicar un tiempo máximo de 10 segundos para completar la secuencia de &lt;em&gt;knock&lt;/em&gt; y un autocierre del puerto a los 5 segundos (aunque firehol va a permitir las conexiones que se hayan establecido en esos 5 segundos).&lt;/p&gt;
&lt;p&gt;Es especialmente interesante ver que la regla incluye la dirección origen, con lo que la apertura de puerto solo será visible desde la máquina que completó la secuencia de &lt;em&gt;knock&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@server:~# cat /etc/knockd.conf 
&lt;span class="o"&gt;[&lt;/span&gt;options&lt;span class="o"&gt;]&lt;/span&gt;
    UseSyslog

&lt;span class="o"&gt;[&lt;/span&gt;SSH&lt;span class="o"&gt;]&lt;/span&gt;
    &lt;span class="nv"&gt;sequence&lt;/span&gt;      &lt;span class="o"&gt;=&lt;/span&gt; 123,456,789
    &lt;span class="nv"&gt;seq_timeout&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; 10
    &lt;span class="nv"&gt;start_command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; iptables -A knock_hidden -s %IP% -j ACCEPT
    &lt;span class="nv"&gt;cmd_timeout&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; 5
    &lt;span class="nv"&gt;stop_command&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; iptables -D knock_hidden -s %IP% -j ACCEPT
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como medida de seguridad, &lt;em&gt;Debian&lt;/em&gt; tiene una protección para levantar ambos servicios, así que tenemos que indicarle que queremos que se puedan levantar, editando otros ficheros de configuración.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@server:~# cat /etc/default/knockd 
...
&lt;span class="nv"&gt;START_KNOCKD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1
...
root@server:~# cat /etc/default/firehol 
...
&lt;span class="nv"&gt;START_FIREHOL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;YES
...
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente podemos levantar los servicios de &lt;em&gt;port knocking&lt;/em&gt; y de &lt;em&gt;firewall&lt;/em&gt;, usando las herramientas estándares que nos ofrece la distribución.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@server:~# service knockd restart
root@server:~# service firehol restart
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Comprobación de funcionamiento&lt;/h2&gt;
&lt;p&gt;Para comprobar el funcionamiento basta con comprobar que el puerto está normalmente cerrado. Personalmente he usado &lt;em&gt;nmap&lt;/em&gt;, aunque se podría usar &lt;em&gt;netcat&lt;/em&gt; o &lt;em&gt;telnet&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gerard@workstation:~$ nmap -PN 192.168.56.3 -p 22

Starting Nmap 5.21 &lt;span class="o"&gt;(&lt;/span&gt; http://nmap.org &lt;span class="o"&gt;)&lt;/span&gt; at 2015-10-28 17:33 CET
Nmap scan report &lt;span class="k"&gt;for&lt;/span&gt; server &lt;span class="o"&gt;(&lt;/span&gt;192.168.56.3&lt;span class="o"&gt;)&lt;/span&gt;
Host is up.
PORT   STATE    SERVICE
22/tcp filtered ssh

Nmap &lt;span class="k"&gt;done&lt;/span&gt;: &lt;span class="m"&gt;1&lt;/span&gt; IP address &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; host up&lt;span class="o"&gt;)&lt;/span&gt; scanned in 2.13 seconds
gerard@workstation:~$ 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vemos que sale &lt;strong&gt;filtered&lt;/strong&gt;, que significa que el firewall lo está bloqueando. Ahora vamos a lanzar la secuencia de &lt;em&gt;knock&lt;/em&gt; usando el helper &lt;strong&gt;knock&lt;/strong&gt;, que en &lt;em&gt;Debian&lt;/em&gt; se encuentra en el mismo paquete &lt;em&gt;knockd&lt;/em&gt;. Acto seguido, el puerto de &lt;em&gt;SSH&lt;/em&gt; queda abierto (en otras palabras: escuchando). Ahora sería posible iniciar sesión por &lt;em&gt;SSH&lt;/em&gt; en la máquina.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gerard@workstation:~$ knock 192.168.56.3 &lt;span class="m"&gt;123&lt;/span&gt; &lt;span class="m"&gt;456&lt;/span&gt; 789
gerard@workstation:~$ nmap -PN 192.168.56.3 -p 22

Starting Nmap 5.21 &lt;span class="o"&gt;(&lt;/span&gt; http://nmap.org &lt;span class="o"&gt;)&lt;/span&gt; at 2015-10-28 17:34 CET
Nmap scan report &lt;span class="k"&gt;for&lt;/span&gt; server &lt;span class="o"&gt;(&lt;/span&gt;192.168.56.3&lt;span class="o"&gt;)&lt;/span&gt;
Host is up &lt;span class="o"&gt;(&lt;/span&gt;0.0011s latency&lt;span class="o"&gt;)&lt;/span&gt;.
PORT   STATE SERVICE
22/tcp open  ssh

Nmap &lt;span class="k"&gt;done&lt;/span&gt;: &lt;span class="m"&gt;1&lt;/span&gt; IP address &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; host up&lt;span class="o"&gt;)&lt;/span&gt; scanned in 0.07 seconds
gerard@workstation:~$ 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente comprobamos que, transcurridos los 5 segundos configurados, el puerto vuelve a verse como &lt;strong&gt;filtrado&lt;/strong&gt;, con lo que no se puede establecer nuevas conexiones en este puerto.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gerard@workstation:~$ nmap -PN 192.168.56.3 -p 22

Starting Nmap 5.21 &lt;span class="o"&gt;(&lt;/span&gt; http://nmap.org &lt;span class="o"&gt;)&lt;/span&gt; at 2015-10-28 17:34 CET
Nmap scan report &lt;span class="k"&gt;for&lt;/span&gt; server &lt;span class="o"&gt;(&lt;/span&gt;192.168.56.3&lt;span class="o"&gt;)&lt;/span&gt;
Host is up.
PORT   STATE    SERVICE
22/tcp filtered ssh

Nmap &lt;span class="k"&gt;done&lt;/span&gt;: &lt;span class="m"&gt;1&lt;/span&gt; IP address &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; host up&lt;span class="o"&gt;)&lt;/span&gt; scanned in 2.08 seconds
gerard@workstation:~$ 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto queda protegido el acceso por &lt;em&gt;SSH&lt;/em&gt; a la máquina.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="firehol"></category><category term="port knocking"></category><category term="ssh"></category><category term="nmap"></category></entry></feed>