<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Linux Sysadmin</title><link href="http://www.linuxsysadmin.tk/" rel="alternate"></link><link href="http://www.linuxsysadmin.tk/feeds/operaciones.atom.xml" rel="self"></link><id>http://www.linuxsysadmin.tk/</id><updated>2015-12-02T12:30:00+01:00</updated><entry><title>Creación de un livecd con Debian</title><link href="http://www.linuxsysadmin.tk/2015/12/creacion-de-un-livecd-con-debian.html" rel="alternate"></link><updated>2015-12-02T12:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-12-02:2015/12/creacion-de-un-livecd-con-debian.html</id><summary type="html">&lt;p&gt;Tras ver como las actualizaciones de mis máquinas virtuales &lt;em&gt;VirtualBox&lt;/em&gt; expandían mis discos &lt;em&gt;.vdi&lt;/em&gt; sin control, quise pasar la herramienta &lt;em&gt;zerofree&lt;/em&gt; y un compactado con la herramienta oficial &lt;em&gt;VBoxManage&lt;/em&gt;. No quería instalar &lt;em&gt;zerofree&lt;/em&gt; de forma permanente y no pude encontrar un &lt;em&gt;livecd&lt;/em&gt; que lo tuviera, así que decidí crear uno.&lt;/p&gt;
&lt;p&gt;Para conseguirlo, se va a usar un sistema de ficheros creado con &lt;em&gt;debootstrap&lt;/em&gt; y compactado mediante &lt;em&gt;SquashFS&lt;/em&gt;; este sistema de ficheros se va a empaquetar en un &lt;em&gt;.iso&lt;/em&gt; junto con un &lt;em&gt;kernel&lt;/em&gt;, un &lt;em&gt;initrd&lt;/em&gt; y el bootloader &lt;em&gt;isolinux&lt;/em&gt;. La herramienta que hace eso es &lt;em&gt;genisoimage&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Este tutorial se ejecutó en una distribución &lt;em&gt;Debian&lt;/em&gt;, pero no hay ningún problema en hacerlo en una &lt;em&gt;Ubuntu&lt;/em&gt; u otra distribución, siempre que sepamos como crear la imagen base para empaquetar.&lt;/p&gt;
&lt;h2&gt;Preparación del entorno&lt;/h2&gt;
&lt;p&gt;Todo el proceso va a ser ejecutado con el usuario &lt;em&gt;root&lt;/em&gt; por comodidad.&lt;/p&gt;
&lt;p&gt;Empezaremos por instalar todas las tecnologías que hemos mencionado:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~# apt-get install debootstrap isolinux squashfs-tools genisoimage
...
root@desktop:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Creamos una carpeta de trabajo para contener todos los ficheros temporales y el producto final, por limpieza:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~# mkdir live_boot
root@desktop:~# &lt;span class="nb"&gt;cd &lt;/span&gt;live_boot
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Todos los comandos que se detallan a continuación se hacen desde dentro de esta carpeta.&lt;/p&gt;
&lt;h2&gt;Preparación del sistema de ficheros, el kernel y el initrd&lt;/h2&gt;
&lt;p&gt;El sistema de ficheros se hace a partir de una jaula estándar de una distribución normal. En este paso, las distribuciones que usan &lt;em&gt;debootstrap&lt;/em&gt; nos facilitan mucho las cosas (aunque esta es la operación mas larga de este tutorial):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# debootstrap --variant&lt;span class="o"&gt;=&lt;/span&gt;minbase jessie chroot
I: Retrieving Release 
I: Retrieving Release.gpg 
I: Checking Release signature
I: Valid Release signature &lt;span class="o"&gt;(&lt;/span&gt;key id 75DDC3C4A499F1A18CB5F3C8CBF8D6FD518E17E1&lt;span class="o"&gt;)&lt;/span&gt;
I: Retrieving Packages 
I: Validating Packages 
I: Resolving dependencies of required packages...
I: Resolving dependencies of base packages...
...
I: Base system installed successfully.
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora se trata de preparar esta jaula con los paquetes que necesitemos y las configuraciones adecuadas. Vamos a montar los pseudo sistemas de ficheros &lt;em&gt;/proc&lt;/em&gt;, &lt;em&gt;/sys&lt;/em&gt;, &lt;em&gt;/dev&lt;/em&gt; y &lt;em&gt;/dev/pts&lt;/em&gt;, que posiblemente nos van a hacer falta cuando estemos dentro de la jaula.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# mount -o &lt;span class="nb"&gt;bind&lt;/span&gt; /proc/ chroot/proc/
root@desktop:~/live_boot# mount -o &lt;span class="nb"&gt;bind&lt;/span&gt; /sys/ chroot/sys/
root@desktop:~/live_boot# mount -o &lt;span class="nb"&gt;bind&lt;/span&gt; /dev/ chroot/dev/
root@desktop:~/live_boot# mount -o &lt;span class="nb"&gt;bind&lt;/span&gt; /dev/pts/ chroot/dev/pts/
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Entramos en la jaula:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# chroot chroot
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;CUIDADO&lt;/strong&gt;: A partir de ahora, y hasta nuevo aviso, todos los comandos se hacen &lt;strong&gt;dentro&lt;/strong&gt; de la jaula.&lt;/p&gt;
&lt;p&gt;Antes de nada, vamos a asignar una password al usuario &lt;em&gt;root&lt;/em&gt;, porque sino, no vamos a poder entrar en el &lt;em&gt;livecd&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# passwd    
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Asignamos el nombre de máquina que mostrará el &lt;em&gt;livecd&lt;/em&gt; una vez haya hecho el &lt;em&gt;boot&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;zerofree&amp;quot;&lt;/span&gt; &amp;gt; /etc/hostname
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para que el &lt;em&gt;livecd&lt;/em&gt; pueda hacer &lt;em&gt;boot&lt;/em&gt;, vamos a necesitar el paquete &lt;strong&gt;live-boot&lt;/strong&gt; y un &lt;em&gt;kernel&lt;/em&gt; adecuado a la máquina que va a usar el &lt;em&gt;livecd&lt;/em&gt;. El paquete del &lt;em&gt;kernel&lt;/em&gt; ya nos va a dotar de un &lt;em&gt;initrd&lt;/em&gt; que también vamos a necesitar para el &lt;em&gt;livecd&lt;/em&gt;. Este paso también tarda un poco.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# apt-get install linux-image-486 live-boot
Reading package lists... Done
Building dependency tree... Done
...
Setting up linux-image-3.16.0-4-586 &lt;span class="o"&gt;(&lt;/span&gt;3.16.7-ckt11-1+deb8u3&lt;span class="o"&gt;)&lt;/span&gt; ...
...  
/etc/kernel/postinst.d/initramfs-tools:
update-initramfs: Generating /boot/initrd.img-3.16.0-4-586
...
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora vamos a instalar los paquetes que queramos en el &lt;em&gt;livecd&lt;/em&gt;; yo voy a poner &lt;em&gt;zerofree&lt;/em&gt; que es la herramienta que motivó este &lt;em&gt;livecd&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# apt-get install zerofree
...
Unpacking zerofree &lt;span class="o"&gt;(&lt;/span&gt;1.0.3-1&lt;span class="o"&gt;)&lt;/span&gt; ...
Setting up zerofree &lt;span class="o"&gt;(&lt;/span&gt;1.0.3-1&lt;span class="o"&gt;)&lt;/span&gt; ...
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;OPCIONAL&lt;/strong&gt;: Para reducir el tamaño final, voy a limpiar todos los archivos temporales que usa &lt;em&gt;apt&lt;/em&gt;, tanto los archivos &lt;em&gt;.deb&lt;/em&gt; en &lt;em&gt;/var/cache/apt&lt;/em&gt;, como las listas de paquetes disponibles en &lt;em&gt;/var/lib/apt&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# cat /dev/null &amp;gt; /etc/apt/sources.list
root@desktop:/# apt-get update
Reading package lists... Done
root@desktop:/# apt-get clean 
root@desktop:/# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y finalmente salimos de la jaula:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:/# &lt;span class="nb"&gt;exit&lt;/span&gt;
&lt;span class="nb"&gt;exit&lt;/span&gt;
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;CUIDADO&lt;/strong&gt;: A partir de ahora, todos los comandos se hacen &lt;strong&gt;fuera&lt;/strong&gt; de la jaula.&lt;/p&gt;
&lt;p&gt;Vamos a desmontar los pseudo sistemas de ficheros que ya no son necesarios, y que van a molestar cuando compactemos la jaula. Como apunte, la jaula había levantado un proceso &lt;em&gt;/usr/sbin/uuidd&lt;/em&gt; que evitaba desmontar &lt;em&gt;chroot/dev&lt;/em&gt;, por lo que tuve que finalizar el proceso con un &lt;em&gt;kill&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# umount chroot/dev/pts/
root@desktop:~/live_boot# umount chroot/dev/
root@desktop:~/live_boot# umount chroot/sys/
root@desktop:~/live_boot# umount chroot/proc/
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;OPCIONAL&lt;/strong&gt;: Sabiendo que mis máquinas virtuales son clones y el comando que va a correr siempre el comando &lt;em&gt;zerofree&lt;/em&gt; contra el disco &lt;em&gt;/dev/sda1&lt;/em&gt;, se puede poner los comandos en el &lt;em&gt;.bash_history&lt;/em&gt; de &lt;em&gt;root&lt;/em&gt; para poderlos recuperar mediante el uso de flechas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# cat chroot/root/.bash_history 
zerofree /dev/sda1
poweroff
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Empaquetando la imagen&lt;/h2&gt;
&lt;p&gt;Vamos a crear una carpeta contenedora, que va a servir como raíz del &lt;em&gt;livecd&lt;/em&gt;. Dentro le vamos a poner una carpeta &lt;em&gt;live&lt;/em&gt; (para el sistema de ficheros, el &lt;em&gt;kernel&lt;/em&gt; y el &lt;em&gt;initrd&lt;/em&gt;) y una carpeta &lt;em&gt;isolinux&lt;/em&gt; (para todo lo referente al &lt;em&gt;bootloader&lt;/em&gt;).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# mkdir -p image/&lt;span class="o"&gt;{&lt;/span&gt;live,isolinux&lt;span class="o"&gt;}&lt;/span&gt;
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos a poner el sistema de ficheros en formato &lt;em&gt;SquashFS&lt;/em&gt;. Como apunte, el &lt;em&gt;kernel&lt;/em&gt; y el &lt;em&gt;initrd&lt;/em&gt; (ambos en la carpeta &lt;em&gt;/boot&lt;/em&gt;) se excluyen porque el &lt;em&gt;bootloader&lt;/em&gt; es incapaz de leerlos de allí; así que los copiamos a la misma carpeta.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# mksquashfs chroot image/live/filesystem.squashfs -e boot
Parallel mksquashfs: Using &lt;span class="m"&gt;1&lt;/span&gt; processor
Creating 4.0 filesystem on image/live/filesystem.squashfs, block size 131072.
...  
root@desktop:~/live_boot# cp chroot/boot/vmlinuz-3.16.0-4-586 image/live/vmlinuz
root@desktop:~/live_boot# cp chroot/boot/initrd.img-3.16.0-4-586 image/live/initrd
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora vamos con el &lt;em&gt;bootloader&lt;/em&gt;. Lo primero es poner una configuración para saber qué menú nos va a mostrar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# cat image/isolinux/isolinux.cfg 
UI menu.c32

prompt 0
menu title Debian Zerofree

timeout 50

label Debian Live 3.16.0-4-586
menu label ^Debian Live 3.16.0-4-586
menu default
kernel /live/vmlinuz
append &lt;span class="nv"&gt;initrd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/live/initrd &lt;span class="nv"&gt;boot&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;live
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Copiamos la imagen del &lt;em&gt;bootloader&lt;/em&gt; &lt;strong&gt;isolinux&lt;/strong&gt; y los módulos que se necesitan, tanto porque nuestra configuración los usa o porque se usan desde otros módulos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# cp /usr/lib/ISOLINUX/isolinux.bin image/isolinux/
root@desktop:~/live_boot# cp /usr/lib/syslinux/modules/bios/ldlinux.c32 image/isolinux/
root@desktop:~/live_boot# cp /usr/lib/syslinux/modules/bios/menu.c32 image/isolinux/
root@desktop:~/live_boot# cp /usr/lib/syslinux/modules/bios/libutil.c32 image/isolinux/
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalmente empaquetamos la imagen &lt;em&gt;.iso&lt;/em&gt;. Para ello usaremos la herramienta &lt;em&gt;genisoimage&lt;/em&gt; en la carpeta raíz de lo que sería el &lt;em&gt;livecd&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# &lt;span class="nb"&gt;cd &lt;/span&gt;image/
root@desktop:~/live_boot/image# genisoimage -rational-rock -volid &lt;span class="s2"&gt;&amp;quot;Debian Zerofree&amp;quot;&lt;/span&gt; -cache-inodes -joliet -full-iso9660-filenames -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size &lt;span class="m"&gt;4&lt;/span&gt; -boot-info-table -output ../debian-zerofree.iso .
I: -input-charset not specified, using utf-8 &lt;span class="o"&gt;(&lt;/span&gt;detected in locale settings&lt;span class="o"&gt;)&lt;/span&gt;
Size of boot image is &lt;span class="m"&gt;4&lt;/span&gt; sectors -&amp;gt; No emulation
  9.24% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:43 2015
 18.48% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:38 2015
 27.69% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:36 2015
 36.94% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:38 2015
 46.15% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:37 2015
 55.40% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:36 2015
 64.61% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:37 2015
 73.85% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:37 2015
 83.07% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:37 2015
 92.30% &lt;span class="k"&gt;done&lt;/span&gt;, estimate finish Wed Dec  &lt;span class="m"&gt;2&lt;/span&gt; 12:06:38 2015
Total translation table size: 2048
Total rockridge attributes bytes: 1335
Total directory bytes: 4570
Path table size&lt;span class="o"&gt;(&lt;/span&gt;bytes&lt;span class="o"&gt;)&lt;/span&gt;: 38
Max brk space used 1a000
&lt;span class="m"&gt;54178&lt;/span&gt; extents written &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;105&lt;/span&gt; MB&lt;span class="o"&gt;)&lt;/span&gt;
root@desktop:~/live_boot/image# &lt;span class="nb"&gt;cd&lt;/span&gt; ..
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y nuestra imagen &lt;em&gt;.iso&lt;/em&gt; queda en la carpeta de trabajo, junto a la jaula y a la estructura del &lt;em&gt;livecd&lt;/em&gt;. Solo necesitamos la imagen &lt;em&gt;.iso&lt;/em&gt;, pero podemos dejar los ficheros intermedios hasta que estemos satisfechos con la imagen; es mas fácil modificar la jaula, el empaquetado &lt;em&gt;filesystem.squashfs&lt;/em&gt; y la imagen &lt;em&gt;.iso&lt;/em&gt; que volver a hacer un &lt;em&gt;debootstrap&lt;/em&gt; entero...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@desktop:~/live_boot# ls -lh
total 106M
drwxr-xr-x &lt;span class="m"&gt;20&lt;/span&gt; root root 4,0K dic  &lt;span class="m"&gt;2&lt;/span&gt; 11:30 chroot
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; root root 106M dic  &lt;span class="m"&gt;2&lt;/span&gt; 12:06 debian-zerofree.iso
drwxr-xr-x  &lt;span class="m"&gt;4&lt;/span&gt; root root 4,0K dic  &lt;span class="m"&gt;2&lt;/span&gt; 11:53 image
root@desktop:~/live_boot# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusión&lt;/h2&gt;
&lt;p&gt;Copiando esta imagen &lt;em&gt;.iso&lt;/em&gt; a mi máquina con &lt;em&gt;VirtualBox&lt;/em&gt; y montándola antes de hacer el &lt;em&gt;boot&lt;/em&gt; de cada máquina, puedo usar la herramienta &lt;em&gt;zerofree&lt;/em&gt; libremente, sin instalarla en las máquinas virtuales. Tras ello, el compactado de los ficheros &lt;em&gt;.vdi&lt;/em&gt; libera los megabytes a cientos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@virtualbox:~/VirtualBox VMs&lt;span class="nv"&gt;$ &lt;/span&gt;VBoxManage modifyvdi Debian/Debian.vdi --compact
...
gerard@virtualbox:~/VirtualBox VMs&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En este caso concreto, la máquina &lt;strong&gt;Debian&lt;/strong&gt; (&lt;em&gt;netinstall&lt;/em&gt;) volvió a ocupar 700 mb, que es mucho mas interesante teniendo en cuenta que es la imagen que suelo clonar para hacer otras máquinas virtuales.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="zerofree"></category><category term="debootstrap"></category><category term="squashfs"></category><category term="genisoimage"></category><category term="isolinux"></category><category term="iso"></category><category term="livecd"></category></entry><entry><title>Creando sistemas de ficheros temporales con tmpfs</title><link href="http://www.linuxsysadmin.tk/2015/11/creando-sistemas-de-ficheros-temporales-con-tmpfs.html" rel="alternate"></link><updated>2015-11-16T23:15:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-11-16:2015/11/creando-sistemas-de-ficheros-temporales-con-tmpfs.html</id><summary type="html">&lt;p&gt;A veces nos podemos encontrar con un sistema de ficheros lleno que no nos permite completar alguna acción por falta de espacio en disco. En un caso así, existe la posibilidad de sacar un sistema de ficheros completo de memoria, de una forma temporal, usando el sistema de ficheros &lt;em&gt;tmpfs&lt;/em&gt;. Otra opción es la de tener un sistema de ficheros temporal, en donde podamos dejar ficheros cuya persistencia no sea necesaria entre reinicios.&lt;/p&gt;
&lt;p&gt;El primer paso es tener un &lt;em&gt;punto de montaje&lt;/em&gt;, que sea la carpeta en la que se va a montar el nuevo sistema de fichero. Por ejemplo podemos usar el punto de montaje &lt;em&gt;/mnt/auxiliar&lt;/em&gt;; empezaremos creándolo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkdir /mnt/auxiliar
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Observemos como la carpeta creada se construye sobre el mismo dispositivo que la partición raíz:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# df -h /mnt/auxiliar/
S.ficheros     Tamaño Usados  Disp Uso% Montado en
/dev/sda1        2,0G   640M  1,2G  35% /
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creando el sistema de ficheros de forma temporal&lt;/h2&gt;
&lt;p&gt;Como prueba de concepto, podemos crear este sistema de ficheros de forma temporal. En caso de no salir bien, los efectos no serían permanentes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mount -o &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;100M -t tmpfs auxiliar /mnt/auxiliar/
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Podemos ver como la carpeta pertenece ahora a un sistema de ficheros nuevo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# df -h /mnt/auxiliar/
S.ficheros     Tamaño Usados  Disp Uso% Montado en
auxiliar            100M      &lt;span class="m"&gt;0&lt;/span&gt;  100M   0% /mnt/auxiliar
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cuando nos cansemos del nuevo sistema de ficheros, haya cumplido con su utilidad y ya no necesitemos su contenido, la podemos desmontar; vamos a perder todos los ficheros dentro del sistema de ficheros temporal.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# umount /mnt/auxiliar/
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Haciendo el cambio permanente&lt;/h2&gt;
&lt;p&gt;Si nos interesa que este sistema de fichero se &lt;em&gt;monte&lt;/em&gt; y se &lt;em&gt;desmonte&lt;/em&gt; cada vez que la máquina se inicie y se apague, basta con usar el mecanismo estándar de todo sistema de ficheros &lt;em&gt;Linux&lt;/em&gt;: el fichero &lt;em&gt;/etc/fstab&lt;/em&gt;. Basta con añadir una línea nueva con las especificaciones de este punto de montaje, por ejemplo en el final del mismo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# tail -1 /etc/fstab 
auxiliar /mnt/auxiliar tmpfs &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;100M &lt;span class="m"&gt;0&lt;/span&gt; 0
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Con este cambio es suficiente para las sesiones venideras. En caso de querer disponer inmediatamente del sistema de ficheros podemos solicitar el montaje con un comando &lt;em&gt;mount&lt;/em&gt; normal, comando que va a usar las especificaciones del fichero &lt;em&gt;/etc/fstab&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mount /mnt/auxiliar
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto queda completado nuestro objetivo.&lt;/p&gt;</summary><category term="linux"></category><category term="tmpfs"></category></entry><entry><title>Escribiendo units en systemd</title><link href="http://www.linuxsysadmin.tk/2015/11/escribiendo-units-en-systemd.html" rel="alternate"></link><updated>2015-11-09T22:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-11-09:2015/11/escribiendo-units-en-systemd.html</id><summary type="html">&lt;p&gt;Cuando se anunció &lt;em&gt;systemd&lt;/em&gt; me llamó la atención que además de las funciones estándares de otros sistemas de &lt;em&gt;init&lt;/em&gt; (por ejemplo &lt;em&gt;sysvinit&lt;/em&gt;), también se ofrecían otras funcionalidades normalmente delegadas a otros procesos, como por ejemplo, la posibilidad de reiniciar procesos automáticamente o de lanzar procesos temporales al estilo de &lt;em&gt;cron&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;En este artículo se explica como escribir estos ficheros que rigen las tareas propias del sistema &lt;em&gt;init&lt;/em&gt; para iniciar procesos que no disponen de tales facilidades. Adicionalmente, vamos a ver como beneficiarnos del sistema de plantillas de estos mismos ficheros para evitarnos tener que repetirnos, de acuerdo con el principio &lt;a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"&gt;DRY (don't repeat yourself)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Como ejemplo, vamos a utilizar un sistema básico de &lt;em&gt;Linux&lt;/em&gt; con &lt;em&gt;systemd&lt;/em&gt;; que podría ser &lt;em&gt;RedHat 7&lt;/em&gt;, &lt;em&gt;ArchLinux&lt;/em&gt; o &lt;em&gt;Debian 8&lt;/em&gt;. En este caso, se va a utilizar un sistema &lt;em&gt;Debian Jessie&lt;/em&gt; con una instalación básica &lt;em&gt;netinstall&lt;/em&gt; con &lt;em&gt;SSH&lt;/em&gt; y nada mas.&lt;/p&gt;
&lt;p&gt;Vamos a suponer que queremos montar un servidor con 2 instancias de &lt;em&gt;MongoDB&lt;/em&gt;, escuchando en los puertos 27001 y 27002. Empecemos con montar una estructura en &lt;em&gt;/opt/&lt;/em&gt; para contener todo lo relacionado con este despliegue. La idea es que vamos a levantar el binario &lt;em&gt;mongod&lt;/em&gt; con dos configuraciones distintas. Por eso, de momento basta con poner el binario &lt;em&gt;mongod&lt;/em&gt;, las dos configuraciones y las dos carpetas de datos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# tree /opt/
/opt/
└── mongodb
    ├── bin
    │   └── mongod
    ├── conf
    │   ├── mongo1.conf
    │   └── mongo2.conf
    ├── data
    │   ├── mongo1
    │   └── mongo2
    └── logs

&lt;span class="m"&gt;7&lt;/span&gt; directories, &lt;span class="m"&gt;3&lt;/span&gt; files
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La configuración de ambos procesos va a ser la mínima necesaria para que los procesos no entren en conflicto entre ellos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /opt/mongodb/conf/mongo1.conf 
systemLog:
    path: /opt/mongodb/logs/mongo1.log
    logAppend: &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="nb"&gt;    &lt;/span&gt;destination: file

net:
    port: 27001

storage:
    dbPath: /opt/mongodb/data/mongo1
    smallFiles: &lt;span class="nb"&gt;true&lt;/span&gt;
root@server:~# cat /opt/mongodb/conf/mongo2.conf 
systemLog:
    path: /opt/mongodb/logs/mongo2.log
    logAppend: &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="nb"&gt;    &lt;/span&gt;destination: file

net:
    port: 27002

storage:
    dbPath: /opt/mongodb/data/mongo2
    smallFiles: &lt;span class="nb"&gt;true&lt;/span&gt;
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como apunte importante, no se ha definido un archivo para guardar el &lt;em&gt;PID&lt;/em&gt; del proceso; &lt;em&gt;systemd&lt;/em&gt; no lo necesita y conoce el &lt;em&gt;PID&lt;/em&gt; de los procesos que levanta.&lt;/p&gt;
&lt;p&gt;Siguiendo las directivas de seguridad mínimas, los dos procesos &lt;em&gt;mongod&lt;/em&gt; van a levantarse con un usuario estándar que no sea &lt;em&gt;root&lt;/em&gt;. En este caso, toda la carpeta &lt;em&gt;/opt/mongodb/&lt;/em&gt; pertenece al usuario &lt;em&gt;mongo&lt;/em&gt;, aunque bastaría con la carpeta de datos y la de logs.&lt;/p&gt;
&lt;p&gt;Ponemos la definición de nuestras &lt;strong&gt;units&lt;/strong&gt; en la carpeta designada según el estándar, que es &lt;em&gt;/etc/systemd/system/&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/systemd/system/mongo1.service 
&lt;span class="o"&gt;[&lt;/span&gt;Unit&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;MongoDB

&lt;span class="o"&gt;[&lt;/span&gt;Service&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;mongo
&lt;span class="nv"&gt;LimitFSIZE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitCPU&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitNOFILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;LimitNPROC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;ExecStartPre&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/bin/rm -f /opt/mongodb/data/mongo1/mongod.lock
&lt;span class="nv"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/opt/mongodb/bin/mongod -f /opt/mongodb/conf/mongo1.conf

&lt;span class="o"&gt;[&lt;/span&gt;Install&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;multi-user.target
root@server:~# cat /etc/systemd/system/mongo2.service 
&lt;span class="o"&gt;[&lt;/span&gt;Unit&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;MongoDB

&lt;span class="o"&gt;[&lt;/span&gt;Service&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;mongo
&lt;span class="nv"&gt;LimitFSIZE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitCPU&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitNOFILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;LimitNPROC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;ExecStartPre&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/bin/rm -f /opt/mongodb/data/mongo2/mongod.lock
&lt;span class="nv"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/opt/mongodb/bin/mongod -f /opt/mongodb/conf/mongo2.conf

&lt;span class="o"&gt;[&lt;/span&gt;Install&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;multi-user.target
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Es especialmente interesante ver que el lenguaje de la &lt;strong&gt;units&lt;/strong&gt; de &lt;em&gt;systemd&lt;/em&gt; es declarativo, y que no son &lt;em&gt;init scripts&lt;/em&gt;; &lt;em&gt;systemd&lt;/em&gt; se encarga de todo por nosotros. Basta con declarar el comando con el que levantar el servicio y el usuario con el que hacerlo.&lt;/p&gt;
&lt;p&gt;La directiva &lt;strong&gt;WantedBy&lt;/strong&gt; indica que se tiene que levantar con el &lt;strong&gt;target&lt;/strong&gt; &lt;em&gt;multi-user&lt;/em&gt;, que es el que usa &lt;em&gt;Debian&lt;/em&gt; por defecto. Un &lt;strong&gt;target&lt;/strong&gt; viene a ser el equivalente a un &lt;em&gt;runlevel&lt;/em&gt; de &lt;em&gt;sysvinit&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Hay una directiva &lt;strong&gt;ExecStartPre&lt;/strong&gt; que se encarga de eliminar el &lt;em&gt;lock file&lt;/em&gt; de &lt;em&gt;MongoDB&lt;/em&gt; por si el proceso hubiera acabado de forma inesperada. El binario &lt;em&gt;mongod&lt;/em&gt; no levanta si este fichero existe, ya que cree que ya hay una instancia de &lt;em&gt;mongod&lt;/em&gt; usando la carpeta de datos.&lt;/p&gt;
&lt;p&gt;El resto de directivas se limitan a modificar los límites de los procesos a levantar, de acuerdo a la documentación de &lt;em&gt;MongoDB&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A partir de ahora, son &lt;strong&gt;units&lt;/strong&gt; normales del sistema y se pueden activar e iniciar. Si ya estuvieran cargados, habría que recargar la configuración de &lt;em&gt;systemd&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# systemctl &lt;span class="nb"&gt;enable &lt;/span&gt;mongo1
root@server:~# systemctl &lt;span class="nb"&gt;enable &lt;/span&gt;mongo2
root@server:~# systemctl start mongo1
root@server:~# systemctl start mongo2
root@server:~# systemctl daemon-reload
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Uso de plantillas para evitar repetirnos&lt;/h2&gt;
&lt;p&gt;Toda &lt;strong&gt;unit&lt;/strong&gt; cuyo nombre acabe en &lt;strong&gt;arroba&lt;/strong&gt; seguido por &lt;em&gt;.service&lt;/em&gt; o cualquier otro tipo de &lt;strong&gt;unit&lt;/strong&gt;, es por convención, una &lt;strong&gt;plantilla&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;La idea es que vamos a crear un &lt;em&gt;link&lt;/em&gt; a la &lt;strong&gt;plantilla&lt;/strong&gt;, que ponga un texto detrás de la &lt;strong&gt;arroba&lt;/strong&gt;. Este texto va a estar disponible en la plantilla como &lt;strong&gt;%i&lt;/strong&gt;. De esta forma podemos "pasar un parámetro" a la plantilla, usando ese parámetro como diferenciador de los dos procesos.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Veamos un ejemplo:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Creamos dos &lt;em&gt;links&lt;/em&gt; a la &lt;strong&gt;plantilla&lt;/strong&gt; &lt;em&gt;mongodb@.service&lt;/em&gt;, con los nombres &lt;em&gt;mongodb@mongo1.service&lt;/em&gt; y &lt;em&gt;mongodb@mongo2.service&lt;/em&gt;, que son nuestras instancias. Estas instancias se rigen con las directivas de la &lt;strong&gt;plantilla&lt;/strong&gt;, con la variable &lt;strong&gt;%i&lt;/strong&gt; conteniendo los valores &lt;em&gt;mongo1&lt;/em&gt; y &lt;em&gt;mongo2&lt;/em&gt; respectivamente.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# ls -l /etc/systemd/system/mongodb&lt;span class="se"&gt;\@&lt;/span&gt;*
lrwxrwxrwx &lt;span class="m"&gt;1&lt;/span&gt; root root  &lt;span class="m"&gt;16&lt;/span&gt; nov  &lt;span class="m"&gt;3&lt;/span&gt; 12:46 /etc/systemd/system/mongodb@mongo1.service -&amp;gt; mongodb@.service
lrwxrwxrwx &lt;span class="m"&gt;1&lt;/span&gt; root root  &lt;span class="m"&gt;16&lt;/span&gt; nov  &lt;span class="m"&gt;3&lt;/span&gt; 12:46 /etc/systemd/system/mongodb@mongo2.service -&amp;gt; mongodb@.service
-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;207&lt;/span&gt; nov  &lt;span class="m"&gt;3&lt;/span&gt; 12:45 /etc/systemd/system/mongodb@.service
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora redactamos la plantilla, teniendo en cuenta los valores que se van a cambiarse por la variable &lt;strong&gt;%i&lt;/strong&gt;, que vamos a usar para identificar el fichero de configuración de cada instancia. También es posible poner otras variables en la &lt;strong&gt;plantilla&lt;/strong&gt;, como por ejemplo, el nombre de la máquina o la versión del &lt;em&gt;kernel&lt;/em&gt; de la máquina.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# cat /etc/systemd/system/mongodb&lt;span class="se"&gt;\@&lt;/span&gt;.service 
&lt;span class="o"&gt;[&lt;/span&gt;Unit&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;MongoDB

&lt;span class="o"&gt;[&lt;/span&gt;Service&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;mongo
&lt;span class="nv"&gt;LimitFSIZE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitCPU&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;infinity
&lt;span class="nv"&gt;LimitNOFILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;LimitNPROC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64000
&lt;span class="nv"&gt;ExecStartPre&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/bin/rm -f /opt/mongodb/data/%i/mongod.lock
&lt;span class="nv"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/opt/mongodb/bin/mongod -f /opt/mongodb/conf/%i.conf

&lt;span class="o"&gt;[&lt;/span&gt;Install&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;multi-user.target
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora solo falta activar las instancias e iniciarlas, con los comandos habituales del demonio &lt;em&gt;systemd&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# systemctl &lt;span class="nb"&gt;enable &lt;/span&gt;mongodb@mongo1
Created symlink from /etc/systemd/system/multi-user.target.wants/mongodb@mongo1.service to /etc/systemd/system/mongodb@.service.
root@server:~# systemctl &lt;span class="nb"&gt;enable &lt;/span&gt;mongodb@mongo2
Created symlink from /etc/systemd/system/multi-user.target.wants/mongodb@mongo2.service to /etc/systemd/system/mongodb@.service.
root@server:~# systemctl start mongodb@mongo1
root@server:~# systemctl start mongodb@mongo2
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto lo hemos conseguido.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="systemd"></category><category term="mongodb"></category></entry><entry><title>Restart automático de servicios con systemd</title><link href="http://www.linuxsysadmin.tk/2015/11/restart-automatico-de-servicios-con-systemd.html" rel="alternate"></link><updated>2015-11-05T22:30:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-11-05:2015/11/restart-automatico-de-servicios-con-systemd.html</id><summary type="html">&lt;p&gt;Cuando estamos gestionando un servidor, es posible que se caiga alguno de sus servicios. Esto es especialmente molesto cuando nos interesa tener un &lt;em&gt;uptime&lt;/em&gt; elevado. Para conseguirlo, se han utilizado diferentes maneras, desde poner personas a monitorizar en modo 24x7 hasta herramientas auxiliares como gestores tipo &lt;em&gt;runit&lt;/em&gt;, &lt;em&gt;supervisor&lt;/em&gt; o &lt;em&gt;monit&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Con la entrada en escena de &lt;em&gt;systemd&lt;/em&gt; en la mayoría de distribuciones grandes de &lt;em&gt;linux&lt;/em&gt; este problema se ha acabado; el mismo proceso que hace de &lt;strong&gt;init&lt;/strong&gt; puede encargarse de mantener los procesos levantados, y reiniciarlos en caso de caída.&lt;/p&gt;
&lt;p&gt;En este tutorial pretendo hacer que un servicio estándar se vea beneficiado de un &lt;strong&gt;override&lt;/strong&gt;, que permita el inicio automático de un servicio cuando se cae, sin tener que reescribir la &lt;strong&gt;unit&lt;/strong&gt; que se encarga del servicio o proceso.&lt;/p&gt;
&lt;p&gt;Partimos de un servidor básico &lt;em&gt;Linux&lt;/em&gt; con &lt;em&gt;systemd&lt;/em&gt;. En este caso vamos a utilizar la última versión estable de &lt;em&gt;Debian&lt;/em&gt;, a la que le vamos a instalar un servicio estándar como &lt;em&gt;nginx&lt;/em&gt; que nos va a servir como conejillo de indias.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# apt-get install nginx-light
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Procedimiento&lt;/h2&gt;
&lt;p&gt;Como comprobación previa, observemos como este &lt;strong&gt;restart&lt;/strong&gt; automático no funciona; tenemos el servicio en ejecución, lo matamos y observamos que no se levanta de nuevo, por mucho que esperemos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;685&lt;/span&gt;  0.0  0.8   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2240&lt;/span&gt; pts/0    S+   11:41   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;662&lt;/span&gt;  0.0  0.7   &lt;span class="m"&gt;6356&lt;/span&gt;  &lt;span class="m"&gt;1856&lt;/span&gt; ?        Ss   11:41   0:00 nginx: master process /usr/sbin/nginx -g daemon on&lt;span class="p"&gt;;&lt;/span&gt; master_process on&lt;span class="p"&gt;;&lt;/span&gt;
www-data   &lt;span class="m"&gt;663&lt;/span&gt;  0.1  0.9   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2456&lt;/span&gt; ?        S    11:41   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;664&lt;/span&gt;  0.0  0.9   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2456&lt;/span&gt; ?        S    11:41   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;665&lt;/span&gt;  0.0  0.9   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2456&lt;/span&gt; ?        S    11:41   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;666&lt;/span&gt;  0.1  0.9   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2456&lt;/span&gt; ?        S    11:41   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
root@server:~# &lt;span class="nb"&gt;kill &lt;/span&gt;662
root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;691&lt;/span&gt;  0.0  0.8   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2220&lt;/span&gt; pts/0    S+   11:41   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora necesitamos localizar el nombre de la &lt;strong&gt;unit&lt;/strong&gt; que se encarga de ese servicio, puesto que la carpeta de &lt;strong&gt;overrides&lt;/strong&gt; debe llamarse igual.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# systemctl list-units -a &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
  nginx.service    loaded    inactive dead    A high performance web server and a reverse proxy server
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como curiosidad, este fichero se encuentra en &lt;em&gt;/lib/systemd/system/&lt;/em&gt;, siguiendo las convenciones del empaquetado de &lt;em&gt;Debian&lt;/em&gt;. Alternativamente, podemos localizar los ficheros instalados por un paquete con el comando &lt;em&gt;dpkg -L nginx-light&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# ls -lh /lib/systemd/system/nginx.service 
-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; root root &lt;span class="m"&gt;986&lt;/span&gt; dic  &lt;span class="m"&gt;1&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; /lib/systemd/system/nginx.service
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En caso de ser una &lt;strong&gt;unit&lt;/strong&gt; escrita por nosotros, se encontraría en &lt;em&gt;/etc/systemd/system/&lt;/em&gt;. Esta es la convención:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;/lib/systemd/system/&lt;/em&gt; &amp;rarr; &lt;strong&gt;units&lt;/strong&gt; de sistema, puestas por los paquetes instalados&lt;/li&gt;
&lt;li&gt;&lt;em&gt;/lib/systemd/system/&lt;/em&gt; &amp;rarr; &lt;strong&gt;units&lt;/strong&gt; o &lt;strong&gt;overrides&lt;/strong&gt; puestos por el usuario (nosotros)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para añadir nuevas directivas (&lt;strong&gt;overrides&lt;/strong&gt;) a una &lt;strong&gt;unit&lt;/strong&gt; sin reescribirla entera, basta con crear una carpeta con su mismo nombre, concatenando &lt;strong&gt;.d&lt;/strong&gt;. Dentro podemos poner tantos ficheros &lt;em&gt;.conf&lt;/em&gt; como creamos necesarios, añadiendo las directivas que queramos añadir o modificar.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# mkdir /etc/systemd/system/nginx.service.d
root@server:~# cat /etc/systemd/system/nginx.service.d/autorestart.conf
&lt;span class="o"&gt;[&lt;/span&gt;Service&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;Restart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;always
&lt;span class="nv"&gt;RestartSec&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En este caso, se ha indicado que queremos un &lt;strong&gt;restart&lt;/strong&gt; siempre, sean cuales sean las circunstancias en las que se cayó el proceso, y que espere 1 segundo antes de intentarlo. Por como está hecho &lt;em&gt;systemd&lt;/em&gt;, &lt;strong&gt;no&lt;/strong&gt; va a levantar un servicio que hemos parado invocando el comando &lt;em&gt;systemctl&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Para que los cambios en el fichero de configuración se apliquen es necesario recargar las configuraciones, indicando a &lt;em&gt;systemd&lt;/em&gt; que tienen que recargarlas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# systemctl daemon-reload
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Comprobación&lt;/h2&gt;
&lt;p&gt;Básicamente vamos a repetir el paso de la comprobación; se localiza el proceso &lt;strong&gt;master&lt;/strong&gt; y se finaliza (por ejemplo, con un &lt;strong&gt;SIGTERM&lt;/strong&gt; normal).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;782&lt;/span&gt;  0.0  0.8   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2252&lt;/span&gt; pts/0    S+   11:56   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;776&lt;/span&gt;  0.0  0.7   &lt;span class="m"&gt;6356&lt;/span&gt;  &lt;span class="m"&gt;1936&lt;/span&gt; ?        Ss   11:56   0:00 nginx: master process /usr/sbin/nginx -g daemon on&lt;span class="p"&gt;;&lt;/span&gt; master_process on&lt;span class="p"&gt;;&lt;/span&gt;
www-data   &lt;span class="m"&gt;777&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2536&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;778&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2536&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;779&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2536&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;780&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2536&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
root@server:~# &lt;span class="nb"&gt;kill &lt;/span&gt;776
root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;787&lt;/span&gt;  0.0  0.9   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2280&lt;/span&gt; pts/0    S+   11:56   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ahora solo hay que esperar el paso de los segundos configurados, y volver a ver si el servicio está corriendo; aunque en este esperé algo menos de lo configurado; la paciencia no es una de mis virtudes...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;789&lt;/span&gt;  0.0  0.8   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2192&lt;/span&gt; pts/0    S+   11:56   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;791&lt;/span&gt;  0.0  0.9   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2280&lt;/span&gt; pts/0    S+   11:56   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root@server:~# ps faux &lt;span class="p"&gt;|&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;802&lt;/span&gt;  0.0  0.8   &lt;span class="m"&gt;4556&lt;/span&gt;  &lt;span class="m"&gt;2236&lt;/span&gt; pts/0    S+   11:56   0:00          &lt;span class="se"&gt;\_&lt;/span&gt; grep nginx
root       &lt;span class="m"&gt;796&lt;/span&gt;  0.0  0.7   &lt;span class="m"&gt;6356&lt;/span&gt;  &lt;span class="m"&gt;1932&lt;/span&gt; ?        Ss   11:56   0:00 nginx: master process /usr/sbin/nginx -g daemon on&lt;span class="p"&gt;;&lt;/span&gt; master_process on&lt;span class="p"&gt;;&lt;/span&gt;
www-data   &lt;span class="m"&gt;797&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2592&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;798&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2592&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;799&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2592&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
www-data   &lt;span class="m"&gt;800&lt;/span&gt;  0.0  1.0   &lt;span class="m"&gt;6504&lt;/span&gt;  &lt;span class="m"&gt;2532&lt;/span&gt; ?        S    11:56   0:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process                           
root@server:~# 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y con esto tenemos nuestro &lt;strong&gt;autorestart&lt;/strong&gt; para este servicio.&lt;/p&gt;</summary><category term="linux"></category><category term="debian"></category><category term="jessie"></category><category term="systemd"></category><category term="nginx"></category></entry><entry><title>Liberando memoria caché</title><link href="http://www.linuxsysadmin.tk/2015/11/liberando-memoria-cache.html" rel="alternate"></link><updated>2015-11-02T14:00:00+01:00</updated><author><name>Gerard</name></author><id>tag:www.linuxsysadmin.tk,2015-11-02:2015/11/liberando-memoria-cache.html</id><summary type="html">&lt;p&gt;A veces nos encontramos que nuestro sistema linux parece tener la memoria &lt;em&gt;virtual&lt;/em&gt; ocupada, cuando no tenemos nada de memoria &lt;em&gt;RSS&lt;/em&gt;; esto no es un problema, ya que por la forma de funcionar del &lt;em&gt;memory manager&lt;/em&gt; de linux, se conserva "por si acaso" y se libera cuando realmente se necesita.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;free -m
             total       used       free     shared    buffers     cached
Mem:          &lt;span class="m"&gt;3858&lt;/span&gt;       &lt;span class="m"&gt;3226&lt;/span&gt;        &lt;span class="m"&gt;632&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;        &lt;span class="m"&gt;114&lt;/span&gt;       2545
-/+ buffers/cache:        &lt;span class="m"&gt;566&lt;/span&gt;       3291
Swap:         &lt;span class="m"&gt;2381&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;       2381
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sin embargo este detalle nos puede resultar molesto y puede que queramos &lt;strong&gt;liberar&lt;/strong&gt; esa memoria de verdad, por ejemplo, para comparar memoria real ocupada por el sistema o sencillamente porque así lo queremos.&lt;/p&gt;
&lt;p&gt;En este caso no tenemos mas remedio que solicitar el &lt;em&gt;memory manager&lt;/em&gt; que la libere, escribiendo en el fichero de control habilitado para ello, de acuerdo a la &lt;a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt"&gt;documentación del &lt;em&gt;kernel&lt;/em&gt; de linux&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;drop_caches

Writing to this will cause the kernel to drop clean caches, as well as
reclaimable slab objects like dentries and inodes.  Once dropped, their
memory becomes free.

To free pagecache:
    &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &amp;gt; /proc/sys/vm/drop_caches
To free reclaimable slab objects &lt;span class="o"&gt;(&lt;/span&gt;includes dentries and inodes&lt;span class="o"&gt;)&lt;/span&gt;:
    &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt; &amp;gt; /proc/sys/vm/drop_caches
To free slab objects and pagecache:
    &lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt; &amp;gt; /proc/sys/vm/drop_caches

This is a non-destructive operation and will not free any dirty objects.
To increase the number of objects freed by this operation, the user may run
&lt;span class="sb"&gt;`&lt;/span&gt;sync&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; prior to writing to /proc/sys/vm/drop_caches.  This will minimize the
number of dirty objects on the system and create more candidates to be
dropped.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Este fichero viene por defecto con permisos de escritura solamente para el usuario &lt;strong&gt;root&lt;/strong&gt; y no se puede escribir sin el mismo. Como no queremos trabajar con el usuario &lt;strong&gt;root&lt;/strong&gt;, vamos a usar el comando &lt;em&gt;sudo&lt;/em&gt; con un usuario normal:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;sudo bash -c &lt;span class="s2"&gt;&amp;quot;echo 3 &amp;gt; /proc/sys/vm/drop_caches&amp;quot;&lt;/span&gt;
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Alternativamente, podemos utilizar el comando &lt;em&gt;tee&lt;/em&gt; para realizar la misma operación, sin el envoltorio de &lt;em&gt;bash&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sudo tee /proc/sys/vm/drop_caches
3
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y finalmente nuestra memoria queda vacía de todo aquello que no era indispensable para la ejecución del sistema.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;free -m
             total       used       free     shared    buffers     cached
Mem:          &lt;span class="m"&gt;3858&lt;/span&gt;        &lt;span class="m"&gt;752&lt;/span&gt;       &lt;span class="m"&gt;3105&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;          &lt;span class="m"&gt;2&lt;/span&gt;        207
-/+ buffers/cache:        &lt;span class="m"&gt;542&lt;/span&gt;       3315
Swap:         &lt;span class="m"&gt;2381&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;       2381
gerard@desktop:~&lt;span class="nv"&gt;$ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;¡Acabamos de liberar 2 gigabytes de memoria!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CUIDADO&lt;/strong&gt;: Esta operación puede afectar el rendimiento puntual del sistema, ya que en caso de volver a necesitar la información &lt;em&gt;cacheada&lt;/em&gt;, deberá volver a recargar la memoria, probablemente desde disco.&lt;/p&gt;</summary><category term="linux"></category><category term="kernel"></category><category term="memory manager"></category><category term="drop caches"></category></entry></feed>